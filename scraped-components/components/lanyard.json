{
  "name": "Lanyard",
  "description": "An open source collection of high quality, animated, interactive & fully customizable React components for building stunning, memorable user interfaces.",
  "props": {},
  "dependencies": [],
  "url": "https://www.reactbits.dev/components/lanyard",
  "code": "1npm i three meshline @react-three/fiber @react-three/drei @react-three/rapier\n\n1import Lanyard from './Lanyard'\n2\n3<Lanyard position={[0, 0, 20]} gravity={[0, -40, 0]} />\n4\n5/* IMPORTANT INFO BELOW\n6\n71. You MUST have the card.glb and lanyard.png files in your project and import them\n8- these can be downloaded from the repo's files, under src/assets/lanyard\n9\n102. You can edit your card.glb file in this online .glb editor and change the texture:\n11- https://modelviewer.dev/editor/\n12\n134. The png file is the texture for the lanyard's band and can be edited in any image editor\n14\n155. Your Vite configuration must be updated to include the following in vite.config.js:\n16assetsInclude: ['**/*.glb']\n17\n186. For TS users, you might need these changes:\n19\n20- src/global.d.ts\n21export { };\n22\n23declare module '*.glb';\n24declare module '*.png';\n25\n26declare module 'meshline' {\n27  export const MeshLineGeometry: any;\n28  export const MeshLineMaterial: any;\n29}\n30\n31declare global {\n32  namespace JSX {\n33    interface IntrinsicElements {\n34      meshLineGeometry: any;\n35      meshLineMaterial: any;\n36    }\n37  }\n38}\n39\n40- src/vite-env.d.ts\n41/// <reference types=\"vite/client\" />\n42declare module '*.glb';\n43declare module '*.png';\n44*/\n\n1/* eslint-disable react/no-unknown-property */\n2'use client';\n3import { useEffect, useRef, useState } from 'react';\n4import { Canvas, extend, useFrame } from '@react-three/fiber';\n5import { useGLTF, useTexture, Environment, Lightformer } from '@react-three/drei';\n6import { BallCollider, CuboidCollider, Physics, RigidBody, useRopeJoint, useSphericalJoint } from '@react-three/rapier';\n7import { MeshLineGeometry, MeshLineMaterial } from 'meshline';\n8\n9import cardGLB from \"./card.glb\";\n10import lanyard from \"./lanyard.png\";\n11\n12import * as THREE from 'three';\n13import './Lanyard.css';\n14\n15extend({ MeshLineGeometry, MeshLineMaterial });\n16\n17export default function Lanyard({ position = [0, 0, 30], gravity = [0, -40, 0], fov = 20, transparent = true }) {\n18  return (\n19    <div className=\"lanyard-wrapper\">\n20      <Canvas\n21        camera={{ position: position, fov: fov }}\n22        gl={{ alpha: transparent }}\n23        onCreated={({ gl }) => gl.setClearColor(new THREE.Color(0x000000), transparent ? 0 : 1)}\n24      >\n25        <ambientLight intensity={Math.PI} />\n26        <Physics gravity={gravity} timeStep={1 / 60}>\n27          <Band />\n28        </Physics>\n29        <Environment blur={0.75}>\n30          <Lightformer intensity={2} color=\"white\" position={[0, -1, 5]} rotation={[0, 0, Math.PI / 3]} scale={[100, 0.1, 1]} />\n31          <Lightformer intensity={3} color=\"white\" position={[-1, -1, 1]} rotation={[0, 0, Math.PI / 3]} scale={[100, 0.1, 1]} />\n32          <Lightformer intensity={3} color=\"white\" position={[1, 1, 1]} rotation={[0, 0, Math.PI / 3]} scale={[100, 0.1, 1]} />\n33          <Lightformer intensity={10} color=\"white\" position={[-10, 0, 14]} rotation={[0, Math.PI / 2, Math.PI / 3]} scale={[100, 10, 1]} />\n34        </Environment>\n35      </Canvas>\n36    </div>\n37  );\n38}\n39function Band({ maxSpeed = 50, minSpeed = 0 }) {\n40  const band = useRef(), fixed = useRef(), j1 = useRef(), j2 = useRef(), j3 = useRef(), card = useRef();\n41  const vec = new THREE.Vector3(), ang = new THREE.Vector3(), rot = new THREE.Vector3(), dir = new THREE.Vector3();\n42  const segmentProps = { type: 'dynamic', canSleep: true, colliders: false, angularDamping: 4, linearDamping: 4 };\n43  const { nodes, materials } = useGLTF(cardGLB);\n44  const texture = useTexture(lanyard);\n45  const [curve] = useState(() => new THREE.CatmullRomCurve3([new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()]));\n46  const [dragged, drag] = useState(false);\n47  const [hovered, hover] = useState(false);\n48  const [isSmall, setIsSmall] = useState(() =>\n49    typeof window !== 'undefined' && window.innerWidth < 1024\n50  );\n51\n52  useRopeJoint(fixed, j1, [[0, 0, 0], [0, 0, 0], 1]);\n53  useRopeJoint(j1, j2, [[0, 0, 0], [0, 0, 0], 1]);\n54  useRopeJoint(j2, j3, [[0, 0, 0], [0, 0, 0], 1]);\n55  useSphericalJoint(j3, card, [[0, 0, 0], [0, 1.50, 0]]);\n56\n57  useEffect(() => {\n58    if (hovered) {\n59      document.body.style.cursor = dragged ? 'grabbing' : 'grab';\n60      return () => void (document.body.style.cursor = 'auto');\n61    }\n62  }, [hovered, dragged]);\n63\n64  useEffect(() => {\n65    const handleResize = () => {\n66      setIsSmall(window.innerWidth < 1024);\n67    };\n68\n69    window.addEventListener('resize', handleResize);\n70\n71    return () => window.removeEventListener('resize', handleResize);\n72  }, []);\n73\n74  useFrame((state, delta) => {\n75    if (dragged) {\n76      vec.set(state.pointer.x, state.pointer.y, 0.5).unproject(state.camera);\n77      dir.copy(vec).sub(state.camera.position).normalize();\n78      vec.add(dir.multiplyScalar(state.camera.position.length()));\n79      [card, j1, j2, j3, fixed].forEach((ref) => ref.current?.wakeUp());\n80      card.current?.setNextKinematicTranslation({ x: vec.x - dragged.x, y: vec.y - dragged.y, z: vec.z - dragged.z });\n81    }\n82    if (fixed.current) {\n83      [j1, j2].forEach((ref) => {\n84        if (!ref.current.lerped) ref.current.lerped = new THREE.Vector3().copy(ref.current.translation());\n85        const clampedDistance = Math.max(0.1, Math.min(1, ref.current.lerped.distanceTo(ref.current.translation())));\n86        ref.current.lerped.lerp(ref.current.translation(), delta * (minSpeed + clampedDistance * (maxSpeed - minSpeed)));\n87      });\n88      curve.points[0].copy(j3.current.translation());\n89      curve.points[1].copy(j2.current.lerped);\n90      curve.points[2].copy(j1.current.lerped);\n91      curve.points[3].copy(fixed.current.translation());\n92      band.current.geometry.setPoints(curve.getPoints(32));\n93      ang.copy(card.current.angvel());\n94      rot.copy(card.current.rotation());\n95      card.current.setAngvel({ x: ang.x, y: ang.y - rot.y * 0.25, z: ang.z });\n96    }\n97  });\n98\n99  curve.curveType = 'chordal';\n100  texture.wrapS = texture.wrapT = THREE.RepeatWrapping;\n101\n102  return (\n103    <>\n104      <group position={[0, 4, 0]}>\n105        <RigidBody ref={fixed} {...segmentProps} type=\"fixed\" />\n106        <RigidBody position={[0.5, 0, 0]} ref={j1} {...segmentProps}>\n107          <BallCollider args={[0.1]} />\n108        </RigidBody>\n109        <RigidBody position={[1, 0, 0]} ref={j2} {...segmentProps}>\n110          <BallCollider args={[0.1]} />\n111        </RigidBody>\n112        <RigidBody position={[1.5, 0, 0]} ref={j3} {...segmentProps}>\n113          <BallCollider args={[0.1]} />\n114        </RigidBody>\n115        <RigidBody position={[2, 0, 0]} ref={card} {...segmentProps} type={dragged ? 'kinematicPosition' : 'dynamic'}>\n116          <CuboidCollider args={[0.8, 1.125, 0.01]} />\n117          <group\n118            scale={2.25}\n119            position={[0, -1.2, -0.05]}\n120            onPointerOver={() => hover(true)}\n121            onPointerOut={() => hover(false)}\n122            onPointerUp={(e) => (e.target.releasePointerCapture(e.pointerId), drag(false))}\n123            onPointerDown={(e) => (e.target.setPointerCapture(e.pointerId), drag(new THREE.Vector3().copy(e.point).sub(vec.copy(card.current.translation()))))}>\n124            <mesh geometry={nodes.card.geometry}>\n125              <meshPhysicalMaterial map={materials.base.map} map-anisotropy={16} clearcoat={1} clearcoatRoughness={0.15} roughness={0.9} metalness={0.8} />\n126            </mesh>\n127            <mesh geometry={nodes.clip.geometry} material={materials.metal} material-roughness={0.3} />\n128            <mesh geometry={nodes.clamp.geometry} material={materials.metal} />\n129          </group>\n130        </RigidBody>\n131      </group>\n132      <mesh ref={band}>\n133        <meshLineGeometry />\n134        <meshLineMaterial\n135          color=\"white\"\n136          depthTest={false}\n137          resolution={isSmall ? [1000, 2000] : [1000, 1000]}\n138          useMap\n139          map={texture}\n140          repeat={[-4, 1]}\n141          lineWidth={1}\n142        />\n143      </mesh>\n144    </>\n145  );\n146}\n\n1.lanyard-wrapper {\n2  position: relative;\n3  z-index: 0;\n4  width: 100%;\n5  height: 100vh;\n6  display: flex;\n7  justify-content: center;\n8  align-items: center;\n9  transform: scale(1);\n10  transform-origin: center;\n11}\n\n1/* eslint-disable react/no-unknown-property */\n2'use client';\n3import { useEffect, useRef, useState } from 'react';\n4import { Canvas, extend, useFrame } from '@react-three/fiber';\n5import { useGLTF, useTexture, Environment, Lightformer } from '@react-three/drei';\n6import { BallCollider, CuboidCollider, Physics, RigidBody, useRopeJoint, useSphericalJoint } from '@react-three/rapier';\n7import { MeshLineGeometry, MeshLineMaterial } from 'meshline';\n8\n9import cardGLB from \"./card.glb\";\n10import lanyard from \"./lanyard.png\";\n11\n12import * as THREE from 'three';\n13\n14extend({ MeshLineGeometry, MeshLineMaterial });\n15\n16export default function Lanyard({ position = [0, 0, 30], gravity = [0, -40, 0], fov = 20, transparent = true }) {\n17  return (\n18    <div className=\"relative z-0 w-full h-screen flex justify-center items-center transform scale-100 origin-center\">\n19      <Canvas\n20        camera={{ position: position, fov: fov }}\n21        gl={{ alpha: transparent }}\n22        onCreated={({ gl }) => gl.setClearColor(new THREE.Color(0x000000), transparent ? 0 : 1)}\n23      >\n24        <ambientLight intensity={Math.PI} />\n25        <Physics gravity={gravity} timeStep={1 / 60}>\n26          <Band />\n27        </Physics>\n28        <Environment blur={0.75}>\n29          <Lightformer intensity={2} color=\"white\" position={[0, -1, 5]} rotation={[0, 0, Math.PI / 3]} scale={[100, 0.1, 1]} />\n30          <Lightformer intensity={3} color=\"white\" position={[-1, -1, 1]} rotation={[0, 0, Math.PI / 3]} scale={[100, 0.1, 1]} />\n31          <Lightformer intensity={3} color=\"white\" position={[1, 1, 1]} rotation={[0, 0, Math.PI / 3]} scale={[100, 0.1, 1]} />\n32          <Lightformer intensity={10} color=\"white\" position={[-10, 0, 14]} rotation={[0, Math.PI / 2, Math.PI / 3]} scale={[100, 10, 1]} />\n33        </Environment>\n34      </Canvas>\n35    </div>\n36  );\n37}\n38function Band({ maxSpeed = 50, minSpeed = 0 }) {\n39  const band = useRef(), fixed = useRef(), j1 = useRef(), j2 = useRef(), j3 = useRef(), card = useRef();\n40  const vec = new THREE.Vector3(), ang = new THREE.Vector3(), rot = new THREE.Vector3(), dir = new THREE.Vector3();\n41  const segmentProps = { type: 'dynamic', canSleep: true, colliders: false, angularDamping: 4, linearDamping: 4 };\n42  const { nodes, materials } = useGLTF(cardGLB);\n43  const texture = useTexture(lanyard);\n44  const [curve] = useState(() => new THREE.CatmullRomCurve3([new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()]));\n45  const [dragged, drag] = useState(false);\n46  const [hovered, hover] = useState(false);\n47  const [isSmall, setIsSmall] = useState(() =>\n48    typeof window !== 'undefined' && window.innerWidth < 1024\n49  );\n50\n51  useRopeJoint(fixed, j1, [[0, 0, 0], [0, 0, 0], 1]);\n52  useRopeJoint(j1, j2, [[0, 0, 0], [0, 0, 0], 1]);\n53  useRopeJoint(j2, j3, [[0, 0, 0], [0, 0, 0], 1]);\n54  useSphericalJoint(j3, card, [[0, 0, 0], [0, 1.50, 0]]);\n55\n56  useEffect(() => {\n57    if (hovered) {\n58      document.body.style.cursor = dragged ? 'grabbing' : 'grab';\n59      return () => void (document.body.style.cursor = 'auto');\n60    }\n61  }, [hovered, dragged]);\n62\n63  useEffect(() => {\n64    const handleResize = () => {\n65      setIsSmall(window.innerWidth < 1024);\n66    };\n67\n68    window.addEventListener('resize', handleResize);\n69\n70    return () => window.removeEventListener('resize', handleResize);\n71  }, []);\n72\n73  useFrame((state, delta) => {\n74    if (dragged) {\n75      vec.set(state.pointer.x, state.pointer.y, 0.5).unproject(state.camera);\n76      dir.copy(vec).sub(state.camera.position).normalize();\n77      vec.add(dir.multiplyScalar(state.camera.position.length()));\n78      [card, j1, j2, j3, fixed].forEach((ref) => ref.current?.wakeUp());\n79      card.current?.setNextKinematicTranslation({ x: vec.x - dragged.x, y: vec.y - dragged.y, z: vec.z - dragged.z });\n80    }\n81    if (fixed.current) {\n82      [j1, j2].forEach((ref) => {\n83        if (!ref.current.lerped) ref.current.lerped = new THREE.Vector3().copy(ref.current.translation());\n84        const clampedDistance = Math.max(0.1, Math.min(1, ref.current.lerped.distanceTo(ref.current.translation())));\n85        ref.current.lerped.lerp(ref.current.translation(), delta * (minSpeed + clampedDistance * (maxSpeed - minSpeed)));\n86      });\n87      curve.points[0].copy(j3.current.translation());\n88      curve.points[1].copy(j2.current.lerped);\n89      curve.points[2].copy(j1.current.lerped);\n90      curve.points[3].copy(fixed.current.translation());\n91      band.current.geometry.setPoints(curve.getPoints(32));\n92      ang.copy(card.current.angvel());\n93      rot.copy(card.current.rotation());\n94      card.current.setAngvel({ x: ang.x, y: ang.y - rot.y * 0.25, z: ang.z });\n95    }\n96  });\n97\n98  curve.curveType = 'chordal';\n99  texture.wrapS = texture.wrapT = THREE.RepeatWrapping;\n100\n101  return (\n102    <>\n103      <group position={[0, 4, 0]}>\n104        <RigidBody ref={fixed} {...segmentProps} type=\"fixed\" />\n105        <RigidBody position={[0.5, 0, 0]} ref={j1} {...segmentProps}>\n106          <BallCollider args={[0.1]} />\n107        </RigidBody>\n108        <RigidBody position={[1, 0, 0]} ref={j2} {...segmentProps}>\n109          <BallCollider args={[0.1]} />\n110        </RigidBody>\n111        <RigidBody position={[1.5, 0, 0]} ref={j3} {...segmentProps}>\n112          <BallCollider args={[0.1]} />\n113        </RigidBody>\n114        <RigidBody position={[2, 0, 0]} ref={card} {...segmentProps} type={dragged ? 'kinematicPosition' : 'dynamic'}>\n115          <CuboidCollider args={[0.8, 1.125, 0.01]} />\n116          <group\n117            scale={2.25}\n118            position={[0, -1.2, -0.05]}\n119            onPointerOver={() => hover(true)}\n120            onPointerOut={() => hover(false)}\n121            onPointerUp={(e) => (e.target.releasePointerCapture(e.pointerId), drag(false))}\n122            onPointerDown={(e) => (e.target.setPointerCapture(e.pointerId), drag(new THREE.Vector3().copy(e.point).sub(vec.copy(card.current.translation()))))}>\n123            <mesh geometry={nodes.card.geometry}>\n124              <meshPhysicalMaterial map={materials.base.map} map-anisotropy={16} clearcoat={1} clearcoatRoughness={0.15} roughness={0.9} metalness={0.8} />\n125            </mesh>\n126            <mesh geometry={nodes.clip.geometry} material={materials.metal} material-roughness={0.3} />\n127            <mesh geometry={nodes.clamp.geometry} material={materials.metal} />\n128          </group>\n129        </RigidBody>\n130      </group>\n131      <mesh ref={band}>\n132        <meshLineGeometry />\n133        <meshLineMaterial\n134          color=\"white\"\n135          depthTest={false}\n136          resolution={isSmall ? [1000, 2000] : [1000, 1000]}\n137          useMap\n138          map={texture}\n139          repeat={[-4, 1]}\n140          lineWidth={1}\n141        />\n142      </mesh>\n143    </>\n144  );\n145}",
  "category": "components",
  "scrapedAt": "2025-04-27T11:47:05.183Z",
  "previewImage": "lanyard-preview.png"
}