{
  "name": "Splash Cursor",
  "description": "An open source collection of high quality, animated, interactive & fully customizable React components for building stunning, memorable user interfaces.",
  "props": {},
  "dependencies": [],
  "url": "https://www.reactbits.dev/animations/splash-cursor",
  "code": "1import SplashCursor from './SplashCursor'\n2\n3<SplashCursor />\n\n1'use client';\n2import { useEffect, useRef } from 'react';\n3\n4function SplashCursor({\n5  // You can customize these props if you want\n6  SIM_RESOLUTION = 128,\n7  DYE_RESOLUTION = 1440,\n8  CAPTURE_RESOLUTION = 512,\n9  DENSITY_DISSIPATION = 3.5,\n10  VELOCITY_DISSIPATION = 2,\n11  PRESSURE = 0.1,\n12  PRESSURE_ITERATIONS = 20,\n13  CURL = 3,\n14  SPLAT_RADIUS = 0.2,\n15  SPLAT_FORCE = 6000,\n16  SHADING = true,\n17  COLOR_UPDATE_SPEED = 10,\n18  BACK_COLOR = { r: 0.5, g: 0, b: 0 },\n19  TRANSPARENT = true\n20}) {\n21  const canvasRef = useRef(null);\n22\n23  useEffect(() => {\n24    const canvas = canvasRef.current;\n25    if (!canvas) return;\n26\n27    function pointerPrototype() {\n28      this.id = -1;\n29      this.texcoordX = 0;\n30      this.texcoordY = 0;\n31      this.prevTexcoordX = 0;\n32      this.prevTexcoordY = 0;\n33      this.deltaX = 0;\n34      this.deltaY = 0;\n35      this.down = false;\n36      this.moved = false;\n37      this.color = [0, 0, 0];\n38    }\n39\n40    let config = {\n41      SIM_RESOLUTION,\n42      DYE_RESOLUTION,\n43      CAPTURE_RESOLUTION,\n44      DENSITY_DISSIPATION,\n45      VELOCITY_DISSIPATION,\n46      PRESSURE,\n47      PRESSURE_ITERATIONS,\n48      CURL,\n49      SPLAT_RADIUS,\n50      SPLAT_FORCE,\n51      SHADING,\n52      COLOR_UPDATE_SPEED,\n53      PAUSED: false,\n54      BACK_COLOR,\n55      TRANSPARENT,\n56    };\n57\n58    let pointers = [new pointerPrototype()];\n59\n60    const { gl, ext } = getWebGLContext(canvas);\n61    if (!ext.supportLinearFiltering) {\n62      config.DYE_RESOLUTION = 256;\n63      config.SHADING = false;\n64    }\n65\n66    function getWebGLContext(canvas) {\n67      const params = {\n68        alpha: true,\n69        depth: false,\n70        stencil: false,\n71        antialias: false,\n72        preserveDrawingBuffer: false,\n73      };\n74      let gl = canvas.getContext('webgl2', params);\n75      const isWebGL2 = !!gl;\n76      if (!isWebGL2)\n77        gl =\n78          canvas.getContext('webgl', params) ||\n79          canvas.getContext('experimental-webgl', params);\n80\n81      let halfFloat;\n82      let supportLinearFiltering;\n83      if (isWebGL2) {\n84        gl.getExtension('EXT_color_buffer_float');\n85        supportLinearFiltering = gl.getExtension('OES_texture_float_linear');\n86      } else {\n87        halfFloat = gl.getExtension('OES_texture_half_float');\n88        supportLinearFiltering = gl.getExtension('OES_texture_half_float_linear');\n89      }\n90      gl.clearColor(0.0, 0.0, 0.0, 1.0);\n91\n92      const halfFloatTexType = isWebGL2\n93        ? gl.HALF_FLOAT\n94        : halfFloat && halfFloat.HALF_FLOAT_OES;\n95      let formatRGBA;\n96      let formatRG;\n97      let formatR;\n98\n99      if (isWebGL2) {\n100        formatRGBA = getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, halfFloatTexType);\n101        formatRG = getSupportedFormat(gl, gl.RG16F, gl.RG, halfFloatTexType);\n102        formatR = getSupportedFormat(gl, gl.R16F, gl.RED, halfFloatTexType);\n103      } else {\n104        formatRGBA = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n105        formatRG = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n106        formatR = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n107      }\n108\n109      return {\n110        gl,\n111        ext: {\n112          formatRGBA,\n113          formatRG,\n114          formatR,\n115          halfFloatTexType,\n116          supportLinearFiltering,\n117        },\n118      };\n119    }\n120\n121    function getSupportedFormat(gl, internalFormat, format, type) {\n122      if (!supportRenderTextureFormat(gl, internalFormat, format, type)) {\n123        switch (internalFormat) {\n124          case gl.R16F:\n125            return getSupportedFormat(gl, gl.RG16F, gl.RG, type);\n126          case gl.RG16F:\n127            return getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, type);\n128          default:\n129            return null;\n130        }\n131      }\n132      return { internalFormat, format };\n133    }\n134\n135    function supportRenderTextureFormat(gl, internalFormat, format, type) {\n136      const texture = gl.createTexture();\n137      gl.bindTexture(gl.TEXTURE_2D, texture);\n138      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n139      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n140      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n141      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n142      gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 4, 4, 0, format, type, null);\n143      const fbo = gl.createFramebuffer();\n144      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n145      gl.framebufferTexture2D(\n146        gl.FRAMEBUFFER,\n147        gl.COLOR_ATTACHMENT0,\n148        gl.TEXTURE_2D,\n149        texture,\n150        0\n151      );\n152      const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n153      return status === gl.FRAMEBUFFER_COMPLETE;\n154    }\n155\n156    class Material {\n157      constructor(vertexShader, fragmentShaderSource) {\n158        this.vertexShader = vertexShader;\n159        this.fragmentShaderSource = fragmentShaderSource;\n160        this.programs = [];\n161        this.activeProgram = null;\n162        this.uniforms = [];\n163      }\n164      setKeywords(keywords) {\n165        let hash = 0;\n166        for (let i = 0; i < keywords.length; i++) hash += hashCode(keywords[i]);\n167        let program = this.programs[hash];\n168        if (program == null) {\n169          let fragmentShader = compileShader(\n170            gl.FRAGMENT_SHADER,\n171            this.fragmentShaderSource,\n172            keywords\n173          );\n174          program = createProgram(this.vertexShader, fragmentShader);\n175          this.programs[hash] = program;\n176        }\n177        if (program === this.activeProgram) return;\n178        this.uniforms = getUniforms(program);\n179        this.activeProgram = program;\n180      }\n181      bind() {\n182        gl.useProgram(this.activeProgram);\n183      }\n184    }\n185\n186    class Program {\n187      constructor(vertexShader, fragmentShader) {\n188        this.uniforms = {};\n189        this.program = createProgram(vertexShader, fragmentShader);\n190        this.uniforms = getUniforms(this.program);\n191      }\n192      bind() {\n193        gl.useProgram(this.program);\n194      }\n195    }\n196\n197    function createProgram(vertexShader, fragmentShader) {\n198      let program = gl.createProgram();\n199      gl.attachShader(program, vertexShader);\n200      gl.attachShader(program, fragmentShader);\n201      gl.linkProgram(program);\n202      if (!gl.getProgramParameter(program, gl.LINK_STATUS))\n203        console.trace(gl.getProgramInfoLog(program));\n204      return program;\n205    }\n206\n207    function getUniforms(program) {\n208      let uniforms = [];\n209      let uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n210      for (let i = 0; i < uniformCount; i++) {\n211        let uniformName = gl.getActiveUniform(program, i).name;\n212        uniforms[uniformName] = gl.getUniformLocation(program, uniformName);\n213      }\n214      return uniforms;\n215    }\n216\n217    function compileShader(type, source, keywords) {\n218      source = addKeywords(source, keywords);\n219      const shader = gl.createShader(type);\n220      gl.shaderSource(shader, source);\n221      gl.compileShader(shader);\n222      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))\n223        console.trace(gl.getShaderInfoLog(shader));\n224      return shader;\n225    }\n226\n227    function addKeywords(source, keywords) {\n228      if (!keywords) return source;\n229      let keywordsString = '';\n230      keywords.forEach((keyword) => {\n231        keywordsString += '#define ' + keyword + '\\n';\n232      });\n233      return keywordsString + source;\n234    }\n235\n236    const baseVertexShader = compileShader(\n237      gl.VERTEX_SHADER,\n238      `\n239        precision highp float;\n240        attribute vec2 aPosition;\n241        varying vec2 vUv;\n242        varying vec2 vL;\n243        varying vec2 vR;\n244        varying vec2 vT;\n245        varying vec2 vB;\n246        uniform vec2 texelSize;\n247\n248        void main () {\n249            vUv = aPosition * 0.5 + 0.5;\n250            vL = vUv - vec2(texelSize.x, 0.0);\n251            vR = vUv + vec2(texelSize.x, 0.0);\n252            vT = vUv + vec2(0.0, texelSize.y);\n253            vB = vUv - vec2(0.0, texelSize.y);\n254            gl_Position = vec4(aPosition, 0.0, 1.0);\n255        }\n256      `\n257    );\n258\n259    const copyShader = compileShader(\n260      gl.FRAGMENT_SHADER,\n261      `\n262        precision mediump float;\n263        precision mediump sampler2D;\n264        varying highp vec2 vUv;\n265        uniform sampler2D uTexture;\n266\n267        void main () {\n268            gl_FragColor = texture2D(uTexture, vUv);\n269        }\n270      `\n271    );\n272\n273    const clearShader = compileShader(\n274      gl.FRAGMENT_SHADER,\n275      `\n276        precision mediump float;\n277        precision mediump sampler2D;\n278        varying highp vec2 vUv;\n279        uniform sampler2D uTexture;\n280        uniform float value;\n281\n282        void main () {\n283            gl_FragColor = value * texture2D(uTexture, vUv);\n284        }\n285      `\n286    );\n287\n288    const displayShaderSource = `\n289      precision highp float;\n290      precision highp sampler2D;\n291      varying vec2 vUv;\n292      varying vec2 vL;\n293      varying vec2 vR;\n294      varying vec2 vT;\n295      varying vec2 vB;\n296      uniform sampler2D uTexture;\n297      uniform sampler2D uDithering;\n298      uniform vec2 ditherScale;\n299      uniform vec2 texelSize;\n300\n301      vec3 linearToGamma (vec3 color) {\n302          color = max(color, vec3(0));\n303          return max(1.055 * pow(color, vec3(0.416666667)) - 0.055, vec3(0));\n304      }\n305\n306      void main () {\n307          vec3 c = texture2D(uTexture, vUv).rgb;\n308          #ifdef SHADING\n309              vec3 lc = texture2D(uTexture, vL).rgb;\n310              vec3 rc = texture2D(uTexture, vR).rgb;\n311              vec3 tc = texture2D(uTexture, vT).rgb;\n312              vec3 bc = texture2D(uTexture, vB).rgb;\n313\n314              float dx = length(rc) - length(lc);\n315              float dy = length(tc) - length(bc);\n316\n317              vec3 n = normalize(vec3(dx, dy, length(texelSize)));\n318              vec3 l = vec3(0.0, 0.0, 1.0);\n319\n320              float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);\n321              c *= diffuse;\n322          #endif\n323\n324          float a = max(c.r, max(c.g, c.b));\n325          gl_FragColor = vec4(c, a);\n326      }\n327    `;\n328\n329    const splatShader = compileShader(\n330      gl.FRAGMENT_SHADER,\n331      `\n332        precision highp float;\n333        precision highp sampler2D;\n334        varying vec2 vUv;\n335        uniform sampler2D uTarget;\n336        uniform float aspectRatio;\n337        uniform vec3 color;\n338        uniform vec2 point;\n339        uniform float radius;\n340\n341        void main () {\n342            vec2 p = vUv - point.xy;\n343            p.x *= aspectRatio;\n344            vec3 splat = exp(-dot(p, p) / radius) * color;\n345            vec3 base = texture2D(uTarget, vUv).xyz;\n346            gl_FragColor = vec4(base + splat, 1.0);\n347        }\n348      `\n349    );\n350\n351    const advectionShader = compileShader(\n352      gl.FRAGMENT_SHADER,\n353      `\n354        precision highp float;\n355        precision highp sampler2D;\n356        varying vec2 vUv;\n357        uniform sampler2D uVelocity;\n358        uniform sampler2D uSource;\n359        uniform vec2 texelSize;\n360        uniform vec2 dyeTexelSize;\n361        uniform float dt;\n362        uniform float dissipation;\n363\n364        vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {\n365            vec2 st = uv / tsize - 0.5;\n366            vec2 iuv = floor(st);\n367            vec2 fuv = fract(st);\n368\n369            vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);\n370            vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);\n371            vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);\n372            vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);\n373\n374            return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);\n375        }\n376\n377        void main () {\n378            #ifdef MANUAL_FILTERING\n379                vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;\n380                vec4 result = bilerp(uSource, coord, dyeTexelSize);\n381            #else\n382                vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\n383                vec4 result = texture2D(uSource, coord);\n384            #endif\n385            float decay = 1.0 + dissipation * dt;\n386            gl_FragColor = result / decay;\n387        }\n388      `,\n389      ext.supportLinearFiltering ? null : ['MANUAL_FILTERING']\n390    );\n391\n392    const divergenceShader = compileShader(\n393      gl.FRAGMENT_SHADER,\n394      `\n395        precision mediump float;\n396        precision mediump sampler2D;\n397        varying highp vec2 vUv;\n398        varying highp vec2 vL;\n399        varying highp vec2 vR;\n400        varying highp vec2 vT;\n401        varying highp vec2 vB;\n402        uniform sampler2D uVelocity;\n403\n404        void main () {\n405            float L = texture2D(uVelocity, vL).x;\n406            float R = texture2D(uVelocity, vR).x;\n407            float T = texture2D(uVelocity, vT).y;\n408            float B = texture2D(uVelocity, vB).y;\n409\n410            vec2 C = texture2D(uVelocity, vUv).xy;\n411            if (vL.x < 0.0) { L = -C.x; }\n412            if (vR.x > 1.0) { R = -C.x; }\n413            if (vT.y > 1.0) { T = -C.y; }\n414            if (vB.y < 0.0) { B = -C.y; }\n415\n416            float div = 0.5 * (R - L + T - B);\n417            gl_FragColor = vec4(div, 0.0, 0.0, 1.0);\n418        }\n419      `\n420    );\n421\n422    const curlShader = compileShader(\n423      gl.FRAGMENT_SHADER,\n424      `\n425        precision mediump float;\n426        precision mediump sampler2D;\n427        varying highp vec2 vUv;\n428        varying highp vec2 vL;\n429        varying highp vec2 vR;\n430        varying highp vec2 vT;\n431        varying highp vec2 vB;\n432        uniform sampler2D uVelocity;\n433\n434        void main () {\n435            float L = texture2D(uVelocity, vL).y;\n436            float R = texture2D(uVelocity, vR).y;\n437            float T = texture2D(uVelocity, vT).x;\n438            float B = texture2D(uVelocity, vB).x;\n439            float vorticity = R - L - T + B;\n440            gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);\n441        }\n442      `\n443    );\n444\n445    const vorticityShader = compileShader(\n446      gl.FRAGMENT_SHADER,\n447      `\n448        precision highp float;\n449        precision highp sampler2D;\n450        varying vec2 vUv;\n451        varying vec2 vL;\n452        varying vec2 vR;\n453        varying vec2 vT;\n454        varying vec2 vB;\n455        uniform sampler2D uVelocity;\n456        uniform sampler2D uCurl;\n457        uniform float curl;\n458        uniform float dt;\n459\n460        void main () {\n461            float L = texture2D(uCurl, vL).x;\n462            float R = texture2D(uCurl, vR).x;\n463            float T = texture2D(uCurl, vT).x;\n464            float B = texture2D(uCurl, vB).x;\n465            float C = texture2D(uCurl, vUv).x;\n466\n467            vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));\n468            force /= length(force) + 0.0001;\n469            force *= curl * C;\n470            force.y *= -1.0;\n471\n472            vec2 velocity = texture2D(uVelocity, vUv).xy;\n473            velocity += force * dt;\n474            velocity = min(max(velocity, -1000.0), 1000.0);\n475            gl_FragColor = vec4(velocity, 0.0, 1.0);\n476        }\n477      `\n478    );\n479\n480    const pressureShader = compileShader(\n481      gl.FRAGMENT_SHADER,\n482      `\n483        precision mediump float;\n484        precision mediump sampler2D;\n485        varying highp vec2 vUv;\n486        varying highp vec2 vL;\n487        varying highp vec2 vR;\n488        varying highp vec2 vT;\n489        varying highp vec2 vB;\n490        uniform sampler2D uPressure;\n491        uniform sampler2D uDivergence;\n492\n493        void main () {\n494            float L = texture2D(uPressure, vL).x;\n495            float R = texture2D(uPressure, vR).x;\n496            float T = texture2D(uPressure, vT).x;\n497            float B = texture2D(uPressure, vB).x;\n498            float C = texture2D(uPressure, vUv).x;\n499            float divergence = texture2D(uDivergence, vUv).x;\n500            float pressure = (L + R + B + T - divergence) * 0.25;\n501            gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\n502        }\n503      `\n504    );\n505\n506    const gradientSubtractShader = compileShader(\n507      gl.FRAGMENT_SHADER,\n508      `\n509        precision mediump float;\n510        precision mediump sampler2D;\n511        varying highp vec2 vUv;\n512        varying highp vec2 vL;\n513        varying highp vec2 vR;\n514        varying highp vec2 vT;\n515        varying highp vec2 vB;\n516        uniform sampler2D uPressure;\n517        uniform sampler2D uVelocity;\n518\n519        void main () {\n520            float L = texture2D(uPressure, vL).x;\n521            float R = texture2D(uPressure, vR).x;\n522            float T = texture2D(uPressure, vT).x;\n523            float B = texture2D(uPressure, vB).x;\n524            vec2 velocity = texture2D(uVelocity, vUv).xy;\n525            velocity.xy -= vec2(R - L, T - B);\n526            gl_FragColor = vec4(velocity, 0.0, 1.0);\n527        }\n528      `\n529    );\n530\n531    const blit = (() => {\n532      gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n533      gl.bufferData(\n534        gl.ARRAY_BUFFER,\n535        new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]),\n536        gl.STATIC_DRAW\n537      );\n538      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());\n539      gl.bufferData(\n540        gl.ELEMENT_ARRAY_BUFFER,\n541        new Uint16Array([0, 1, 2, 0, 2, 3]),\n542        gl.STATIC_DRAW\n543      );\n544      gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n545      gl.enableVertexAttribArray(0);\n546      return (target, clear = false) => {\n547        if (target == null) {\n548          gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n549          gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n550        } else {\n551          gl.viewport(0, 0, target.width, target.height);\n552          gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);\n553        }\n554        if (clear) {\n555          gl.clearColor(0.0, 0.0, 0.0, 1.0);\n556          gl.clear(gl.COLOR_BUFFER_BIT);\n557        }\n558        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n559      };\n560    })();\n561\n562    let dye, velocity, divergence, curl, pressure;\n563\n564    const copyProgram = new Program(baseVertexShader, copyShader);\n565    const clearProgram = new Program(baseVertexShader, clearShader);\n566    const splatProgram = new Program(baseVertexShader, splatShader);\n567    const advectionProgram = new Program(baseVertexShader, advectionShader);\n568    const divergenceProgram = new Program(baseVertexShader, divergenceShader);\n569    const curlProgram = new Program(baseVertexShader, curlShader);\n570    const vorticityProgram = new Program(baseVertexShader, vorticityShader);\n571    const pressureProgram = new Program(baseVertexShader, pressureShader);\n572    const gradienSubtractProgram = new Program(baseVertexShader, gradientSubtractShader);\n573    const displayMaterial = new Material(baseVertexShader, displayShaderSource);\n574\n575    function initFramebuffers() {\n576      let simRes = getResolution(config.SIM_RESOLUTION);\n577      let dyeRes = getResolution(config.DYE_RESOLUTION);\n578      const texType = ext.halfFloatTexType;\n579      const rgba = ext.formatRGBA;\n580      const rg = ext.formatRG;\n581      const r = ext.formatR;\n582      const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;\n583      gl.disable(gl.BLEND);\n584\n585      if (!dye)\n586        dye = createDoubleFBO(\n587          dyeRes.width,\n588          dyeRes.height,\n589          rgba.internalFormat,\n590          rgba.format,\n591          texType,\n592          filtering\n593        );\n594      else\n595        dye = resizeDoubleFBO(\n596          dye,\n597          dyeRes.width,\n598          dyeRes.height,\n599          rgba.internalFormat,\n600          rgba.format,\n601          texType,\n602          filtering\n603        );\n604\n605      if (!velocity)\n606        velocity = createDoubleFBO(\n607          simRes.width,\n608          simRes.height,\n609          rg.internalFormat,\n610          rg.format,\n611          texType,\n612          filtering\n613        );\n614      else\n615        velocity = resizeDoubleFBO(\n616          velocity,\n617          simRes.width,\n618          simRes.height,\n619          rg.internalFormat,\n620          rg.format,\n621          texType,\n622          filtering\n623        );\n624\n625      divergence = createFBO(\n626        simRes.width,\n627        simRes.height,\n628        r.internalFormat,\n629        r.format,\n630        texType,\n631        gl.NEAREST\n632      );\n633      curl = createFBO(\n634        simRes.width,\n635        simRes.height,\n636        r.internalFormat,\n637        r.format,\n638        texType,\n639        gl.NEAREST\n640      );\n641      pressure = createDoubleFBO(\n642        simRes.width,\n643        simRes.height,\n644        r.internalFormat,\n645        r.format,\n646        texType,\n647        gl.NEAREST\n648      );\n649    }\n650\n651    function createFBO(w, h, internalFormat, format, type, param) {\n652      gl.activeTexture(gl.TEXTURE0);\n653      let texture = gl.createTexture();\n654      gl.bindTexture(gl.TEXTURE_2D, texture);\n655      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);\n656      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);\n657      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n658      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n659      gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);\n660\n661      let fbo = gl.createFramebuffer();\n662      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n663      gl.framebufferTexture2D(\n664        gl.FRAMEBUFFER,\n665        gl.COLOR_ATTACHMENT0,\n666        gl.TEXTURE_2D,\n667        texture,\n668        0\n669      );\n670      gl.viewport(0, 0, w, h);\n671      gl.clear(gl.COLOR_BUFFER_BIT);\n672\n673      let texelSizeX = 1.0 / w;\n674      let texelSizeY = 1.0 / h;\n675      return {\n676        texture,\n677        fbo,\n678        width: w,\n679        height: h,\n680        texelSizeX,\n681        texelSizeY,\n682        attach(id) {\n683          gl.activeTexture(gl.TEXTURE0 + id);\n684          gl.bindTexture(gl.TEXTURE_2D, texture);\n685          return id;\n686        },\n687      };\n688    }\n689\n690    function createDoubleFBO(w, h, internalFormat, format, type, param) {\n691      let fbo1 = createFBO(w, h, internalFormat, format, type, param);\n692      let fbo2 = createFBO(w, h, internalFormat, format, type, param);\n693      return {\n694        width: w,\n695        height: h,\n696        texelSizeX: fbo1.texelSizeX,\n697        texelSizeY: fbo1.texelSizeY,\n698        get read() {\n699          return fbo1;\n700        },\n701        set read(value) {\n702          fbo1 = value;\n703        },\n704        get write() {\n705          return fbo2;\n706        },\n707        set write(value) {\n708          fbo2 = value;\n709        },\n710        swap() {\n711          let temp = fbo1;\n712          fbo1 = fbo2;\n713          fbo2 = temp;\n714        },\n715      };\n716    }\n717\n718    function resizeFBO(target, w, h, internalFormat, format, type, param) {\n719      let newFBO = createFBO(w, h, internalFormat, format, type, param);\n720      copyProgram.bind();\n721      gl.uniform1i(copyProgram.uniforms.uTexture, target.attach(0));\n722      blit(newFBO);\n723      return newFBO;\n724    }\n725\n726    function resizeDoubleFBO(target, w, h, internalFormat, format, type, param) {\n727      if (target.width === w && target.height === h) return target;\n728      target.read = resizeFBO(\n729        target.read,\n730        w,\n731        h,\n732        internalFormat,\n733        format,\n734        type,\n735        param\n736      );\n737      target.write = createFBO(w, h, internalFormat, format, type, param);\n738      target.width = w;\n739      target.height = h;\n740      target.texelSizeX = 1.0 / w;\n741      target.texelSizeY = 1.0 / h;\n742      return target;\n743    }\n744\n745    function updateKeywords() {\n746      let displayKeywords = [];\n747      if (config.SHADING) displayKeywords.push('SHADING');\n748      displayMaterial.setKeywords(displayKeywords);\n749    }\n750\n751    updateKeywords();\n752    initFramebuffers();\n753    let lastUpdateTime = Date.now();\n754    let colorUpdateTimer = 0.0;\n755\n756    function updateFrame() {\n757      const dt = calcDeltaTime();\n758      if (resizeCanvas()) initFramebuffers();\n759      updateColors(dt);\n760      applyInputs();\n761      step(dt);\n762      render(null);\n763      requestAnimationFrame(updateFrame);\n764    }\n765\n766    function calcDeltaTime() {\n767      let now = Date.now();\n768      let dt = (now - lastUpdateTime) / 1000;\n769      dt = Math.min(dt, 0.016666);\n770      lastUpdateTime = now;\n771      return dt;\n772    }\n773\n774    function resizeCanvas() {\n775      let width = scaleByPixelRatio(canvas.clientWidth);\n776      let height = scaleByPixelRatio(canvas.clientHeight);\n777      if (canvas.width !== width || canvas.height !== height) {\n778        canvas.width = width;\n779        canvas.height = height;\n780        return true;\n781      }\n782      return false;\n783    }\n784\n785    function updateColors(dt) {\n786      colorUpdateTimer += dt * config.COLOR_UPDATE_SPEED;\n787      if (colorUpdateTimer >= 1) {\n788        colorUpdateTimer = wrap(colorUpdateTimer, 0, 1);\n789        pointers.forEach((p) => {\n790          p.color = generateColor();\n791        });\n792      }\n793    }\n794\n795    function applyInputs() {\n796      pointers.forEach((p) => {\n797        if (p.moved) {\n798          p.moved = false;\n799          splatPointer(p);\n800        }\n801      });\n802    }\n803\n804    function step(dt) {\n805      gl.disable(gl.BLEND);\n806      // Curl\n807      curlProgram.bind();\n808      gl.uniform2f(\n809        curlProgram.uniforms.texelSize,\n810        velocity.texelSizeX,\n811        velocity.texelSizeY\n812      );\n813      gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.attach(0));\n814      blit(curl);\n815\n816      // Vorticity\n817      vorticityProgram.bind();\n818      gl.uniform2f(\n819        vorticityProgram.uniforms.texelSize,\n820        velocity.texelSizeX,\n821        velocity.texelSizeY\n822      );\n823      gl.uniform1i(vorticityProgram.uniforms.uVelocity, velocity.read.attach(0));\n824      gl.uniform1i(vorticityProgram.uniforms.uCurl, curl.attach(1));\n825      gl.uniform1f(vorticityProgram.uniforms.curl, config.CURL);\n826      gl.uniform1f(vorticityProgram.uniforms.dt, dt);\n827      blit(velocity.write);\n828      velocity.swap();\n829\n830      // Divergence\n831      divergenceProgram.bind();\n832      gl.uniform2f(\n833        divergenceProgram.uniforms.texelSize,\n834        velocity.texelSizeX,\n835        velocity.texelSizeY\n836      );\n837      gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read.attach(0));\n838      blit(divergence);\n839\n840      // Clear pressure\n841      clearProgram.bind();\n842      gl.uniform1i(clearProgram.uniforms.uTexture, pressure.read.attach(0));\n843      gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE);\n844      blit(pressure.write);\n845      pressure.swap();\n846\n847      // Pressure\n848      pressureProgram.bind();\n849      gl.uniform2f(\n850        pressureProgram.uniforms.texelSize,\n851        velocity.texelSizeX,\n852        velocity.texelSizeY\n853      );\n854      gl.uniform1i(pressureProgram.uniforms.uDivergence, divergence.attach(0));\n855      for (let i = 0; i < config.PRESSURE_ITERATIONS; i++) {\n856        gl.uniform1i(pressureProgram.uniforms.uPressure, pressure.read.attach(1));\n857        blit(pressure.write);\n858        pressure.swap();\n859      }\n860\n861      // Gradient Subtract\n862      gradienSubtractProgram.bind();\n863      gl.uniform2f(\n864        gradienSubtractProgram.uniforms.texelSize,\n865        velocity.texelSizeX,\n866        velocity.texelSizeY\n867      );\n868      gl.uniform1i(\n869        gradienSubtractProgram.uniforms.uPressure,\n870        pressure.read.attach(0)\n871      );\n872      gl.uniform1i(\n873        gradienSubtractProgram.uniforms.uVelocity,\n874        velocity.read.attach(1)\n875      );\n876      blit(velocity.write);\n877      velocity.swap();\n878\n879      // Advection\n880      advectionProgram.bind();\n881      gl.uniform2f(\n882        advectionProgram.uniforms.texelSize,\n883        velocity.texelSizeX,\n884        velocity.texelSizeY\n885      );\n886      if (!ext.supportLinearFiltering)\n887        gl.uniform2f(\n888          advectionProgram.uniforms.dyeTexelSize,\n889          velocity.texelSizeX,\n890          velocity.texelSizeY\n891        );\n892      let velocityId = velocity.read.attach(0);\n893      gl.uniform1i(advectionProgram.uniforms.uVelocity, velocityId);\n894      gl.uniform1i(advectionProgram.uniforms.uSource, velocityId);\n895      gl.uniform1f(advectionProgram.uniforms.dt, dt);\n896      gl.uniform1f(\n897        advectionProgram.uniforms.dissipation,\n898        config.VELOCITY_DISSIPATION\n899      );\n900      blit(velocity.write);\n901      velocity.swap();\n902\n903      if (!ext.supportLinearFiltering)\n904        gl.uniform2f(\n905          advectionProgram.uniforms.dyeTexelSize,\n906          dye.texelSizeX,\n907          dye.texelSizeY\n908        );\n909      gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.attach(0));\n910      gl.uniform1i(advectionProgram.uniforms.uSource, dye.read.attach(1));\n911      gl.uniform1f(\n912        advectionProgram.uniforms.dissipation,\n913        config.DENSITY_DISSIPATION\n914      );\n915      blit(dye.write);\n916      dye.swap();\n917    }\n918\n919    function render(target) {\n920      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n921      gl.enable(gl.BLEND);\n922      drawDisplay(target);\n923    }\n924\n925    function drawDisplay(target) {\n926      let width = target == null ? gl.drawingBufferWidth : target.width;\n927      let height = target == null ? gl.drawingBufferHeight : target.height;\n928      displayMaterial.bind();\n929      if (config.SHADING)\n930        gl.uniform2f(displayMaterial.uniforms.texelSize, 1.0 / width, 1.0 / height);\n931      gl.uniform1i(displayMaterial.uniforms.uTexture, dye.read.attach(0));\n932      blit(target);\n933    }\n934\n935    function splatPointer(pointer) {\n936      let dx = pointer.deltaX * config.SPLAT_FORCE;\n937      let dy = pointer.deltaY * config.SPLAT_FORCE;\n938      splat(pointer.texcoordX, pointer.texcoordY, dx, dy, pointer.color);\n939    }\n940\n941    function clickSplat(pointer) {\n942      const color = generateColor();\n943      color.r *= 10.0;\n944      color.g *= 10.0;\n945      color.b *= 10.0;\n946      let dx = 10 * (Math.random() - 0.5);\n947      let dy = 30 * (Math.random() - 0.5);\n948      splat(pointer.texcoordX, pointer.texcoordY, dx, dy, color);\n949    }\n950\n951    function splat(x, y, dx, dy, color) {\n952      splatProgram.bind();\n953      gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.attach(0));\n954      gl.uniform1f(\n955        splatProgram.uniforms.aspectRatio,\n956        canvas.width / canvas.height\n957      );\n958      gl.uniform2f(splatProgram.uniforms.point, x, y);\n959      gl.uniform3f(splatProgram.uniforms.color, dx, dy, 0.0);\n960      gl.uniform1f(\n961        splatProgram.uniforms.radius,\n962        correctRadius(config.SPLAT_RADIUS / 100.0)\n963      );\n964      blit(velocity.write);\n965      velocity.swap();\n966\n967      gl.uniform1i(splatProgram.uniforms.uTarget, dye.read.attach(0));\n968      gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);\n969      blit(dye.write);\n970      dye.swap();\n971    }\n972\n973    function correctRadius(radius) {\n974      let aspectRatio = canvas.width / canvas.height;\n975      if (aspectRatio > 1) radius *= aspectRatio;\n976      return radius;\n977    }\n978\n979    function updatePointerDownData(pointer, id, posX, posY) {\n980      pointer.id = id;\n981      pointer.down = true;\n982      pointer.moved = false;\n983      pointer.texcoordX = posX / canvas.width;\n984      pointer.texcoordY = 1.0 - posY / canvas.height;\n985      pointer.prevTexcoordX = pointer.texcoordX;\n986      pointer.prevTexcoordY = pointer.texcoordY;\n987      pointer.deltaX = 0;\n988      pointer.deltaY = 0;\n989      pointer.color = generateColor();\n990    }\n991\n992    function updatePointerMoveData(pointer, posX, posY, color) {\n993      pointer.prevTexcoordX = pointer.texcoordX;\n994      pointer.prevTexcoordY = pointer.texcoordY;\n995      pointer.texcoordX = posX / canvas.width;\n996      pointer.texcoordY = 1.0 - posY / canvas.height;\n997      pointer.deltaX = correctDeltaX(pointer.texcoordX - pointer.prevTexcoordX);\n998      pointer.deltaY = correctDeltaY(pointer.texcoordY - pointer.prevTexcoordY);\n999      pointer.moved = Math.abs(pointer.deltaX) > 0 || Math.abs(pointer.deltaY) > 0;\n1000      pointer.color = color;\n1001    }\n1002\n1003    function updatePointerUpData(pointer) {\n1004      pointer.down = false;\n1005    }\n1006\n1007    function correctDeltaX(delta) {\n1008      let aspectRatio = canvas.width / canvas.height;\n1009      if (aspectRatio < 1) delta *= aspectRatio;\n1010      return delta;\n1011    }\n1012\n1013    function correctDeltaY(delta) {\n1014      let aspectRatio = canvas.width / canvas.height;\n1015      if (aspectRatio > 1) delta /= aspectRatio;\n1016      return delta;\n1017    }\n1018\n1019    function generateColor() {\n1020      let c = HSVtoRGB(Math.random(), 1.0, 1.0);\n1021      c.r *= 0.15;\n1022      c.g *= 0.15;\n1023      c.b *= 0.15;\n1024      return c;\n1025    }\n1026\n1027    function HSVtoRGB(h, s, v) {\n1028      let r, g, b, i, f, p, q, t;\n1029      i = Math.floor(h * 6);\n1030      f = h * 6 - i;\n1031      p = v * (1 - s);\n1032      q = v * (1 - f * s);\n1033      t = v * (1 - (1 - f) * s);\n1034      switch (i % 6) {\n1035        case 0:\n1036          r = v;\n1037          g = t;\n1038          b = p;\n1039          break;\n1040        case 1:\n1041          r = q;\n1042          g = v;\n1043          b = p;\n1044          break;\n1045        case 2:\n1046          r = p;\n1047          g = v;\n1048          b = t;\n1049          break;\n1050        case 3:\n1051          r = p;\n1052          g = q;\n1053          b = v;\n1054          break;\n1055        case 4:\n1056          r = t;\n1057          g = p;\n1058          b = v;\n1059          break;\n1060        case 5:\n1061          r = v;\n1062          g = p;\n1063          b = q;\n1064          break;\n1065        default:\n1066          break;\n1067      }\n1068      return { r, g, b };\n1069    }\n1070\n1071    function wrap(value, min, max) {\n1072      const range = max - min;\n1073      if (range === 0) return min;\n1074      return ((value - min) % range) + min;\n1075    }\n1076\n1077    function getResolution(resolution) {\n1078      let aspectRatio = gl.drawingBufferWidth / gl.drawingBufferHeight;\n1079      if (aspectRatio < 1) aspectRatio = 1.0 / aspectRatio;\n1080      const min = Math.round(resolution);\n1081      const max = Math.round(resolution * aspectRatio);\n1082      if (gl.drawingBufferWidth > gl.drawingBufferHeight)\n1083        return { width: max, height: min };\n1084      else return { width: min, height: max };\n1085    }\n1086\n1087    function scaleByPixelRatio(input) {\n1088      const pixelRatio = window.devicePixelRatio || 1;\n1089      return Math.floor(input * pixelRatio);\n1090    }\n1091\n1092    function hashCode(s) {\n1093      if (s.length === 0) return 0;\n1094      let hash = 0;\n1095      for (let i = 0; i < s.length; i++) {\n1096        hash = (hash << 5) - hash + s.charCodeAt(i);\n1097        hash |= 0;\n1098      }\n1099      return hash;\n1100    }\n1101\n1102    window.addEventListener('mousedown', (e) => {\n1103      let pointer = pointers[0];\n1104      let posX = scaleByPixelRatio(e.clientX);\n1105      let posY = scaleByPixelRatio(e.clientY);\n1106      updatePointerDownData(pointer, -1, posX, posY);\n1107      clickSplat(pointer);\n1108    });\n1109\n1110    document.body.addEventListener('mousemove', function handleFirstMouseMove(e) {\n1111      let pointer = pointers[0];\n1112      let posX = scaleByPixelRatio(e.clientX);\n1113      let posY = scaleByPixelRatio(e.clientY);\n1114      let color = generateColor();\n1115      updateFrame(); // start animation loop\n1116      updatePointerMoveData(pointer, posX, posY, color);\n1117      document.body.removeEventListener('mousemove', handleFirstMouseMove);\n1118    });\n1119\n1120    window.addEventListener('mousemove', (e) => {\n1121      let pointer = pointers[0];\n1122      let posX = scaleByPixelRatio(e.clientX);\n1123      let posY = scaleByPixelRatio(e.clientY);\n1124      let color = pointer.color;\n1125      updatePointerMoveData(pointer, posX, posY, color);\n1126    });\n1127\n1128    document.body.addEventListener('touchstart', function handleFirstTouchStart(e) {\n1129      const touches = e.targetTouches;\n1130      let pointer = pointers[0];\n1131      for (let i = 0; i < touches.length; i++) {\n1132        let posX = scaleByPixelRatio(touches[i].clientX);\n1133        let posY = scaleByPixelRatio(touches[i].clientY);\n1134        updateFrame(); // start animation loop\n1135        updatePointerDownData(pointer, touches[i].identifier, posX, posY);\n1136      }\n1137      document.body.removeEventListener('touchstart', handleFirstTouchStart);\n1138    });\n1139\n1140    window.addEventListener('touchstart', (e) => {\n1141      const touches = e.targetTouches;\n1142      let pointer = pointers[0];\n1143      for (let i = 0; i < touches.length; i++) {\n1144        let posX = scaleByPixelRatio(touches[i].clientX);\n1145        let posY = scaleByPixelRatio(touches[i].clientY);\n1146        updatePointerDownData(pointer, touches[i].identifier, posX, posY);\n1147      }\n1148    });\n1149\n1150    window.addEventListener(\n1151      'touchmove',\n1152      (e) => {\n1153        const touches = e.targetTouches;\n1154        let pointer = pointers[0];\n1155        for (let i = 0; i < touches.length; i++) {\n1156          let posX = scaleByPixelRatio(touches[i].clientX);\n1157          let posY = scaleByPixelRatio(touches[i].clientY);\n1158          updatePointerMoveData(pointer, posX, posY, pointer.color);\n1159        }\n1160      },\n1161      false\n1162    );\n1163\n1164    window.addEventListener('touchend', (e) => {\n1165      const touches = e.changedTouches;\n1166      let pointer = pointers[0];\n1167      for (let i = 0; i < touches.length; i++) {\n1168        updatePointerUpData(pointer);\n1169      }\n1170    });\n1171\n1172    updateFrame();\n1173    // eslint-disable-next-line react-hooks/exhaustive-deps\n1174  }, [\n1175    SIM_RESOLUTION,\n1176    DYE_RESOLUTION,\n1177    CAPTURE_RESOLUTION,\n1178    DENSITY_DISSIPATION,\n1179    VELOCITY_DISSIPATION,\n1180    PRESSURE,\n1181    PRESSURE_ITERATIONS,\n1182    CURL,\n1183    SPLAT_RADIUS,\n1184    SPLAT_FORCE,\n1185    SHADING,\n1186    COLOR_UPDATE_SPEED,\n1187    BACK_COLOR,\n1188    TRANSPARENT,\n1189  ]);\n1190\n1191  return (\n1192    <div\n1193      style={{\n1194        position: 'fixed',\n1195        top: 0,\n1196        left: 0,\n1197        zIndex: 50,\n1198        pointerEvents: 'none',\n1199        width: '100%',\n1200        height: '100%',\n1201      }}\n1202    >\n1203      <canvas\n1204        ref={canvasRef}\n1205        id=\"fluid\"\n1206        style={{\n1207          width: '100vw',\n1208          height: '100vh',\n1209          display: 'block',\n1210        }}\n1211      />\n1212    </div>\n1213  );\n1214}\n1215\n1216export default SplashCursor;\n1217\n\n1'use client';\n2import { useEffect, useRef } from 'react';\n3\n4function SplashCursor({\n5  // Add whatever props you like for customization\n6  SIM_RESOLUTION = 128,\n7  DYE_RESOLUTION = 1440,\n8  CAPTURE_RESOLUTION = 512,\n9  DENSITY_DISSIPATION = 3.5,\n10  VELOCITY_DISSIPATION = 2,\n11  PRESSURE = 0.1,\n12  PRESSURE_ITERATIONS = 20,\n13  CURL = 3,\n14  SPLAT_RADIUS = 0.2,\n15  SPLAT_FORCE = 6000,\n16  SHADING = true,\n17  COLOR_UPDATE_SPEED = 10,\n18  BACK_COLOR = { r: 0.5, g: 0, b: 0 },\n19  TRANSPARENT = true,\n20}) {\n21  const canvasRef = useRef(null);\n22\n23  useEffect(() => {\n24    const canvas = canvasRef.current;\n25    if (!canvas) return;\n26\n27    function pointerPrototype() {\n28      this.id = -1;\n29      this.texcoordX = 0;\n30      this.texcoordY = 0;\n31      this.prevTexcoordX = 0;\n32      this.prevTexcoordY = 0;\n33      this.deltaX = 0;\n34      this.deltaY = 0;\n35      this.down = false;\n36      this.moved = false;\n37      this.color = [0, 0, 0];\n38    }\n39\n40    let config = {\n41      SIM_RESOLUTION,\n42      DYE_RESOLUTION,\n43      CAPTURE_RESOLUTION,\n44      DENSITY_DISSIPATION,\n45      VELOCITY_DISSIPATION,\n46      PRESSURE,\n47      PRESSURE_ITERATIONS,\n48      CURL,\n49      SPLAT_RADIUS,\n50      SPLAT_FORCE,\n51      SHADING,\n52      COLOR_UPDATE_SPEED,\n53      PAUSED: false,\n54      BACK_COLOR,\n55      TRANSPARENT,\n56    };\n57\n58    let pointers = [new pointerPrototype()];\n59\n60    const { gl, ext } = getWebGLContext(canvas);\n61    if (!ext.supportLinearFiltering) {\n62      config.DYE_RESOLUTION = 256;\n63      config.SHADING = false;\n64    }\n65\n66    function getWebGLContext(canvas) {\n67      const params = {\n68        alpha: true,\n69        depth: false,\n70        stencil: false,\n71        antialias: false,\n72        preserveDrawingBuffer: false,\n73      };\n74      let gl = canvas.getContext('webgl2', params);\n75      const isWebGL2 = !!gl;\n76      if (!isWebGL2)\n77        gl =\n78          canvas.getContext('webgl', params) ||\n79          canvas.getContext('experimental-webgl', params);\n80      let halfFloat;\n81      let supportLinearFiltering;\n82      if (isWebGL2) {\n83        gl.getExtension('EXT_color_buffer_float');\n84        supportLinearFiltering = gl.getExtension('OES_texture_float_linear');\n85      } else {\n86        halfFloat = gl.getExtension('OES_texture_half_float');\n87        supportLinearFiltering = gl.getExtension(\n88          'OES_texture_half_float_linear'\n89        );\n90      }\n91      gl.clearColor(0.0, 0.0, 0.0, 1.0);\n92      const halfFloatTexType = isWebGL2\n93        ? gl.HALF_FLOAT\n94        : halfFloat && halfFloat.HALF_FLOAT_OES;\n95      let formatRGBA;\n96      let formatRG;\n97      let formatR;\n98\n99      if (isWebGL2) {\n100        formatRGBA = getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, halfFloatTexType);\n101        formatRG = getSupportedFormat(gl, gl.RG16F, gl.RG, halfFloatTexType);\n102        formatR = getSupportedFormat(gl, gl.R16F, gl.RED, halfFloatTexType);\n103      } else {\n104        formatRGBA = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n105        formatRG = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n106        formatR = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n107      }\n108\n109      return {\n110        gl,\n111        ext: {\n112          formatRGBA,\n113          formatRG,\n114          formatR,\n115          halfFloatTexType,\n116          supportLinearFiltering,\n117        },\n118      };\n119    }\n120\n121    function getSupportedFormat(gl, internalFormat, format, type) {\n122      if (!supportRenderTextureFormat(gl, internalFormat, format, type)) {\n123        switch (internalFormat) {\n124          case gl.R16F:\n125            return getSupportedFormat(gl, gl.RG16F, gl.RG, type);\n126          case gl.RG16F:\n127            return getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, type);\n128          default:\n129            return null;\n130        }\n131      }\n132      return {\n133        internalFormat,\n134        format,\n135      };\n136    }\n137\n138    function supportRenderTextureFormat(gl, internalFormat, format, type) {\n139      const texture = gl.createTexture();\n140      gl.bindTexture(gl.TEXTURE_2D, texture);\n141      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n142      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n143      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n144      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n145      gl.texImage2D(\n146        gl.TEXTURE_2D,\n147        0,\n148        internalFormat,\n149        4,\n150        4,\n151        0,\n152        format,\n153        type,\n154        null\n155      );\n156      const fbo = gl.createFramebuffer();\n157      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n158      gl.framebufferTexture2D(\n159        gl.FRAMEBUFFER,\n160        gl.COLOR_ATTACHMENT0,\n161        gl.TEXTURE_2D,\n162        texture,\n163        0\n164      );\n165      const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n166      return status === gl.FRAMEBUFFER_COMPLETE;\n167    }\n168\n169    class Material {\n170      constructor(vertexShader, fragmentShaderSource) {\n171        this.vertexShader = vertexShader;\n172        this.fragmentShaderSource = fragmentShaderSource;\n173        this.programs = [];\n174        this.activeProgram = null;\n175        this.uniforms = [];\n176      }\n177      setKeywords(keywords) {\n178        let hash = 0;\n179        for (let i = 0; i < keywords.length; i++) hash += hashCode(keywords[i]);\n180        let program = this.programs[hash];\n181        if (program == null) {\n182          let fragmentShader = compileShader(\n183            gl.FRAGMENT_SHADER,\n184            this.fragmentShaderSource,\n185            keywords\n186          );\n187          program = createProgram(this.vertexShader, fragmentShader);\n188          this.programs[hash] = program;\n189        }\n190        if (program === this.activeProgram) return;\n191        this.uniforms = getUniforms(program);\n192        this.activeProgram = program;\n193      }\n194      bind() {\n195        gl.useProgram(this.activeProgram);\n196      }\n197    }\n198\n199    class Program {\n200      constructor(vertexShader, fragmentShader) {\n201        this.uniforms = {};\n202        this.program = createProgram(vertexShader, fragmentShader);\n203        this.uniforms = getUniforms(this.program);\n204      }\n205      bind() {\n206        gl.useProgram(this.program);\n207      }\n208    }\n209\n210    function createProgram(vertexShader, fragmentShader) {\n211      let program = gl.createProgram();\n212      gl.attachShader(program, vertexShader);\n213      gl.attachShader(program, fragmentShader);\n214      gl.linkProgram(program);\n215      if (!gl.getProgramParameter(program, gl.LINK_STATUS))\n216        console.trace(gl.getProgramInfoLog(program));\n217      return program;\n218    }\n219\n220    function getUniforms(program) {\n221      let uniforms = [];\n222      let uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n223      for (let i = 0; i < uniformCount; i++) {\n224        let uniformName = gl.getActiveUniform(program, i).name;\n225        uniforms[uniformName] = gl.getUniformLocation(program, uniformName);\n226      }\n227      return uniforms;\n228    }\n229\n230    function compileShader(type, source, keywords) {\n231      source = addKeywords(source, keywords);\n232      const shader = gl.createShader(type);\n233      gl.shaderSource(shader, source);\n234      gl.compileShader(shader);\n235      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))\n236        console.trace(gl.getShaderInfoLog(shader));\n237      return shader;\n238    }\n239\n240    function addKeywords(source, keywords) {\n241      if (!keywords) return source;\n242      let keywordsString = '';\n243      keywords.forEach((keyword) => {\n244        keywordsString += '#define ' + keyword + '\\n';\n245      });\n246      return keywordsString + source;\n247    }\n248\n249    const baseVertexShader = compileShader(\n250      gl.VERTEX_SHADER,\n251      `\n252        precision highp float;\n253        attribute vec2 aPosition;\n254        varying vec2 vUv;\n255        varying vec2 vL;\n256        varying vec2 vR;\n257        varying vec2 vT;\n258        varying vec2 vB;\n259        uniform vec2 texelSize;\n260\n261        void main () {\n262            vUv = aPosition * 0.5 + 0.5;\n263            vL = vUv - vec2(texelSize.x, 0.0);\n264            vR = vUv + vec2(texelSize.x, 0.0);\n265            vT = vUv + vec2(0.0, texelSize.y);\n266            vB = vUv - vec2(0.0, texelSize.y);\n267            gl_Position = vec4(aPosition, 0.0, 1.0);\n268        }\n269      `\n270    );\n271\n272    const copyShader = compileShader(\n273      gl.FRAGMENT_SHADER,\n274      `\n275        precision mediump float;\n276        precision mediump sampler2D;\n277        varying highp vec2 vUv;\n278        uniform sampler2D uTexture;\n279\n280        void main () {\n281            gl_FragColor = texture2D(uTexture, vUv);\n282        }\n283      `\n284    );\n285\n286    const clearShader = compileShader(\n287      gl.FRAGMENT_SHADER,\n288      `\n289        precision mediump float;\n290        precision mediump sampler2D;\n291        varying highp vec2 vUv;\n292        uniform sampler2D uTexture;\n293        uniform float value;\n294\n295        void main () {\n296            gl_FragColor = value * texture2D(uTexture, vUv);\n297        }\n298     `\n299    );\n300\n301    const displayShaderSource = `\n302      precision highp float;\n303      precision highp sampler2D;\n304      varying vec2 vUv;\n305      varying vec2 vL;\n306      varying vec2 vR;\n307      varying vec2 vT;\n308      varying vec2 vB;\n309      uniform sampler2D uTexture;\n310      uniform sampler2D uDithering;\n311      uniform vec2 ditherScale;\n312      uniform vec2 texelSize;\n313\n314      vec3 linearToGamma (vec3 color) {\n315          color = max(color, vec3(0));\n316          return max(1.055 * pow(color, vec3(0.416666667)) - 0.055, vec3(0));\n317      }\n318\n319      void main () {\n320          vec3 c = texture2D(uTexture, vUv).rgb;\n321          #ifdef SHADING\n322              vec3 lc = texture2D(uTexture, vL).rgb;\n323              vec3 rc = texture2D(uTexture, vR).rgb;\n324              vec3 tc = texture2D(uTexture, vT).rgb;\n325              vec3 bc = texture2D(uTexture, vB).rgb;\n326\n327              float dx = length(rc) - length(lc);\n328              float dy = length(tc) - length(bc);\n329\n330              vec3 n = normalize(vec3(dx, dy, length(texelSize)));\n331              vec3 l = vec3(0.0, 0.0, 1.0);\n332\n333              float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);\n334              c *= diffuse;\n335          #endif\n336\n337          float a = max(c.r, max(c.g, c.b));\n338          gl_FragColor = vec4(c, a);\n339      }\n340    `;\n341\n342    const splatShader = compileShader(\n343      gl.FRAGMENT_SHADER,\n344      `\n345        precision highp float;\n346        precision highp sampler2D;\n347        varying vec2 vUv;\n348        uniform sampler2D uTarget;\n349        uniform float aspectRatio;\n350        uniform vec3 color;\n351        uniform vec2 point;\n352        uniform float radius;\n353\n354        void main () {\n355            vec2 p = vUv - point.xy;\n356            p.x *= aspectRatio;\n357            vec3 splat = exp(-dot(p, p) / radius) * color;\n358            vec3 base = texture2D(uTarget, vUv).xyz;\n359            gl_FragColor = vec4(base + splat, 1.0);\n360        }\n361      `\n362    );\n363\n364    const advectionShader = compileShader(\n365      gl.FRAGMENT_SHADER,\n366      `\n367        precision highp float;\n368        precision highp sampler2D;\n369        varying vec2 vUv;\n370        uniform sampler2D uVelocity;\n371        uniform sampler2D uSource;\n372        uniform vec2 texelSize;\n373        uniform vec2 dyeTexelSize;\n374        uniform float dt;\n375        uniform float dissipation;\n376\n377        vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {\n378            vec2 st = uv / tsize - 0.5;\n379            vec2 iuv = floor(st);\n380            vec2 fuv = fract(st);\n381\n382            vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);\n383            vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);\n384            vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);\n385            vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);\n386\n387            return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);\n388        }\n389\n390        void main () {\n391            #ifdef MANUAL_FILTERING\n392                vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;\n393                vec4 result = bilerp(uSource, coord, dyeTexelSize);\n394            #else\n395                vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\n396                vec4 result = texture2D(uSource, coord);\n397            #endif\n398            float decay = 1.0 + dissipation * dt;\n399            gl_FragColor = result / decay;\n400        }\n401      `,\n402      ext.supportLinearFiltering ? null : ['MANUAL_FILTERING']\n403    );\n404\n405    const divergenceShader = compileShader(\n406      gl.FRAGMENT_SHADER,\n407      `\n408        precision mediump float;\n409        precision mediump sampler2D;\n410        varying highp vec2 vUv;\n411        varying highp vec2 vL;\n412        varying highp vec2 vR;\n413        varying highp vec2 vT;\n414        varying highp vec2 vB;\n415        uniform sampler2D uVelocity;\n416\n417        void main () {\n418            float L = texture2D(uVelocity, vL).x;\n419            float R = texture2D(uVelocity, vR).x;\n420            float T = texture2D(uVelocity, vT).y;\n421            float B = texture2D(uVelocity, vB).y;\n422\n423            vec2 C = texture2D(uVelocity, vUv).xy;\n424            if (vL.x < 0.0) { L = -C.x; }\n425            if (vR.x > 1.0) { R = -C.x; }\n426            if (vT.y > 1.0) { T = -C.y; }\n427            if (vB.y < 0.0) { B = -C.y; }\n428\n429            float div = 0.5 * (R - L + T - B);\n430            gl_FragColor = vec4(div, 0.0, 0.0, 1.0);\n431        }\n432      `\n433    );\n434\n435    const curlShader = compileShader(\n436      gl.FRAGMENT_SHADER,\n437      `\n438        precision mediump float;\n439        precision mediump sampler2D;\n440        varying highp vec2 vUv;\n441        varying highp vec2 vL;\n442        varying highp vec2 vR;\n443        varying highp vec2 vT;\n444        varying highp vec2 vB;\n445        uniform sampler2D uVelocity;\n446\n447        void main () {\n448            float L = texture2D(uVelocity, vL).y;\n449            float R = texture2D(uVelocity, vR).y;\n450            float T = texture2D(uVelocity, vT).x;\n451            float B = texture2D(uVelocity, vB).x;\n452            float vorticity = R - L - T + B;\n453            gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);\n454        }\n455      `\n456    );\n457\n458    const vorticityShader = compileShader(\n459      gl.FRAGMENT_SHADER,\n460      `\n461        precision highp float;\n462        precision highp sampler2D;\n463        varying vec2 vUv;\n464        varying vec2 vL;\n465        varying vec2 vR;\n466        varying vec2 vT;\n467        varying vec2 vB;\n468        uniform sampler2D uVelocity;\n469        uniform sampler2D uCurl;\n470        uniform float curl;\n471        uniform float dt;\n472\n473        void main () {\n474            float L = texture2D(uCurl, vL).x;\n475            float R = texture2D(uCurl, vR).x;\n476            float T = texture2D(uCurl, vT).x;\n477            float B = texture2D(uCurl, vB).x;\n478            float C = texture2D(uCurl, vUv).x;\n479\n480            vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));\n481            force /= length(force) + 0.0001;\n482            force *= curl * C;\n483            force.y *= -1.0;\n484\n485            vec2 velocity = texture2D(uVelocity, vUv).xy;\n486            velocity += force * dt;\n487            velocity = min(max(velocity, -1000.0), 1000.0);\n488            gl_FragColor = vec4(velocity, 0.0, 1.0);\n489        }\n490      `\n491    );\n492\n493    const pressureShader = compileShader(\n494      gl.FRAGMENT_SHADER,\n495      `\n496        precision mediump float;\n497        precision mediump sampler2D;\n498        varying highp vec2 vUv;\n499        varying highp vec2 vL;\n500        varying highp vec2 vR;\n501        varying highp vec2 vT;\n502        varying highp vec2 vB;\n503        uniform sampler2D uPressure;\n504        uniform sampler2D uDivergence;\n505\n506        void main () {\n507            float L = texture2D(uPressure, vL).x;\n508            float R = texture2D(uPressure, vR).x;\n509            float T = texture2D(uPressure, vT).x;\n510            float B = texture2D(uPressure, vB).x;\n511            float C = texture2D(uPressure, vUv).x;\n512            float divergence = texture2D(uDivergence, vUv).x;\n513            float pressure = (L + R + B + T - divergence) * 0.25;\n514            gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\n515        }\n516      `\n517    );\n518\n519    const gradientSubtractShader = compileShader(\n520      gl.FRAGMENT_SHADER,\n521      `\n522        precision mediump float;\n523        precision mediump sampler2D;\n524        varying highp vec2 vUv;\n525        varying highp vec2 vL;\n526        varying highp vec2 vR;\n527        varying highp vec2 vT;\n528        varying highp vec2 vB;\n529        uniform sampler2D uPressure;\n530        uniform sampler2D uVelocity;\n531\n532        void main () {\n533            float L = texture2D(uPressure, vL).x;\n534            float R = texture2D(uPressure, vR).x;\n535            float T = texture2D(uPressure, vT).x;\n536            float B = texture2D(uPressure, vB).x;\n537            vec2 velocity = texture2D(uVelocity, vUv).xy;\n538            velocity.xy -= vec2(R - L, T - B);\n539            gl_FragColor = vec4(velocity, 0.0, 1.0);\n540        }\n541      `\n542    );\n543\n544    const blit = (() => {\n545      gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n546      gl.bufferData(\n547        gl.ARRAY_BUFFER,\n548        new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]),\n549        gl.STATIC_DRAW\n550      );\n551      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());\n552      gl.bufferData(\n553        gl.ELEMENT_ARRAY_BUFFER,\n554        new Uint16Array([0, 1, 2, 0, 2, 3]),\n555        gl.STATIC_DRAW\n556      );\n557      gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n558      gl.enableVertexAttribArray(0);\n559      return (target, clear = false) => {\n560        if (target == null) {\n561          gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n562          gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n563        } else {\n564          gl.viewport(0, 0, target.width, target.height);\n565          gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);\n566        }\n567        if (clear) {\n568          gl.clearColor(0.0, 0.0, 0.0, 1.0);\n569          gl.clear(gl.COLOR_BUFFER_BIT);\n570        }\n571        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n572      };\n573    })();\n574\n575    let dye, velocity, divergence, curl, pressure;\n576\n577    const copyProgram = new Program(baseVertexShader, copyShader);\n578    const clearProgram = new Program(baseVertexShader, clearShader);\n579    const splatProgram = new Program(baseVertexShader, splatShader);\n580    const advectionProgram = new Program(baseVertexShader, advectionShader);\n581    const divergenceProgram = new Program(baseVertexShader, divergenceShader);\n582    const curlProgram = new Program(baseVertexShader, curlShader);\n583    const vorticityProgram = new Program(baseVertexShader, vorticityShader);\n584    const pressureProgram = new Program(baseVertexShader, pressureShader);\n585    const gradienSubtractProgram = new Program(baseVertexShader, gradientSubtractShader);\n586    const displayMaterial = new Material(baseVertexShader, displayShaderSource);\n587\n588    function initFramebuffers() {\n589      let simRes = getResolution(config.SIM_RESOLUTION);\n590      let dyeRes = getResolution(config.DYE_RESOLUTION);\n591      const texType = ext.halfFloatTexType;\n592      const rgba = ext.formatRGBA;\n593      const rg = ext.formatRG;\n594      const r = ext.formatR;\n595      const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;\n596      gl.disable(gl.BLEND);\n597\n598      if (!dye)\n599        dye = createDoubleFBO(\n600          dyeRes.width,\n601          dyeRes.height,\n602          rgba.internalFormat,\n603          rgba.format,\n604          texType,\n605          filtering\n606        );\n607      else\n608        dye = resizeDoubleFBO(\n609          dye,\n610          dyeRes.width,\n611          dyeRes.height,\n612          rgba.internalFormat,\n613          rgba.format,\n614          texType,\n615          filtering\n616        );\n617\n618      if (!velocity)\n619        velocity = createDoubleFBO(\n620          simRes.width,\n621          simRes.height,\n622          rg.internalFormat,\n623          rg.format,\n624          texType,\n625          filtering\n626        );\n627      else\n628        velocity = resizeDoubleFBO(\n629          velocity,\n630          simRes.width,\n631          simRes.height,\n632          rg.internalFormat,\n633          rg.format,\n634          texType,\n635          filtering\n636        );\n637\n638      divergence = createFBO(\n639        simRes.width,\n640        simRes.height,\n641        r.internalFormat,\n642        r.format,\n643        texType,\n644        gl.NEAREST\n645      );\n646      curl = createFBO(\n647        simRes.width,\n648        simRes.height,\n649        r.internalFormat,\n650        r.format,\n651        texType,\n652        gl.NEAREST\n653      );\n654      pressure = createDoubleFBO(\n655        simRes.width,\n656        simRes.height,\n657        r.internalFormat,\n658        r.format,\n659        texType,\n660        gl.NEAREST\n661      );\n662    }\n663\n664    function createFBO(w, h, internalFormat, format, type, param) {\n665      gl.activeTexture(gl.TEXTURE0);\n666      let texture = gl.createTexture();\n667      gl.bindTexture(gl.TEXTURE_2D, texture);\n668      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);\n669      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);\n670      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n671      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n672      gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);\n673\n674      let fbo = gl.createFramebuffer();\n675      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n676      gl.framebufferTexture2D(\n677        gl.FRAMEBUFFER,\n678        gl.COLOR_ATTACHMENT0,\n679        gl.TEXTURE_2D,\n680        texture,\n681        0\n682      );\n683      gl.viewport(0, 0, w, h);\n684      gl.clear(gl.COLOR_BUFFER_BIT);\n685\n686      let texelSizeX = 1.0 / w;\n687      let texelSizeY = 1.0 / h;\n688      return {\n689        texture,\n690        fbo,\n691        width: w,\n692        height: h,\n693        texelSizeX,\n694        texelSizeY,\n695        attach(id) {\n696          gl.activeTexture(gl.TEXTURE0 + id);\n697          gl.bindTexture(gl.TEXTURE_2D, texture);\n698          return id;\n699        },\n700      };\n701    }\n702\n703    function createDoubleFBO(w, h, internalFormat, format, type, param) {\n704      let fbo1 = createFBO(w, h, internalFormat, format, type, param);\n705      let fbo2 = createFBO(w, h, internalFormat, format, type, param);\n706      return {\n707        width: w,\n708        height: h,\n709        texelSizeX: fbo1.texelSizeX,\n710        texelSizeY: fbo1.texelSizeY,\n711        get read() {\n712          return fbo1;\n713        },\n714        set read(value) {\n715          fbo1 = value;\n716        },\n717        get write() {\n718          return fbo2;\n719        },\n720        set write(value) {\n721          fbo2 = value;\n722        },\n723        swap() {\n724          let temp = fbo1;\n725          fbo1 = fbo2;\n726          fbo2 = temp;\n727        },\n728      };\n729    }\n730\n731    function resizeFBO(target, w, h, internalFormat, format, type, param) {\n732      let newFBO = createFBO(w, h, internalFormat, format, type, param);\n733      copyProgram.bind();\n734      gl.uniform1i(copyProgram.uniforms.uTexture, target.attach(0));\n735      blit(newFBO);\n736      return newFBO;\n737    }\n738\n739    function resizeDoubleFBO(target, w, h, internalFormat, format, type, param) {\n740      if (target.width === w && target.height === h) return target;\n741      target.read = resizeFBO(\n742        target.read,\n743        w,\n744        h,\n745        internalFormat,\n746        format,\n747        type,\n748        param\n749      );\n750      target.write = createFBO(w, h, internalFormat, format, type, param);\n751      target.width = w;\n752      target.height = h;\n753      target.texelSizeX = 1.0 / w;\n754      target.texelSizeY = 1.0 / h;\n755      return target;\n756    }\n757\n758    function updateKeywords() {\n759      let displayKeywords = [];\n760      if (config.SHADING) displayKeywords.push('SHADING');\n761      displayMaterial.setKeywords(displayKeywords);\n762    }\n763\n764    updateKeywords();\n765    initFramebuffers();\n766    let lastUpdateTime = Date.now();\n767    let colorUpdateTimer = 0.0;\n768\n769    function updateFrame() {\n770      const dt = calcDeltaTime();\n771      if (resizeCanvas()) initFramebuffers();\n772      updateColors(dt);\n773      applyInputs();\n774      step(dt);\n775      render(null);\n776      requestAnimationFrame(updateFrame);\n777    }\n778\n779    function calcDeltaTime() {\n780      let now = Date.now();\n781      let dt = (now - lastUpdateTime) / 1000;\n782      dt = Math.min(dt, 0.016666);\n783      lastUpdateTime = now;\n784      return dt;\n785    }\n786\n787    function resizeCanvas() {\n788      let width = scaleByPixelRatio(canvas.clientWidth);\n789      let height = scaleByPixelRatio(canvas.clientHeight);\n790      if (canvas.width !== width || canvas.height !== height) {\n791        canvas.width = width;\n792        canvas.height = height;\n793        return true;\n794      }\n795      return false;\n796    }\n797\n798    function updateColors(dt) {\n799      colorUpdateTimer += dt * config.COLOR_UPDATE_SPEED;\n800      if (colorUpdateTimer >= 1) {\n801        colorUpdateTimer = wrap(colorUpdateTimer, 0, 1);\n802        pointers.forEach((p) => {\n803          p.color = generateColor();\n804        });\n805      }\n806    }\n807\n808    function applyInputs() {\n809      pointers.forEach((p) => {\n810        if (p.moved) {\n811          p.moved = false;\n812          splatPointer(p);\n813        }\n814      });\n815    }\n816\n817    function step(dt) {\n818      gl.disable(gl.BLEND);\n819      // Curl\n820      curlProgram.bind();\n821      gl.uniform2f(\n822        curlProgram.uniforms.texelSize,\n823        velocity.texelSizeX,\n824        velocity.texelSizeY\n825      );\n826      gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.attach(0));\n827      blit(curl);\n828\n829      // Vorticity\n830      vorticityProgram.bind();\n831      gl.uniform2f(\n832        vorticityProgram.uniforms.texelSize,\n833        velocity.texelSizeX,\n834        velocity.texelSizeY\n835      );\n836      gl.uniform1i(vorticityProgram.uniforms.uVelocity, velocity.read.attach(0));\n837      gl.uniform1i(vorticityProgram.uniforms.uCurl, curl.attach(1));\n838      gl.uniform1f(vorticityProgram.uniforms.curl, config.CURL);\n839      gl.uniform1f(vorticityProgram.uniforms.dt, dt);\n840      blit(velocity.write);\n841      velocity.swap();\n842\n843      // Divergence\n844      divergenceProgram.bind();\n845      gl.uniform2f(\n846        divergenceProgram.uniforms.texelSize,\n847        velocity.texelSizeX,\n848        velocity.texelSizeY\n849      );\n850      gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read.attach(0));\n851      blit(divergence);\n852\n853      // Clear pressure\n854      clearProgram.bind();\n855      gl.uniform1i(clearProgram.uniforms.uTexture, pressure.read.attach(0));\n856      gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE);\n857      blit(pressure.write);\n858      pressure.swap();\n859\n860      // Pressure\n861      pressureProgram.bind();\n862      gl.uniform2f(\n863        pressureProgram.uniforms.texelSize,\n864        velocity.texelSizeX,\n865        velocity.texelSizeY\n866      );\n867      gl.uniform1i(pressureProgram.uniforms.uDivergence, divergence.attach(0));\n868      for (let i = 0; i < config.PRESSURE_ITERATIONS; i++) {\n869        gl.uniform1i(pressureProgram.uniforms.uPressure, pressure.read.attach(1));\n870        blit(pressure.write);\n871        pressure.swap();\n872      }\n873\n874      // Gradient Subtract\n875      gradienSubtractProgram.bind();\n876      gl.uniform2f(\n877        gradienSubtractProgram.uniforms.texelSize,\n878        velocity.texelSizeX,\n879        velocity.texelSizeY\n880      );\n881      gl.uniform1i(\n882        gradienSubtractProgram.uniforms.uPressure,\n883        pressure.read.attach(0)\n884      );\n885      gl.uniform1i(\n886        gradienSubtractProgram.uniforms.uVelocity,\n887        velocity.read.attach(1)\n888      );\n889      blit(velocity.write);\n890      velocity.swap();\n891\n892      // Advection\n893      advectionProgram.bind();\n894      gl.uniform2f(\n895        advectionProgram.uniforms.texelSize,\n896        velocity.texelSizeX,\n897        velocity.texelSizeY\n898      );\n899      if (!ext.supportLinearFiltering)\n900        gl.uniform2f(\n901          advectionProgram.uniforms.dyeTexelSize,\n902          velocity.texelSizeX,\n903          velocity.texelSizeY\n904        );\n905      let velocityId = velocity.read.attach(0);\n906      gl.uniform1i(advectionProgram.uniforms.uVelocity, velocityId);\n907      gl.uniform1i(advectionProgram.uniforms.uSource, velocityId);\n908      gl.uniform1f(advectionProgram.uniforms.dt, dt);\n909      gl.uniform1f(\n910        advectionProgram.uniforms.dissipation,\n911        config.VELOCITY_DISSIPATION\n912      );\n913      blit(velocity.write);\n914      velocity.swap();\n915\n916      if (!ext.supportLinearFiltering)\n917        gl.uniform2f(\n918          advectionProgram.uniforms.dyeTexelSize,\n919          dye.texelSizeX,\n920          dye.texelSizeY\n921        );\n922      gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.attach(0));\n923      gl.uniform1i(advectionProgram.uniforms.uSource, dye.read.attach(1));\n924      gl.uniform1f(\n925        advectionProgram.uniforms.dissipation,\n926        config.DENSITY_DISSIPATION\n927      );\n928      blit(dye.write);\n929      dye.swap();\n930    }\n931\n932    function render(target) {\n933      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n934      gl.enable(gl.BLEND);\n935      drawDisplay(target);\n936    }\n937\n938    function drawDisplay(target) {\n939      let width = target == null ? gl.drawingBufferWidth : target.width;\n940      let height = target == null ? gl.drawingBufferHeight : target.height;\n941      displayMaterial.bind();\n942      if (config.SHADING)\n943        gl.uniform2f(displayMaterial.uniforms.texelSize, 1.0 / width, 1.0 / height);\n944      gl.uniform1i(displayMaterial.uniforms.uTexture, dye.read.attach(0));\n945      blit(target);\n946    }\n947\n948    function splatPointer(pointer) {\n949      let dx = pointer.deltaX * config.SPLAT_FORCE;\n950      let dy = pointer.deltaY * config.SPLAT_FORCE;\n951      splat(pointer.texcoordX, pointer.texcoordY, dx, dy, pointer.color);\n952    }\n953\n954    function clickSplat(pointer) {\n955      const color = generateColor();\n956      color.r *= 10.0;\n957      color.g *= 10.0;\n958      color.b *= 10.0;\n959      let dx = 10 * (Math.random() - 0.5);\n960      let dy = 30 * (Math.random() - 0.5);\n961      splat(pointer.texcoordX, pointer.texcoordY, dx, dy, color);\n962    }\n963\n964    function splat(x, y, dx, dy, color) {\n965      splatProgram.bind();\n966      gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.attach(0));\n967      gl.uniform1f(\n968        splatProgram.uniforms.aspectRatio,\n969        canvas.width / canvas.height\n970      );\n971      gl.uniform2f(splatProgram.uniforms.point, x, y);\n972      gl.uniform3f(splatProgram.uniforms.color, dx, dy, 0.0);\n973      gl.uniform1f(splatProgram.uniforms.radius, correctRadius(config.SPLAT_RADIUS / 100.0));\n974      blit(velocity.write);\n975      velocity.swap();\n976\n977      gl.uniform1i(splatProgram.uniforms.uTarget, dye.read.attach(0));\n978      gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);\n979      blit(dye.write);\n980      dye.swap();\n981    }\n982\n983    function correctRadius(radius) {\n984      let aspectRatio = canvas.width / canvas.height;\n985      if (aspectRatio > 1) radius *= aspectRatio;\n986      return radius;\n987    }\n988\n989    function updatePointerDownData(pointer, id, posX, posY) {\n990      pointer.id = id;\n991      pointer.down = true;\n992      pointer.moved = false;\n993      pointer.texcoordX = posX / canvas.width;\n994      pointer.texcoordY = 1.0 - posY / canvas.height;\n995      pointer.prevTexcoordX = pointer.texcoordX;\n996      pointer.prevTexcoordY = pointer.texcoordY;\n997      pointer.deltaX = 0;\n998      pointer.deltaY = 0;\n999      pointer.color = generateColor();\n1000    }\n1001\n1002    function updatePointerMoveData(pointer, posX, posY, color) {\n1003      pointer.prevTexcoordX = pointer.texcoordX;\n1004      pointer.prevTexcoordY = pointer.texcoordY;\n1005      pointer.texcoordX = posX / canvas.width;\n1006      pointer.texcoordY = 1.0 - posY / canvas.height;\n1007      pointer.deltaX = correctDeltaX(pointer.texcoordX - pointer.prevTexcoordX);\n1008      pointer.deltaY = correctDeltaY(pointer.texcoordY - pointer.prevTexcoordY);\n1009      pointer.moved = Math.abs(pointer.deltaX) > 0 || Math.abs(pointer.deltaY) > 0;\n1010      pointer.color = color;\n1011    }\n1012\n1013    function updatePointerUpData(pointer) {\n1014      pointer.down = false;\n1015    }\n1016\n1017    function correctDeltaX(delta) {\n1018      let aspectRatio = canvas.width / canvas.height;\n1019      if (aspectRatio < 1) delta *= aspectRatio;\n1020      return delta;\n1021    }\n1022\n1023    function correctDeltaY(delta) {\n1024      let aspectRatio = canvas.width / canvas.height;\n1025      if (aspectRatio > 1) delta /= aspectRatio;\n1026      return delta;\n1027    }\n1028\n1029    function generateColor() {\n1030      let c = HSVtoRGB(Math.random(), 1.0, 1.0);\n1031      c.r *= 0.15;\n1032      c.g *= 0.15;\n1033      c.b *= 0.15;\n1034      return c;\n1035    }\n1036\n1037    function HSVtoRGB(h, s, v) {\n1038      let r, g, b, i, f, p, q, t;\n1039      i = Math.floor(h * 6);\n1040      f = h * 6 - i;\n1041      p = v * (1 - s);\n1042      q = v * (1 - f * s);\n1043      t = v * (1 - (1 - f) * s);\n1044      switch (i % 6) {\n1045        case 0:\n1046          r = v;\n1047          g = t;\n1048          b = p;\n1049          break;\n1050        case 1:\n1051          r = q;\n1052          g = v;\n1053          b = p;\n1054          break;\n1055        case 2:\n1056          r = p;\n1057          g = v;\n1058          b = t;\n1059          break;\n1060        case 3:\n1061          r = p;\n1062          g = q;\n1063          b = v;\n1064          break;\n1065        case 4:\n1066          r = t;\n1067          g = p;\n1068          b = v;\n1069          break;\n1070        case 5:\n1071          r = v;\n1072          g = p;\n1073          b = q;\n1074          break;\n1075        default:\n1076          break;\n1077      }\n1078      return { r, g, b };\n1079    }\n1080\n1081    function wrap(value, min, max) {\n1082      const range = max - min;\n1083      if (range === 0) return min;\n1084      return ((value - min) % range) + min;\n1085    }\n1086\n1087    function getResolution(resolution) {\n1088      let aspectRatio = gl.drawingBufferWidth / gl.drawingBufferHeight;\n1089      if (aspectRatio < 1) aspectRatio = 1.0 / aspectRatio;\n1090      const min = Math.round(resolution);\n1091      const max = Math.round(resolution * aspectRatio);\n1092      if (gl.drawingBufferWidth > gl.drawingBufferHeight)\n1093        return { width: max, height: min };\n1094      else return { width: min, height: max };\n1095    }\n1096\n1097    function scaleByPixelRatio(input) {\n1098      const pixelRatio = window.devicePixelRatio || 1;\n1099      return Math.floor(input * pixelRatio);\n1100    }\n1101\n1102    function hashCode(s) {\n1103      if (s.length === 0) return 0;\n1104      let hash = 0;\n1105      for (let i = 0; i < s.length; i++) {\n1106        hash = (hash << 5) - hash + s.charCodeAt(i);\n1107        hash |= 0;\n1108      }\n1109      return hash;\n1110    }\n1111\n1112    window.addEventListener('mousedown', (e) => {\n1113      let pointer = pointers[0];\n1114      let posX = scaleByPixelRatio(e.clientX);\n1115      let posY = scaleByPixelRatio(e.clientY);\n1116      updatePointerDownData(pointer, -1, posX, posY);\n1117      clickSplat(pointer);\n1118    });\n1119\n1120    document.body.addEventListener('mousemove', function handleFirstMouseMove(e) {\n1121      let pointer = pointers[0];\n1122      let posX = scaleByPixelRatio(e.clientX);\n1123      let posY = scaleByPixelRatio(e.clientY);\n1124      let color = generateColor();\n1125      updateFrame(); // start animation loop\n1126      updatePointerMoveData(pointer, posX, posY, color);\n1127      document.body.removeEventListener('mousemove', handleFirstMouseMove);\n1128    });\n1129\n1130    window.addEventListener('mousemove', (e) => {\n1131      let pointer = pointers[0];\n1132      let posX = scaleByPixelRatio(e.clientX);\n1133      let posY = scaleByPixelRatio(e.clientY);\n1134      let color = pointer.color;\n1135      updatePointerMoveData(pointer, posX, posY, color);\n1136    });\n1137\n1138    document.body.addEventListener('touchstart', function handleFirstTouchStart(e) {\n1139      const touches = e.targetTouches;\n1140      let pointer = pointers[0];\n1141      for (let i = 0; i < touches.length; i++) {\n1142        let posX = scaleByPixelRatio(touches[i].clientX);\n1143        let posY = scaleByPixelRatio(touches[i].clientY);\n1144        updateFrame(); // start animation loop\n1145        updatePointerDownData(pointer, touches[i].identifier, posX, posY);\n1146      }\n1147      document.body.removeEventListener('touchstart', handleFirstTouchStart);\n1148    });\n1149\n1150    window.addEventListener('touchstart', (e) => {\n1151      const touches = e.targetTouches;\n1152      let pointer = pointers[0];\n1153      for (let i = 0; i < touches.length; i++) {\n1154        let posX = scaleByPixelRatio(touches[i].clientX);\n1155        let posY = scaleByPixelRatio(touches[i].clientY);\n1156        updatePointerDownData(pointer, touches[i].identifier, posX, posY);\n1157      }\n1158    });\n1159\n1160    window.addEventListener(\n1161      'touchmove',\n1162      (e) => {\n1163        const touches = e.targetTouches;\n1164        let pointer = pointers[0];\n1165        for (let i = 0; i < touches.length; i++) {\n1166          let posX = scaleByPixelRatio(touches[i].clientX);\n1167          let posY = scaleByPixelRatio(touches[i].clientY);\n1168          updatePointerMoveData(pointer, posX, posY, pointer.color);\n1169        }\n1170      },\n1171      false\n1172    );\n1173\n1174    window.addEventListener('touchend', (e) => {\n1175      const touches = e.changedTouches;\n1176      let pointer = pointers[0];\n1177      for (let i = 0; i < touches.length; i++) {\n1178        updatePointerUpData(pointer);\n1179      }\n1180    });\n1181\n1182    updateFrame();\n1183    // eslint-disable-next-line react-hooks/exhaustive-deps\n1184  }, [\n1185    SIM_RESOLUTION,\n1186    DYE_RESOLUTION,\n1187    CAPTURE_RESOLUTION,\n1188    DENSITY_DISSIPATION,\n1189    VELOCITY_DISSIPATION,\n1190    PRESSURE,\n1191    PRESSURE_ITERATIONS,\n1192    CURL,\n1193    SPLAT_RADIUS,\n1194    SPLAT_FORCE,\n1195    SHADING,\n1196    COLOR_UPDATE_SPEED,\n1197    BACK_COLOR,\n1198    TRANSPARENT,\n1199  ]);\n1200\n1201  return (\n1202    <div className=\"fixed top-0 left-0 z-50 pointer-events-none w-full h-full\">\n1203      <canvas ref={canvasRef} id=\"fluid\" className=\"w-screen h-screen block\"></canvas>\n1204    </div>\n1205  );\n1206}\n1207\n1208export default SplashCursor;",
  "category": "animations",
  "scrapedAt": "2025-04-27T11:48:45.425Z",
  "previewImage": "splash-cursor-preview.png"
}