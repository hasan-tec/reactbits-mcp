{
  "name": "Ribbons",
  "description": "An open source collection of high quality, animated, interactive & fully customizable React components for building stunning, memorable user interfaces.",
  "props": {},
  "dependencies": [],
  "previewImage": "",
  "url": "https://www.reactbits.dev/animations/ribbons",
  "code": "1npm i ogl\n\n1import Ribbons from './Ribbons';\n2\n3<div style={{ height: '500px', position: 'relative', overflow: 'hidden'}}>\n4  <Ribbons\n5    baseThickness={30}\n6    colors={['#ffffff']}\n7    speedMultiplier={0.5}\n8    maxAge={500}\n9    enableFade={false}\n10    enableShaderEffect={true}\n11  />\n12</div>\n\n1import { useEffect, useRef } from 'react';\n2import { Renderer, Transform, Vec3, Color, Polyline } from 'ogl';\n3\n4import './Ribbons.css';\n5\n6const Ribbons = ({\n7  colors = ['#FC8EAC'],\n8  baseSpring = 0.03,\n9  baseFriction = 0.9,\n10  baseThickness = 30,\n11  offsetFactor = 0.05,\n12  maxAge = 500,\n13  pointCount = 50,\n14  speedMultiplier = 0.6,\n15  enableFade = false,\n16  enableShaderEffect = false,\n17  effectAmplitude = 2,\n18  backgroundColor = [0, 0, 0, 0],\n19}) => {\n20  const containerRef = useRef(null);\n21\n22  useEffect(() => {\n23    const container = containerRef.current;\n24    if (!container) return;\n25\n26    const renderer = new Renderer({ dpr: window.devicePixelRatio || 2, alpha: true });\n27    const gl = renderer.gl;\n28    if (Array.isArray(backgroundColor) && backgroundColor.length === 4) {\n29      gl.clearColor(\n30        backgroundColor[0],\n31        backgroundColor[1],\n32        backgroundColor[2],\n33        backgroundColor[3]\n34      );\n35    } else {\n36      gl.clearColor(0, 0, 0, 0);\n37    }\n38\n39    gl.canvas.style.position = 'absolute';\n40    gl.canvas.style.top = '0';\n41    gl.canvas.style.left = '0';\n42    gl.canvas.style.width = '100%';\n43    gl.canvas.style.height = '100%';\n44    container.appendChild(gl.canvas);\n45\n46    const scene = new Transform();\n47    const lines = [];\n48\n49    const vertex = `\n50      precision highp float;\n51      \n52      attribute vec3 position;\n53      attribute vec3 next;\n54      attribute vec3 prev;\n55      attribute vec2 uv;\n56      attribute float side;\n57      \n58      uniform vec2 uResolution;\n59      uniform float uDPR;\n60      uniform float uThickness;\n61      uniform float uTime;\n62      uniform float uEnableShaderEffect;\n63      uniform float uEffectAmplitude;\n64      \n65      varying vec2 vUV;\n66      \n67      vec4 getPosition() {\n68          vec4 current = vec4(position, 1.0);\n69          vec2 aspect = vec2(uResolution.x / uResolution.y, 1.0);\n70          vec2 nextScreen = next.xy * aspect;\n71          vec2 prevScreen = prev.xy * aspect;\n72          vec2 tangent = normalize(nextScreen - prevScreen);\n73          vec2 normal = vec2(-tangent.y, tangent.x);\n74          normal /= aspect;\n75          normal *= mix(1.0, 0.1, pow(abs(uv.y - 0.5) * 2.0, 2.0));\n76          float dist = length(nextScreen - prevScreen);\n77          normal *= smoothstep(0.0, 0.02, dist);\n78          float pixelWidthRatio = 1.0 / (uResolution.y / uDPR);\n79          float pixelWidth = current.w * pixelWidthRatio;\n80          normal *= pixelWidth * uThickness;\n81          current.xy -= normal * side;\n82          if(uEnableShaderEffect > 0.5) {\n83            current.xy += normal * sin(uTime + current.x * 10.0) * uEffectAmplitude;\n84          }\n85          return current;\n86      }\n87      \n88      void main() {\n89          // Pass the original uv to the fragment shader.\n90          vUV = uv;\n91          gl_Position = getPosition();\n92      }\n93    `;\n94\n95    const fragment = `\n96      precision highp float;\n97      uniform vec3 uColor;\n98      uniform float uOpacity;\n99      uniform float uEnableFade;\n100      varying vec2 vUV;\n101      void main() {\n102          float fadeFactor = 1.0;\n103          if(uEnableFade > 0.5) {\n104              fadeFactor = 1.0 - smoothstep(0.0, 1.0, vUV.y);\n105          }\n106          gl_FragColor = vec4(uColor, uOpacity * fadeFactor);\n107      }\n108    `;\n109\n110    function resize() {\n111      const width = container.clientWidth;\n112      const height = container.clientHeight;\n113      renderer.setSize(width, height);\n114      lines.forEach(line => line.polyline.resize());\n115    }\n116    window.addEventListener('resize', resize);\n117\n118    const center = (colors.length - 1) / 2;\n119    colors.forEach((color, index) => {\n120      const spring = baseSpring + (Math.random() - 0.5) * 0.05;\n121      const friction = baseFriction + (Math.random() - 0.5) * 0.05;\n122      const thickness = baseThickness + (Math.random() - 0.5) * 3;\n123      const mouseOffset = new Vec3(\n124        (index - center) * offsetFactor + (Math.random() - 0.5) * 0.01,\n125        (Math.random() - 0.5) * 0.1,\n126        0\n127      );\n128\n129      const line = {\n130        spring,\n131        friction,\n132        mouseVelocity: new Vec3(),\n133        mouseOffset,\n134      };\n135\n136      const count = pointCount;\n137      const points = [];\n138      for (let i = 0; i < count; i++) {\n139        points.push(new Vec3());\n140      }\n141      line.points = points;\n142\n143      line.polyline = new Polyline(gl, {\n144        points,\n145        vertex,\n146        fragment,\n147        uniforms: {\n148          uColor: { value: new Color(color) },\n149          uThickness: { value: thickness },\n150          uOpacity: { value: 1.0 },\n151          uTime: { value: 0.0 },\n152          uEnableShaderEffect: { value: enableShaderEffect ? 1.0 : 0.0 },\n153          uEffectAmplitude: { value: effectAmplitude },\n154          uEnableFade: { value: enableFade ? 1.0 : 0.0 },\n155        },\n156      });\n157      line.polyline.mesh.setParent(scene);\n158      lines.push(line);\n159    });\n160\n161    resize();\n162\n163    const mouse = new Vec3();\n164    function updateMouse(e) {\n165      let x, y;\n166      const rect = container.getBoundingClientRect();\n167      if (e.changedTouches && e.changedTouches.length) {\n168        x = e.changedTouches[0].clientX - rect.left;\n169        y = e.changedTouches[0].clientY - rect.top;\n170      } else {\n171        x = e.clientX - rect.left;\n172        y = e.clientY - rect.top;\n173      }\n174      const width = container.clientWidth;\n175      const height = container.clientHeight;\n176      mouse.set((x / width) * 2 - 1, (y / height) * -2 + 1, 0);\n177    }\n178    container.addEventListener('mousemove', updateMouse);\n179    container.addEventListener('touchstart', updateMouse);\n180    container.addEventListener('touchmove', updateMouse);\n181\n182    const tmp = new Vec3();\n183    let frameId;\n184    let lastTime = performance.now();\n185    function update() {\n186      frameId = requestAnimationFrame(update);\n187      const currentTime = performance.now();\n188      const dt = currentTime - lastTime;\n189      lastTime = currentTime;\n190\n191      lines.forEach(line => {\n192        tmp.copy(mouse)\n193          .add(line.mouseOffset)\n194          .sub(line.points[0])\n195          .multiply(line.spring);\n196        line.mouseVelocity.add(tmp).multiply(line.friction);\n197        line.points[0].add(line.mouseVelocity);\n198\n199        for (let i = 1; i < line.points.length; i++) {\n200          if (isFinite(maxAge) && maxAge > 0) {\n201            const segmentDelay = maxAge / (line.points.length - 1);\n202            const alpha = Math.min(1, (dt * speedMultiplier) / segmentDelay);\n203            line.points[i].lerp(line.points[i - 1], alpha);\n204          } else {\n205            line.points[i].lerp(line.points[i - 1], 0.9);\n206          }\n207        }\n208        if (line.polyline.mesh.program.uniforms.uTime) {\n209          line.polyline.mesh.program.uniforms.uTime.value = currentTime * 0.001;\n210        }\n211        line.polyline.updateGeometry();\n212      });\n213\n214      renderer.render({ scene });\n215    }\n216    update();\n217\n218    return () => {\n219      window.removeEventListener('resize', resize);\n220      container.removeEventListener('mousemove', updateMouse);\n221      container.removeEventListener('touchstart', updateMouse);\n222      container.removeEventListener('touchmove', updateMouse);\n223      cancelAnimationFrame(frameId);\n224      if (gl.canvas && gl.canvas.parentNode === container) {\n225        container.removeChild(gl.canvas);\n226      }\n227    };\n228  }, [\n229    colors,\n230    baseSpring,\n231    baseFriction,\n232    baseThickness,\n233    offsetFactor,\n234    maxAge,\n235    pointCount,\n236    speedMultiplier,\n237    enableFade,\n238    enableShaderEffect,\n239    effectAmplitude,\n240    backgroundColor\n241  ]);\n242\n243  return (\n244    <div\n245      ref={containerRef}\n246      className=\"ribbons-container\"\n247    />\n248  );\n249};\n250\n251export default Ribbons;\n252\n\n1.ribbons-container {\n2  width: 100%;\n3  height: 100%;\n4  position: relative;\n5}\n\n1import { useEffect, useRef } from 'react';\n2import { Renderer, Transform, Vec3, Color, Polyline } from 'ogl';\n3\n4const Ribbons = ({\n5  colors = ['#FC8EAC'],\n6  baseSpring = 0.03,\n7  baseFriction = 0.9,\n8  baseThickness = 30,\n9  offsetFactor = 0.05,\n10  maxAge = 500,\n11  pointCount = 50,\n12  speedMultiplier = 0.6,\n13  enableFade = false,\n14  enableShaderEffect = false,\n15  effectAmplitude = 2,\n16  backgroundColor = [0, 0, 0, 0],\n17}) => {\n18  const containerRef = useRef(null);\n19\n20  useEffect(() => {\n21    const container = containerRef.current;\n22    if (!container) return;\n23\n24    const renderer = new Renderer({ dpr: window.devicePixelRatio || 2, alpha: true });\n25    const gl = renderer.gl;\n26    if (Array.isArray(backgroundColor) && backgroundColor.length === 4) {\n27      gl.clearColor(\n28        backgroundColor[0],\n29        backgroundColor[1],\n30        backgroundColor[2],\n31        backgroundColor[3]\n32      );\n33    } else {\n34      gl.clearColor(0, 0, 0, 0);\n35    }\n36\n37    gl.canvas.style.position = 'absolute';\n38    gl.canvas.style.top = '0';\n39    gl.canvas.style.left = '0';\n40    gl.canvas.style.width = '100%';\n41    gl.canvas.style.height = '100%';\n42    container.appendChild(gl.canvas);\n43\n44    const scene = new Transform();\n45    const lines = [];\n46\n47    const vertex = `\n48      precision highp float;\n49      \n50      attribute vec3 position;\n51      attribute vec3 next;\n52      attribute vec3 prev;\n53      attribute vec2 uv;\n54      attribute float side;\n55      \n56      uniform vec2 uResolution;\n57      uniform float uDPR;\n58      uniform float uThickness;\n59      uniform float uTime;\n60      uniform float uEnableShaderEffect;\n61      uniform float uEffectAmplitude;\n62      \n63      varying vec2 vUV;\n64      \n65      vec4 getPosition() {\n66          vec4 current = vec4(position, 1.0);\n67          vec2 aspect = vec2(uResolution.x / uResolution.y, 1.0);\n68          vec2 nextScreen = next.xy * aspect;\n69          vec2 prevScreen = prev.xy * aspect;\n70          vec2 tangent = normalize(nextScreen - prevScreen);\n71          vec2 normal = vec2(-tangent.y, tangent.x);\n72          normal /= aspect;\n73          normal *= mix(1.0, 0.1, pow(abs(uv.y - 0.5) * 2.0, 2.0));\n74          float dist = length(nextScreen - prevScreen);\n75          normal *= smoothstep(0.0, 0.02, dist);\n76          float pixelWidthRatio = 1.0 / (uResolution.y / uDPR);\n77          float pixelWidth = current.w * pixelWidthRatio;\n78          normal *= pixelWidth * uThickness;\n79          current.xy -= normal * side;\n80          if(uEnableShaderEffect > 0.5) {\n81            current.xy += normal * sin(uTime + current.x * 10.0) * uEffectAmplitude;\n82          }\n83          return current;\n84      }\n85      \n86      void main() {\n87          // Pass the original uv to the fragment shader.\n88          vUV = uv;\n89          gl_Position = getPosition();\n90      }\n91    `;\n92\n93    const fragment = `\n94      precision highp float;\n95      uniform vec3 uColor;\n96      uniform float uOpacity;\n97      uniform float uEnableFade;\n98      varying vec2 vUV;\n99      void main() {\n100          float fadeFactor = 1.0;\n101          if(uEnableFade > 0.5) {\n102              fadeFactor = 1.0 - smoothstep(0.0, 1.0, vUV.y);\n103          }\n104          gl_FragColor = vec4(uColor, uOpacity * fadeFactor);\n105      }\n106    `;\n107\n108    function resize() {\n109      const width = container.clientWidth;\n110      const height = container.clientHeight;\n111      renderer.setSize(width, height);\n112      lines.forEach(line => line.polyline.resize());\n113    }\n114    window.addEventListener('resize', resize);\n115\n116    const center = (colors.length - 1) / 2;\n117    colors.forEach((color, index) => {\n118      const spring = baseSpring + (Math.random() - 0.5) * 0.05;\n119      const friction = baseFriction + (Math.random() - 0.5) * 0.05;\n120      const thickness = baseThickness + (Math.random() - 0.5) * 3;\n121      const mouseOffset = new Vec3(\n122        (index - center) * offsetFactor + (Math.random() - 0.5) * 0.01,\n123        (Math.random() - 0.5) * 0.1,\n124        0\n125      );\n126\n127      const line = {\n128        spring,\n129        friction,\n130        mouseVelocity: new Vec3(),\n131        mouseOffset,\n132      };\n133\n134      const count = pointCount;\n135      const points = [];\n136      for (let i = 0; i < count; i++) {\n137        points.push(new Vec3());\n138      }\n139      line.points = points;\n140\n141      line.polyline = new Polyline(gl, {\n142        points,\n143        vertex,\n144        fragment,\n145        uniforms: {\n146          uColor: { value: new Color(color) },\n147          uThickness: { value: thickness },\n148          uOpacity: { value: 1.0 },\n149          uTime: { value: 0.0 },\n150          uEnableShaderEffect: { value: enableShaderEffect ? 1.0 : 0.0 },\n151          uEffectAmplitude: { value: effectAmplitude },\n152          uEnableFade: { value: enableFade ? 1.0 : 0.0 },\n153        },\n154      });\n155      line.polyline.mesh.setParent(scene);\n156      lines.push(line);\n157    });\n158\n159    resize();\n160\n161    const mouse = new Vec3();\n162    function updateMouse(e) {\n163      let x, y;\n164      const rect = container.getBoundingClientRect();\n165      if (e.changedTouches && e.changedTouches.length) {\n166        x = e.changedTouches[0].clientX - rect.left;\n167        y = e.changedTouches[0].clientY - rect.top;\n168      } else {\n169        x = e.clientX - rect.left;\n170        y = e.clientY - rect.top;\n171      }\n172      const width = container.clientWidth;\n173      const height = container.clientHeight;\n174      mouse.set((x / width) * 2 - 1, (y / height) * -2 + 1, 0);\n175    }\n176    container.addEventListener('mousemove', updateMouse);\n177    container.addEventListener('touchstart', updateMouse);\n178    container.addEventListener('touchmove', updateMouse);\n179\n180    const tmp = new Vec3();\n181    let frameId;\n182    let lastTime = performance.now();\n183    function update() {\n184      frameId = requestAnimationFrame(update);\n185      const currentTime = performance.now();\n186      const dt = currentTime - lastTime;\n187      lastTime = currentTime;\n188\n189      lines.forEach(line => {\n190        tmp.copy(mouse)\n191          .add(line.mouseOffset)\n192          .sub(line.points[0])\n193          .multiply(line.spring);\n194        line.mouseVelocity.add(tmp).multiply(line.friction);\n195        line.points[0].add(line.mouseVelocity);\n196\n197        for (let i = 1; i < line.points.length; i++) {\n198          if (isFinite(maxAge) && maxAge > 0) {\n199            const segmentDelay = maxAge / (line.points.length - 1);\n200            const alpha = Math.min(1, (dt * speedMultiplier) / segmentDelay);\n201            line.points[i].lerp(line.points[i - 1], alpha);\n202          } else {\n203            line.points[i].lerp(line.points[i - 1], 0.9);\n204          }\n205        }\n206        if (line.polyline.mesh.program.uniforms.uTime) {\n207          line.polyline.mesh.program.uniforms.uTime.value = currentTime * 0.001;\n208        }\n209        line.polyline.updateGeometry();\n210      });\n211\n212      renderer.render({ scene });\n213    }\n214    update();\n215\n216    return () => {\n217      window.removeEventListener('resize', resize);\n218      container.removeEventListener('mousemove', updateMouse);\n219      container.removeEventListener('touchstart', updateMouse);\n220      container.removeEventListener('touchmove', updateMouse);\n221      cancelAnimationFrame(frameId);\n222      if (gl.canvas && gl.canvas.parentNode === container) {\n223        container.removeChild(gl.canvas);\n224      }\n225    };\n226  }, [\n227    colors,\n228    baseSpring,\n229    baseFriction,\n230    baseThickness,\n231    offsetFactor,\n232    maxAge,\n233    pointCount,\n234    speedMultiplier,\n235    enableFade,\n236    enableShaderEffect,\n237    effectAmplitude,\n238    backgroundColor\n239  ]);\n240\n241  return (\n242    <div\n243      ref={containerRef}\n244      className='relative w-full h-full'\n245    />\n246  );\n247};\n248\n249export default Ribbons;\n250"
}