{
  "name": "Dither",
  "description": "An open source collection of high quality, animated, interactive & fully customizable React components for building stunning, memorable user interfaces.",
  "props": {},
  "dependencies": [],
  "previewImage": "",
  "url": "https://www.reactbits.dev/backgrounds/dither",
  "code": "1npm i three postprocessing @react-three/fiber @react-three/postprocessing\n\n1import Dither from './Dither';\n2\n3<div style={{ width: '100%', height: '600px', position: 'relative' }}>\n4  <Dither\n5    waveColor={[0.5, 0.5, 0.5]}\n6    disableAnimation={false}\n7    enableMouseInteraction={true}\n8    mouseRadius={0.3}\n9    colorNum={4}\n10    waveAmplitude={0.3}\n11    waveFrequency={3}\n12    waveSpeed={0.05}\n13  />\n14</div>\n\n1/* eslint-disable react/no-unknown-property */\n2import { useRef, useState, useEffect } from \"react\";\n3import { Canvas, useFrame, useThree } from \"@react-three/fiber\";\n4import { EffectComposer, wrapEffect } from \"@react-three/postprocessing\";\n5import { Effect } from \"postprocessing\";\n6import * as THREE from \"three\";\n7\n8import './Dither.css';\n9\n10const waveVertexShader = `\n11precision highp float;\n12varying vec2 vUv;\n13void main() {\n14  vUv = uv;\n15  vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n16  vec4 viewPosition = viewMatrix * modelPosition;\n17  gl_Position = projectionMatrix * viewPosition;\n18}\n19`;\n20\n21const waveFragmentShader = `\n22precision highp float;\n23uniform vec2 resolution;\n24uniform float time;\n25uniform float waveSpeed;\n26uniform float waveFrequency;\n27uniform float waveAmplitude;\n28uniform vec3 waveColor;\n29uniform vec2 mousePos;\n30uniform int enableMouseInteraction;\n31uniform float mouseRadius;\n32\n33vec4 mod289(vec4 x) { return x - floor(x * (1.0/289.0)) * 289.0; }\n34vec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\n35vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n36vec2 fade(vec2 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\n37\n38float cnoise(vec2 P) {\n39  vec4 Pi = floor(P.xyxy) + vec4(0.0,0.0,1.0,1.0);\n40  vec4 Pf = fract(P.xyxy) - vec4(0.0,0.0,1.0,1.0);\n41  Pi = mod289(Pi);\n42  vec4 ix = Pi.xzxz;\n43  vec4 iy = Pi.yyww;\n44  vec4 fx = Pf.xzxz;\n45  vec4 fy = Pf.yyww;\n46  vec4 i = permute(permute(ix) + iy);\n47  vec4 gx = fract(i * (1.0/41.0)) * 2.0 - 1.0;\n48  vec4 gy = abs(gx) - 0.5;\n49  vec4 tx = floor(gx + 0.5);\n50  gx = gx - tx;\n51  vec2 g00 = vec2(gx.x, gy.x);\n52  vec2 g10 = vec2(gx.y, gy.y);\n53  vec2 g01 = vec2(gx.z, gy.z);\n54  vec2 g11 = vec2(gx.w, gy.w);\n55  vec4 norm = taylorInvSqrt(vec4(dot(g00,g00), dot(g01,g01), dot(g10,g10), dot(g11,g11)));\n56  g00 *= norm.x; g01 *= norm.y; g10 *= norm.z; g11 *= norm.w;\n57  float n00 = dot(g00, vec2(fx.x, fy.x));\n58  float n10 = dot(g10, vec2(fx.y, fy.y));\n59  float n01 = dot(g01, vec2(fx.z, fy.z));\n60  float n11 = dot(g11, vec2(fx.w, fy.w));\n61  vec2 fade_xy = fade(Pf.xy);\n62  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n63  return 2.3 * mix(n_x.x, n_x.y, fade_xy.y);\n64}\n65\n66const int OCTAVES = 8;\n67float fbm(vec2 p) {\n68  float value = 0.0;\n69  float amp = 1.0;\n70  float freq = waveFrequency;\n71  for (int i = 0; i < OCTAVES; i++) {\n72    value += amp * abs(cnoise(p));\n73    p *= freq;\n74    amp *= waveAmplitude;\n75  }\n76  return value;\n77}\n78\n79float pattern(vec2 p) {\n80  vec2 p2 = p - time * waveSpeed;\n81  return fbm(p - fbm(p + fbm(p2)));\n82}\n83\n84void main() {\n85  vec2 uv = gl_FragCoord.xy / resolution.xy;\n86  uv -= 0.5;\n87  uv.x *= resolution.x / resolution.y;\n88  float f = pattern(uv);\n89  if (enableMouseInteraction == 1) {\n90    vec2 mouseNDC = (mousePos / resolution - 0.5) * vec2(1.0, -1.0);\n91    mouseNDC.x *= resolution.x / resolution.y;\n92    float dist = length(uv - mouseNDC);\n93    float effect = 1.0 - smoothstep(0.0, mouseRadius, dist);\n94    f -= 0.5 * effect;\n95  }\n96  vec3 col = mix(vec3(0.0), waveColor, f);\n97  gl_FragColor = vec4(col, 1.0);\n98}\n99`;\n100\n101const ditherFragmentShader = `\n102precision highp float;\n103uniform float colorNum;\n104uniform float pixelSize;\n105const float bayerMatrix8x8[64] = float[64](\n106  0.0/64.0, 48.0/64.0, 12.0/64.0, 60.0/64.0,  3.0/64.0, 51.0/64.0, 15.0/64.0, 63.0/64.0,\n107  32.0/64.0,16.0/64.0, 44.0/64.0, 28.0/64.0, 35.0/64.0,19.0/64.0, 47.0/64.0, 31.0/64.0,\n108  8.0/64.0, 56.0/64.0,  4.0/64.0, 52.0/64.0, 11.0/64.0,59.0/64.0,  7.0/64.0, 55.0/64.0,\n109  40.0/64.0,24.0/64.0, 36.0/64.0, 20.0/64.0, 43.0/64.0,27.0/64.0, 39.0/64.0, 23.0/64.0,\n110  2.0/64.0, 50.0/64.0, 14.0/64.0, 62.0/64.0,  1.0/64.0,49.0/64.0, 13.0/64.0, 61.0/64.0,\n111  34.0/64.0,18.0/64.0, 46.0/64.0, 30.0/64.0, 33.0/64.0,17.0/64.0, 45.0/64.0, 29.0/64.0,\n112  10.0/64.0,58.0/64.0,  6.0/64.0, 54.0/64.0,  9.0/64.0,57.0/64.0,  5.0/64.0, 53.0/64.0,\n113  42.0/64.0,26.0/64.0, 38.0/64.0, 22.0/64.0, 41.0/64.0,25.0/64.0, 37.0/64.0, 21.0/64.0\n114);\n115\n116vec3 dither(vec2 uv, vec3 color) {\n117  vec2 scaledCoord = floor(uv * resolution / pixelSize);\n118  int x = int(mod(scaledCoord.x, 8.0));\n119  int y = int(mod(scaledCoord.y, 8.0));\n120  float threshold = bayerMatrix8x8[y * 8 + x] - 0.25;\n121  float step = 1.0 / (colorNum - 1.0);\n122  color += threshold * step;\n123  float bias = 0.2;\n124  color = clamp(color - bias, 0.0, 1.0);\n125  return floor(color * (colorNum - 1.0) + 0.5) / (colorNum - 1.0);\n126}\n127\n128void mainImage(in vec4 inputColor, in vec2 uv, out vec4 outputColor) {\n129  vec2 normalizedPixelSize = pixelSize / resolution;\n130  vec2 uvPixel = normalizedPixelSize * floor(uv / normalizedPixelSize);\n131  vec4 color = texture2D(inputBuffer, uvPixel);\n132  color.rgb = dither(uv, color.rgb);\n133  outputColor = color;\n134}\n135`;\n136\n137class RetroEffectImpl extends Effect {\n138  constructor() {\n139    const uniforms = new Map([\n140      [\"colorNum\", new THREE.Uniform(4.0)],\n141      [\"pixelSize\", new THREE.Uniform(2.0)]\n142    ]);\n143    super(\"RetroEffect\", ditherFragmentShader, { uniforms });\n144    this.uniforms = uniforms;\n145  }\n146  set colorNum(value) {\n147    this.uniforms.get(\"colorNum\").value = value;\n148  }\n149  get colorNum() {\n150    return this.uniforms.get(\"colorNum\").value;\n151  }\n152  set pixelSize(value) {\n153    this.uniforms.get(\"pixelSize\").value = value;\n154  }\n155  get pixelSize() {\n156    return this.uniforms.get(\"pixelSize\").value;\n157  }\n158}\n159\n160const RetroEffect = wrapEffect(RetroEffectImpl);\n161\n162function DitheredWaves({\n163  waveSpeed,\n164  waveFrequency,\n165  waveAmplitude,\n166  waveColor,\n167  colorNum,\n168  pixelSize,\n169  disableAnimation,\n170  enableMouseInteraction,\n171  mouseRadius\n172}) {\n173  const mesh = useRef(null);\n174  const effect = useRef(null);\n175  const [mousePos, setMousePos] = useState({ x: 0, y: 0 });\n176  const { viewport, size, gl } = useThree();\n177\n178  const waveUniformsRef = useRef({\n179    time: { value: 0 },\n180    resolution: { value: new THREE.Vector2(0, 0) },\n181    waveSpeed: { value: waveSpeed },\n182    waveFrequency: { value: waveFrequency },\n183    waveAmplitude: { value: waveAmplitude },\n184    waveColor: { value: new THREE.Color(...waveColor) },\n185    mousePos: { value: new THREE.Vector2(0, 0) },\n186    enableMouseInteraction: { value: enableMouseInteraction ? 1 : 0 },\n187    mouseRadius: { value: mouseRadius }\n188  });\n189\n190  useEffect(() => {\n191    const dpr = gl.getPixelRatio();\n192    const newWidth = Math.floor(size.width * dpr);\n193    const newHeight = Math.floor(size.height * dpr);\n194    const currentRes = waveUniformsRef.current.resolution.value;\n195    if (currentRes.x !== newWidth || currentRes.y !== newHeight) {\n196      currentRes.set(newWidth, newHeight);\n197      if (\n198        effect.current &&\n199        effect.current.uniforms &&\n200        effect.current.uniforms.resolution &&\n201        effect.current.uniforms.resolution.value\n202      ) {\n203        effect.current.uniforms.resolution.value.set(newWidth, newHeight);\n204      }\n205    }\n206  }, [size, gl]);\n207\n208  useFrame(({ clock }) => {\n209    if (!disableAnimation) {\n210      waveUniformsRef.current.time.value = clock.getElapsedTime();\n211    }\n212    waveUniformsRef.current.waveSpeed.value = waveSpeed;\n213    waveUniformsRef.current.waveFrequency.value = waveFrequency;\n214    waveUniformsRef.current.waveAmplitude.value = waveAmplitude;\n215    waveUniformsRef.current.waveColor.value.set(...waveColor);\n216    waveUniformsRef.current.enableMouseInteraction.value = enableMouseInteraction ? 1 : 0;\n217    waveUniformsRef.current.mouseRadius.value = mouseRadius;\n218    if (enableMouseInteraction) {\n219      waveUniformsRef.current.mousePos.value.set(mousePos.x, mousePos.y);\n220    }\n221    if (effect.current) {\n222      effect.current.colorNum = colorNum;\n223      effect.current.pixelSize = pixelSize;\n224    }\n225  });\n226\n227  const handlePointerMove = (e) => {\n228    if (!enableMouseInteraction) return;\n229    const rect = gl.domElement.getBoundingClientRect();\n230    const dpr = gl.getPixelRatio();\n231    const x = (e.clientX - rect.left) * dpr;\n232    const y = (e.clientY - rect.top) * dpr;\n233    setMousePos({ x, y });\n234  };\n235\n236  return (\n237    <>\n238      <mesh ref={mesh} scale={[viewport.width, viewport.height, 1]}>\n239        <planeGeometry args={[1, 1]} />\n240        <shaderMaterial\n241          vertexShader={waveVertexShader}\n242          fragmentShader={waveFragmentShader}\n243          uniforms={waveUniformsRef.current}\n244        />\n245      </mesh>\n246      <EffectComposer>\n247        <RetroEffect ref={effect} />\n248      </EffectComposer>\n249      <mesh\n250        onPointerMove={handlePointerMove}\n251        position={[0, 0, 0.01]}\n252        scale={[viewport.width, viewport.height, 1]}\n253        visible={false}\n254      >\n255        <planeGeometry args={[1, 1]} />\n256        <meshBasicMaterial transparent opacity={0} />\n257      </mesh>\n258    </>\n259  );\n260}\n261\n262export default function Dither({\n263  waveSpeed = 0.05,\n264  waveFrequency = 3,\n265  waveAmplitude = 0.3,\n266  waveColor = [0.5, 0.5, 0.5],\n267  colorNum = 4,\n268  pixelSize = 2,\n269  disableAnimation = false,\n270  enableMouseInteraction = true,\n271  mouseRadius = 1\n272}) {\n273  return (\n274    <Canvas\n275      className=\"dither-container\"\n276      camera={{ position: [0, 0, 6] }}\n277      dpr={window.devicePixelRatio}\n278      gl={{ antialias: true, preserveDrawingBuffer: true }}\n279    >\n280      <DitheredWaves\n281        waveSpeed={waveSpeed}\n282        waveFrequency={waveFrequency}\n283        waveAmplitude={waveAmplitude}\n284        waveColor={waveColor}\n285        colorNum={colorNum}\n286        pixelSize={pixelSize}\n287        disableAnimation={disableAnimation}\n288        enableMouseInteraction={enableMouseInteraction}\n289        mouseRadius={mouseRadius}\n290      />\n291    </Canvas>\n292  );\n293}\n294\n\n1.dither-container {\n2  width: 100%;\n3  height: 100%;\n4  position: relative;\n5}\n\n1/* eslint-disable react/no-unknown-property */\n2import { useRef, useState, useEffect } from \"react\";\n3import { Canvas, useFrame, useThree } from \"@react-three/fiber\";\n4import { EffectComposer, wrapEffect } from \"@react-three/postprocessing\";\n5import { Effect } from \"postprocessing\";\n6import * as THREE from \"three\";\n7\n8const waveVertexShader = `\n9precision highp float;\n10varying vec2 vUv;\n11void main() {\n12  vUv = uv;\n13  vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n14  vec4 viewPosition = viewMatrix * modelPosition;\n15  gl_Position = projectionMatrix * viewPosition;\n16}\n17`;\n18\n19const waveFragmentShader = `\n20precision highp float;\n21uniform vec2 resolution;\n22uniform float time;\n23uniform float waveSpeed;\n24uniform float waveFrequency;\n25uniform float waveAmplitude;\n26uniform vec3 waveColor;\n27uniform vec2 mousePos;\n28uniform int enableMouseInteraction;\n29uniform float mouseRadius;\n30\n31vec4 mod289(vec4 x) { return x - floor(x * (1.0/289.0)) * 289.0; }\n32vec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\n33vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n34vec2 fade(vec2 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\n35\n36float cnoise(vec2 P) {\n37  vec4 Pi = floor(P.xyxy) + vec4(0.0,0.0,1.0,1.0);\n38  vec4 Pf = fract(P.xyxy) - vec4(0.0,0.0,1.0,1.0);\n39  Pi = mod289(Pi);\n40  vec4 ix = Pi.xzxz;\n41  vec4 iy = Pi.yyww;\n42  vec4 fx = Pf.xzxz;\n43  vec4 fy = Pf.yyww;\n44  vec4 i = permute(permute(ix) + iy);\n45  vec4 gx = fract(i * (1.0/41.0)) * 2.0 - 1.0;\n46  vec4 gy = abs(gx) - 0.5;\n47  vec4 tx = floor(gx + 0.5);\n48  gx = gx - tx;\n49  vec2 g00 = vec2(gx.x, gy.x);\n50  vec2 g10 = vec2(gx.y, gy.y);\n51  vec2 g01 = vec2(gx.z, gy.z);\n52  vec2 g11 = vec2(gx.w, gy.w);\n53  vec4 norm = taylorInvSqrt(vec4(dot(g00,g00), dot(g01,g01), dot(g10,g10), dot(g11,g11)));\n54  g00 *= norm.x; g01 *= norm.y; g10 *= norm.z; g11 *= norm.w;\n55  float n00 = dot(g00, vec2(fx.x, fy.x));\n56  float n10 = dot(g10, vec2(fx.y, fy.y));\n57  float n01 = dot(g01, vec2(fx.z, fy.z));\n58  float n11 = dot(g11, vec2(fx.w, fy.w));\n59  vec2 fade_xy = fade(Pf.xy);\n60  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n61  return 2.3 * mix(n_x.x, n_x.y, fade_xy.y);\n62}\n63\n64const int OCTAVES = 8;\n65float fbm(vec2 p) {\n66  float value = 0.0;\n67  float amp = 1.0;\n68  float freq = waveFrequency;\n69  for (int i = 0; i < OCTAVES; i++) {\n70    value += amp * abs(cnoise(p));\n71    p *= freq;\n72    amp *= waveAmplitude;\n73  }\n74  return value;\n75}\n76\n77float pattern(vec2 p) {\n78  vec2 p2 = p - time * waveSpeed;\n79  return fbm(p - fbm(p + fbm(p2)));\n80}\n81\n82void main() {\n83  vec2 uv = gl_FragCoord.xy / resolution.xy;\n84  uv -= 0.5;\n85  uv.x *= resolution.x / resolution.y;\n86  float f = pattern(uv);\n87  if (enableMouseInteraction == 1) {\n88    vec2 mouseNDC = (mousePos / resolution - 0.5) * vec2(1.0, -1.0);\n89    mouseNDC.x *= resolution.x / resolution.y;\n90    float dist = length(uv - mouseNDC);\n91    float effect = 1.0 - smoothstep(0.0, mouseRadius, dist);\n92    f -= 0.5 * effect;\n93  }\n94  vec3 col = mix(vec3(0.0), waveColor, f);\n95  gl_FragColor = vec4(col, 1.0);\n96}\n97`;\n98\n99const ditherFragmentShader = `\n100precision highp float;\n101uniform float colorNum;\n102uniform float pixelSize;\n103const float bayerMatrix8x8[64] = float[64](\n104  0.0/64.0, 48.0/64.0, 12.0/64.0, 60.0/64.0,  3.0/64.0, 51.0/64.0, 15.0/64.0, 63.0/64.0,\n105  32.0/64.0,16.0/64.0, 44.0/64.0, 28.0/64.0, 35.0/64.0,19.0/64.0, 47.0/64.0, 31.0/64.0,\n106  8.0/64.0, 56.0/64.0,  4.0/64.0, 52.0/64.0, 11.0/64.0,59.0/64.0,  7.0/64.0, 55.0/64.0,\n107  40.0/64.0,24.0/64.0, 36.0/64.0, 20.0/64.0, 43.0/64.0,27.0/64.0, 39.0/64.0, 23.0/64.0,\n108  2.0/64.0, 50.0/64.0, 14.0/64.0, 62.0/64.0,  1.0/64.0,49.0/64.0, 13.0/64.0, 61.0/64.0,\n109  34.0/64.0,18.0/64.0, 46.0/64.0, 30.0/64.0, 33.0/64.0,17.0/64.0, 45.0/64.0, 29.0/64.0,\n110  10.0/64.0,58.0/64.0,  6.0/64.0, 54.0/64.0,  9.0/64.0,57.0/64.0,  5.0/64.0, 53.0/64.0,\n111  42.0/64.0,26.0/64.0, 38.0/64.0, 22.0/64.0, 41.0/64.0,25.0/64.0, 37.0/64.0, 21.0/64.0\n112);\n113\n114vec3 dither(vec2 uv, vec3 color) {\n115  vec2 scaledCoord = floor(uv * resolution / pixelSize);\n116  int x = int(mod(scaledCoord.x, 8.0));\n117  int y = int(mod(scaledCoord.y, 8.0));\n118  float threshold = bayerMatrix8x8[y * 8 + x] - 0.25;\n119  float step = 1.0 / (colorNum - 1.0);\n120  color += threshold * step;\n121  float bias = 0.2;\n122  color = clamp(color - bias, 0.0, 1.0);\n123  return floor(color * (colorNum - 1.0) + 0.5) / (colorNum - 1.0);\n124}\n125\n126void mainImage(in vec4 inputColor, in vec2 uv, out vec4 outputColor) {\n127  vec2 normalizedPixelSize = pixelSize / resolution;\n128  vec2 uvPixel = normalizedPixelSize * floor(uv / normalizedPixelSize);\n129  vec4 color = texture2D(inputBuffer, uvPixel);\n130  color.rgb = dither(uv, color.rgb);\n131  outputColor = color;\n132}\n133`;\n134\n135class RetroEffectImpl extends Effect {\n136  constructor() {\n137    const uniforms = new Map([\n138      [\"colorNum\", new THREE.Uniform(4.0)],\n139      [\"pixelSize\", new THREE.Uniform(2.0)]\n140    ]);\n141    super(\"RetroEffect\", ditherFragmentShader, { uniforms });\n142    this.uniforms = uniforms;\n143  }\n144  set colorNum(value) {\n145    this.uniforms.get(\"colorNum\").value = value;\n146  }\n147  get colorNum() {\n148    return this.uniforms.get(\"colorNum\").value;\n149  }\n150  set pixelSize(value) {\n151    this.uniforms.get(\"pixelSize\").value = value;\n152  }\n153  get pixelSize() {\n154    return this.uniforms.get(\"pixelSize\").value;\n155  }\n156}\n157\n158const RetroEffect = wrapEffect(RetroEffectImpl);\n159\n160function DitheredWaves({\n161  waveSpeed,\n162  waveFrequency,\n163  waveAmplitude,\n164  waveColor,\n165  colorNum,\n166  pixelSize,\n167  disableAnimation,\n168  enableMouseInteraction,\n169  mouseRadius\n170}) {\n171  const mesh = useRef(null);\n172  const effect = useRef(null);\n173  const [mousePos, setMousePos] = useState({ x: 0, y: 0 });\n174  const { viewport, size, gl } = useThree();\n175\n176  const waveUniformsRef = useRef({\n177    time: { value: 0 },\n178    resolution: { value: new THREE.Vector2(0, 0) },\n179    waveSpeed: { value: waveSpeed },\n180    waveFrequency: { value: waveFrequency },\n181    waveAmplitude: { value: waveAmplitude },\n182    waveColor: { value: new THREE.Color(...waveColor) },\n183    mousePos: { value: new THREE.Vector2(0, 0) },\n184    enableMouseInteraction: { value: enableMouseInteraction ? 1 : 0 },\n185    mouseRadius: { value: mouseRadius }\n186  });\n187\n188  useEffect(() => {\n189    const dpr = gl.getPixelRatio();\n190    const newWidth = Math.floor(size.width * dpr);\n191    const newHeight = Math.floor(size.height * dpr);\n192    const currentRes = waveUniformsRef.current.resolution.value;\n193    if (currentRes.x !== newWidth || currentRes.y !== newHeight) {\n194      currentRes.set(newWidth, newHeight);\n195      if (\n196        effect.current &&\n197        effect.current.uniforms &&\n198        effect.current.uniforms.resolution &&\n199        effect.current.uniforms.resolution.value\n200      ) {\n201        effect.current.uniforms.resolution.value.set(newWidth, newHeight);\n202      }\n203    }\n204  }, [size, gl]);\n205\n206  useFrame(({ clock }) => {\n207    if (!disableAnimation) {\n208      waveUniformsRef.current.time.value = clock.getElapsedTime();\n209    }\n210    waveUniformsRef.current.waveSpeed.value = waveSpeed;\n211    waveUniformsRef.current.waveFrequency.value = waveFrequency;\n212    waveUniformsRef.current.waveAmplitude.value = waveAmplitude;\n213    waveUniformsRef.current.waveColor.value.set(...waveColor);\n214    waveUniformsRef.current.enableMouseInteraction.value = enableMouseInteraction ? 1 : 0;\n215    waveUniformsRef.current.mouseRadius.value = mouseRadius;\n216    if (enableMouseInteraction) {\n217      waveUniformsRef.current.mousePos.value.set(mousePos.x, mousePos.y);\n218    }\n219    if (effect.current) {\n220      effect.current.colorNum = colorNum;\n221      effect.current.pixelSize = pixelSize;\n222    }\n223  });\n224\n225  const handlePointerMove = (e) => {\n226    if (!enableMouseInteraction) return;\n227    const rect = gl.domElement.getBoundingClientRect();\n228    const dpr = gl.getPixelRatio();\n229    const x = (e.clientX - rect.left) * dpr;\n230    const y = (e.clientY - rect.top) * dpr;\n231    setMousePos({ x, y });\n232  };\n233\n234  return (\n235    <>\n236      <mesh ref={mesh} scale={[viewport.width, viewport.height, 1]}>\n237        <planeGeometry args={[1, 1]} />\n238        <shaderMaterial\n239          vertexShader={waveVertexShader}\n240          fragmentShader={waveFragmentShader}\n241          uniforms={waveUniformsRef.current}\n242        />\n243      </mesh>\n244      <EffectComposer>\n245        <RetroEffect ref={effect} />\n246      </EffectComposer>\n247      <mesh\n248        onPointerMove={handlePointerMove}\n249        position={[0, 0, 0.01]}\n250        scale={[viewport.width, viewport.height, 1]}\n251        visible={false}\n252      >\n253        <planeGeometry args={[1, 1]} />\n254        <meshBasicMaterial transparent opacity={0} />\n255      </mesh>\n256    </>\n257  );\n258}\n259\n260export default function Dither({\n261  waveSpeed = 0.05,\n262  waveFrequency = 3,\n263  waveAmplitude = 0.3,\n264  waveColor = [0.5, 0.5, 0.5],\n265  colorNum = 4,\n266  pixelSize = 2,\n267  disableAnimation = false,\n268  enableMouseInteraction = true,\n269  mouseRadius = 1\n270}) {\n271  return (\n272    <Canvas\n273      className=\"w-full h-full relative\"\n274      camera={{ position: [0, 0, 6] }}\n275      dpr={window.devicePixelRatio}\n276      gl={{ antialias: true, preserveDrawingBuffer: true }}\n277    >\n278      <DitheredWaves\n279        waveSpeed={waveSpeed}\n280        waveFrequency={waveFrequency}\n281        waveAmplitude={waveAmplitude}\n282        waveColor={waveColor}\n283        colorNum={colorNum}\n284        pixelSize={pixelSize}\n285        disableAnimation={disableAnimation}\n286        enableMouseInteraction={enableMouseInteraction}\n287        mouseRadius={mouseRadius}\n288      />\n289    </Canvas>\n290  );\n291}\n292"
}