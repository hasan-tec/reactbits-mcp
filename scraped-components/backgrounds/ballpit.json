{
  "name": "Ballpit",
  "description": "An open source collection of high quality, animated, interactive & fully customizable React components for building stunning, memorable user interfaces.",
  "props": {},
  "dependencies": [],
  "previewImage": "",
  "url": "https://www.reactbits.dev/backgrounds/ballpit",
  "code": "1npm i three\n\n1//Component inspired by Kevin Levron:\n2//https://x.com/soju22/status/1858925191671271801\n3  \n4import Ballpit from './Ballpit;'\n5\n6<div style={{position: 'relative', overflow: 'hidden', minHeight: '500px', maxHeight: '500px', width: '100%'}}>\n7  <Ballpit\n8    count={200}\n9    gravity={0.7}\n10    friction={0.8}\n11    wallBounce={0.95}\n12    followCursor={true}\n13  />\n14</div>\n\n1import { useRef, useEffect } from 'react';\n2import {\n3  Clock as e,\n4  PerspectiveCamera as t,\n5  Scene as i,\n6  WebGLRenderer as s,\n7  SRGBColorSpace as n,\n8  MathUtils as o,\n9  Vector2 as r,\n10  Vector3 as a,\n11  MeshPhysicalMaterial as c,\n12  ShaderChunk as h,\n13  Color as l,\n14  Object3D as m,\n15  InstancedMesh as d,\n16  PMREMGenerator as p,\n17  SphereGeometry as g,\n18  AmbientLight as f,\n19  PointLight as u,\n20  ACESFilmicToneMapping as v,\n21  Raycaster as y,\n22  Plane as w,\n23} from \"three\";\n24import { RoomEnvironment as z } from \"three/examples/jsm/environments/RoomEnvironment.js\";\n25\n26class x {\n27  #e;\n28  canvas;\n29  camera;\n30  cameraMinAspect;\n31  cameraMaxAspect;\n32  cameraFov;\n33  maxPixelRatio;\n34  minPixelRatio;\n35  scene;\n36  renderer;\n37  #t;\n38  size = { width: 0, height: 0, wWidth: 0, wHeight: 0, ratio: 0, pixelRatio: 0 };\n39  render = this.#i;\n40  onBeforeRender = () => { };\n41  onAfterRender = () => { };\n42  onAfterResize = () => { };\n43  #s = false;\n44  #n = false;\n45  isDisposed = false;\n46  #o;\n47  #r;\n48  #a;\n49  #c = new e();\n50  #h = { elapsed: 0, delta: 0 };\n51  #l;\n52  constructor(e) {\n53    this.#e = { ...e };\n54    this.#m();\n55    this.#d();\n56    this.#p();\n57    this.resize();\n58    this.#g();\n59  }\n60  #m() {\n61    this.camera = new t();\n62    this.cameraFov = this.camera.fov;\n63  }\n64  #d() {\n65    this.scene = new i();\n66  }\n67  #p() {\n68    if (this.#e.canvas) {\n69      this.canvas = this.#e.canvas;\n70    } else if (this.#e.id) {\n71      this.canvas = document.getElementById(this.#e.id);\n72    } else {\n73      console.error(\"Three: Missing canvas or id parameter\");\n74    }\n75    this.canvas.style.display = \"block\";\n76    const e = {\n77      canvas: this.canvas,\n78      powerPreference: \"high-performance\",\n79      ...(this.#e.rendererOptions ?? {}),\n80    };\n81    this.renderer = new s(e);\n82    this.renderer.outputColorSpace = n;\n83  }\n84  #g() {\n85    if (!(this.#e.size instanceof Object)) {\n86      window.addEventListener(\"resize\", this.#f.bind(this));\n87      if (this.#e.size === \"parent\" && this.canvas.parentNode) {\n88        this.#r = new ResizeObserver(this.#f.bind(this));\n89        this.#r.observe(this.canvas.parentNode);\n90      }\n91    }\n92    this.#o = new IntersectionObserver(this.#u.bind(this), {\n93      root: null,\n94      rootMargin: \"0px\",\n95      threshold: 0,\n96    });\n97    this.#o.observe(this.canvas);\n98    document.addEventListener(\"visibilitychange\", this.#v.bind(this));\n99  }\n100  #y() {\n101    window.removeEventListener(\"resize\", this.#f.bind(this));\n102    this.#r?.disconnect();\n103    this.#o?.disconnect();\n104    document.removeEventListener(\"visibilitychange\", this.#v.bind(this));\n105  }\n106  #u(e) {\n107    this.#s = e[0].isIntersecting;\n108    this.#s ? this.#w() : this.#z();\n109  }\n110  #v() {\n111    if (this.#s) {\n112      document.hidden ? this.#z() : this.#w();\n113    }\n114  }\n115  #f() {\n116    if (this.#a) clearTimeout(this.#a);\n117    this.#a = setTimeout(this.resize.bind(this), 100);\n118  }\n119  resize() {\n120    let e, t;\n121    if (this.#e.size instanceof Object) {\n122      e = this.#e.size.width;\n123      t = this.#e.size.height;\n124    } else if (this.#e.size === \"parent\" && this.canvas.parentNode) {\n125      e = this.canvas.parentNode.offsetWidth;\n126      t = this.canvas.parentNode.offsetHeight;\n127    } else {\n128      e = window.innerWidth;\n129      t = window.innerHeight;\n130    }\n131    this.size.width = e;\n132    this.size.height = t;\n133    this.size.ratio = e / t;\n134    this.#x();\n135    this.#b();\n136    this.onAfterResize(this.size);\n137  }\n138  #x() {\n139    this.camera.aspect = this.size.width / this.size.height;\n140    if (this.camera.isPerspectiveCamera && this.cameraFov) {\n141      if (this.cameraMinAspect && this.camera.aspect < this.cameraMinAspect) {\n142        this.#A(this.cameraMinAspect);\n143      } else if (this.cameraMaxAspect && this.camera.aspect > this.cameraMaxAspect) {\n144        this.#A(this.cameraMaxAspect);\n145      } else {\n146        this.camera.fov = this.cameraFov;\n147      }\n148    }\n149    this.camera.updateProjectionMatrix();\n150    this.updateWorldSize();\n151  }\n152  #A(e) {\n153    const t = Math.tan(o.degToRad(this.cameraFov / 2)) / (this.camera.aspect / e);\n154    this.camera.fov = 2 * o.radToDeg(Math.atan(t));\n155  }\n156  updateWorldSize() {\n157    if (this.camera.isPerspectiveCamera) {\n158      const e = (this.camera.fov * Math.PI) / 180;\n159      this.size.wHeight =\n160        2 * Math.tan(e / 2) * this.camera.position.length();\n161      this.size.wWidth = this.size.wHeight * this.camera.aspect;\n162    } else if (this.camera.isOrthographicCamera) {\n163      this.size.wHeight = this.camera.top - this.camera.bottom;\n164      this.size.wWidth = this.camera.right - this.camera.left;\n165    }\n166  }\n167  #b() {\n168    this.renderer.setSize(this.size.width, this.size.height);\n169    this.#t?.setSize(this.size.width, this.size.height);\n170    let e = window.devicePixelRatio;\n171    if (this.maxPixelRatio && e > this.maxPixelRatio) {\n172      e = this.maxPixelRatio;\n173    } else if (this.minPixelRatio && e < this.minPixelRatio) {\n174      e = this.minPixelRatio;\n175    }\n176    this.renderer.setPixelRatio(e);\n177    this.size.pixelRatio = e;\n178  }\n179  get postprocessing() {\n180    return this.#t;\n181  }\n182  set postprocessing(e) {\n183    this.#t = e;\n184    this.render = e.render.bind(e);\n185  }\n186  #w() {\n187    if (this.#n) return;\n188    const animate = () => {\n189      this.#l = requestAnimationFrame(animate);\n190      this.#h.delta = this.#c.getDelta();\n191      this.#h.elapsed += this.#h.delta;\n192      this.onBeforeRender(this.#h);\n193      this.render();\n194      this.onAfterRender(this.#h);\n195    };\n196    this.#n = true;\n197    this.#c.start();\n198    animate();\n199  }\n200  #z() {\n201    if (this.#n) {\n202      cancelAnimationFrame(this.#l);\n203      this.#n = false;\n204      this.#c.stop();\n205    }\n206  }\n207  #i() {\n208    this.renderer.render(this.scene, this.camera);\n209  }\n210  clear() {\n211    this.scene.traverse((e) => {\n212      if (\n213        e.isMesh &&\n214        typeof e.material === \"object\" &&\n215        e.material !== null\n216      ) {\n217        Object.keys(e.material).forEach((t) => {\n218          const i = e.material[t];\n219          if (i !== null && typeof i === \"object\" && typeof i.dispose === \"function\") {\n220            i.dispose();\n221          }\n222        });\n223        e.material.dispose();\n224        e.geometry.dispose();\n225      }\n226    });\n227    this.scene.clear();\n228  }\n229  dispose() {\n230    this.#y();\n231    this.#z();\n232    this.clear();\n233    this.#t?.dispose();\n234    this.renderer.dispose();\n235    this.isDisposed = true;\n236  }\n237}\n238\n239const b = new Map(),\n240  A = new r();\n241let R = false;\n242function S(e) {\n243  const t = {\n244    position: new r(),\n245    nPosition: new r(),\n246    hover: false,\n247    onEnter() { },\n248    onMove() { },\n249    onClick() { },\n250    onLeave() { },\n251    ...e,\n252  };\n253  (function (e, t) {\n254    if (!b.has(e)) {\n255      b.set(e, t);\n256      if (!R) {\n257        document.body.addEventListener(\"pointermove\", M);\n258        document.body.addEventListener(\"pointerleave\", L);\n259        document.body.addEventListener(\"click\", C);\n260        R = true;\n261      }\n262    }\n263  })(e.domElement, t);\n264  t.dispose = () => {\n265    const t = e.domElement;\n266    b.delete(t);\n267    if (b.size === 0) {\n268      document.body.removeEventListener(\"pointermove\", M);\n269      document.body.removeEventListener(\"pointerleave\", L);\n270      R = false;\n271    }\n272  };\n273  return t;\n274}\n275function M(e) {\n276  A.x = e.clientX;\n277  A.y = e.clientY;\n278  for (const [elem, t] of b) {\n279    const i = elem.getBoundingClientRect();\n280    if (D(i)) {\n281      P(t, i);\n282      if (!t.hover) {\n283        t.hover = true;\n284        t.onEnter(t);\n285      }\n286      t.onMove(t);\n287    } else if (t.hover) {\n288      t.hover = false;\n289      t.onLeave(t);\n290    }\n291  }\n292}\n293function C(e) {\n294  A.x = e.clientX;\n295  A.y = e.clientY;\n296  for (const [elem, t] of b) {\n297    const i = elem.getBoundingClientRect();\n298    P(t, i);\n299    if (D(i)) t.onClick(t);\n300  }\n301}\n302function L() {\n303  for (const t of b.values()) {\n304    if (t.hover) {\n305      t.hover = false;\n306      t.onLeave(t);\n307    }\n308  }\n309}\n310function P(e, t) {\n311  const { position: i, nPosition: s } = e;\n312  i.x = A.x - t.left;\n313  i.y = A.y - t.top;\n314  s.x = (i.x / t.width) * 2 - 1;\n315  s.y = (-i.y / t.height) * 2 + 1;\n316}\n317function D(e) {\n318  const { x: t, y: i } = A;\n319  const { left: s, top: n, width: o, height: r } = e;\n320  return t >= s && t <= s + o && i >= n && i <= n + r;\n321}\n322\n323const { randFloat: k, randFloatSpread: E } = o;\n324const F = new a();\n325const I = new a();\n326const O = new a();\n327const V = new a();\n328const B = new a();\n329const N = new a();\n330const _ = new a();\n331const j = new a();\n332const H = new a();\n333const T = new a();\n334\n335class W {\n336  constructor(e) {\n337    this.config = e;\n338    this.positionData = new Float32Array(3 * e.count).fill(0);\n339    this.velocityData = new Float32Array(3 * e.count).fill(0);\n340    this.sizeData = new Float32Array(e.count).fill(1);\n341    this.center = new a();\n342    this.#R();\n343    this.setSizes();\n344  }\n345  #R() {\n346    const { config: e, positionData: t } = this;\n347    this.center.toArray(t, 0);\n348    for (let i = 1; i < e.count; i++) {\n349      const s = 3 * i;\n350      t[s] = E(2 * e.maxX);\n351      t[s + 1] = E(2 * e.maxY);\n352      t[s + 2] = E(2 * e.maxZ);\n353    }\n354  }\n355  setSizes() {\n356    const { config: e, sizeData: t } = this;\n357    t[0] = e.size0;\n358    for (let i = 1; i < e.count; i++) {\n359      t[i] = k(e.minSize, e.maxSize);\n360    }\n361  }\n362  update(e) {\n363    const { config: t, center: i, positionData: s, sizeData: n, velocityData: o } = this;\n364    let r = 0;\n365    if (t.controlSphere0) {\n366      r = 1;\n367      F.fromArray(s, 0);\n368      F.lerp(i, 0.1).toArray(s, 0);\n369      V.set(0, 0, 0).toArray(o, 0);\n370    }\n371    for (let idx = r; idx < t.count; idx++) {\n372      const base = 3 * idx;\n373      I.fromArray(s, base);\n374      B.fromArray(o, base);\n375      B.y -= e.delta * t.gravity * n[idx];\n376      B.multiplyScalar(t.friction);\n377      B.clampLength(0, t.maxVelocity);\n378      I.add(B);\n379      I.toArray(s, base);\n380      B.toArray(o, base);\n381    }\n382    for (let idx = r; idx < t.count; idx++) {\n383      const base = 3 * idx;\n384      I.fromArray(s, base);\n385      B.fromArray(o, base);\n386      const radius = n[idx];\n387      for (let jdx = idx + 1; jdx < t.count; jdx++) {\n388        const otherBase = 3 * jdx;\n389        O.fromArray(s, otherBase);\n390        N.fromArray(o, otherBase);\n391        const otherRadius = n[jdx];\n392        _.copy(O).sub(I);\n393        const dist = _.length();\n394        const sumRadius = radius + otherRadius;\n395        if (dist < sumRadius) {\n396          const overlap = sumRadius - dist;\n397          j.copy(_).normalize().multiplyScalar(0.5 * overlap);\n398          H.copy(j).multiplyScalar(Math.max(B.length(), 1));\n399          T.copy(j).multiplyScalar(Math.max(N.length(), 1));\n400          I.sub(j);\n401          B.sub(H);\n402          I.toArray(s, base);\n403          B.toArray(o, base);\n404          O.add(j);\n405          N.add(T);\n406          O.toArray(s, otherBase);\n407          N.toArray(o, otherBase);\n408        }\n409      }\n410      if (t.controlSphere0) {\n411        _.copy(F).sub(I);\n412        const dist = _.length();\n413        const sumRadius0 = radius + n[0];\n414        if (dist < sumRadius0) {\n415          const diff = sumRadius0 - dist;\n416          j.copy(_.normalize()).multiplyScalar(diff);\n417          H.copy(j).multiplyScalar(Math.max(B.length(), 2));\n418          I.sub(j);\n419          B.sub(H);\n420        }\n421      }\n422      if (Math.abs(I.x) + radius > t.maxX) {\n423        I.x = Math.sign(I.x) * (t.maxX - radius);\n424        B.x = -B.x * t.wallBounce;\n425      }\n426      if (t.gravity === 0) {\n427        if (Math.abs(I.y) + radius > t.maxY) {\n428          I.y = Math.sign(I.y) * (t.maxY - radius);\n429          B.y = -B.y * t.wallBounce;\n430        }\n431      } else if (I.y - radius < -t.maxY) {\n432        I.y = -t.maxY + radius;\n433        B.y = -B.y * t.wallBounce;\n434      }\n435      const maxBoundary = Math.max(t.maxZ, t.maxSize);\n436      if (Math.abs(I.z) + radius > maxBoundary) {\n437        I.z = Math.sign(I.z) * (t.maxZ - radius);\n438        B.z = -B.z * t.wallBounce;\n439      }\n440      I.toArray(s, base);\n441      B.toArray(o, base);\n442    }\n443  }\n444}\n445\n446class Y extends c {\n447  constructor(e) {\n448    super(e);\n449    this.uniforms = {\n450      thicknessDistortion: { value: 0.1 },\n451      thicknessAmbient: { value: 0 },\n452      thicknessAttenuation: { value: 0.1 },\n453      thicknessPower: { value: 2 },\n454      thicknessScale: { value: 10 },\n455    };\n456    this.defines.USE_UV = \"\";\n457    this.onBeforeCompile = (e) => {\n458      Object.assign(e.uniforms, this.uniforms);\n459      e.fragmentShader =\n460        \"\\n        uniform float thicknessPower;\\n        uniform float thicknessScale;\\n        uniform float thicknessDistortion;\\n        uniform float thicknessAmbient;\\n        uniform float thicknessAttenuation;\\n      \" +\n461        e.fragmentShader;\n462      e.fragmentShader = e.fragmentShader.replace(\n463        \"void main() {\",\n464        \"\\n        void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, inout ReflectedLight reflectedLight) {\\n          vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));\\n          float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;\\n          #ifdef USE_COLOR\\n            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * vColor;\\n          #else\\n            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * diffuse;\\n          #endif\\n          reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;\\n        }\\n\\n        void main() {\\n      \"\n465      );\n466      const t = h.lights_fragment_begin.replaceAll(\n467        \"RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\",\n468        \"\\n          RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n          RE_Direct_Scattering(directLight, vUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, reflectedLight);\\n        \"\n469      );\n470      e.fragmentShader = e.fragmentShader.replace(\"#include <lights_fragment_begin>\", t);\n471      if (this.onBeforeCompile2) this.onBeforeCompile2(e);\n472    };\n473  }\n474}\n475\n476const X = {\n477  count: 200,\n478  colors: [0, 0, 0],\n479  ambientColor: 16777215,\n480  ambientIntensity: 1,\n481  lightIntensity: 200,\n482  materialParams: {\n483    metalness: 0.5,\n484    roughness: 0.5,\n485    clearcoat: 1,\n486    clearcoatRoughness: 0.15,\n487  },\n488  minSize: 0.5,\n489  maxSize: 1,\n490  size0: 1,\n491  gravity: 0.5,\n492  friction: 0.9975,\n493  wallBounce: 0.95,\n494  maxVelocity: 0.15,\n495  maxX: 5,\n496  maxY: 5,\n497  maxZ: 2,\n498  controlSphere0: false,\n499  followCursor: true,  // Added default for followCursor\n500};\n501\n502const U = new m();\n503\n504class Z extends d {\n505  constructor(e, t = {}) {\n506    const i = { ...X, ...t };\n507    const s = new z();\n508    const n = new p(e, 0.04).fromScene(s).texture;\n509    const o = new g();\n510    const r = new Y({ envMap: n, ...i.materialParams });\n511    r.envMapRotation.x = -Math.PI / 2;\n512    super(o, r, i.count);\n513    this.config = i;\n514    this.physics = new W(i);\n515    this.#S();\n516    this.setColors(i.colors);\n517  }\n518  #S() {\n519    this.ambientLight = new f(\n520      this.config.ambientColor,\n521      this.config.ambientIntensity\n522    );\n523    this.add(this.ambientLight);\n524    this.light = new u(this.config.colors[0], this.config.lightIntensity);\n525    this.add(this.light);\n526  }\n527  setColors(e) {\n528    if (Array.isArray(e) && e.length > 1) {\n529      const t = (function (e) {\n530        let t, i;\n531        function setColors(e) {\n532          t = e;\n533          i = [];\n534          t.forEach((col) => {\n535            i.push(new l(col));\n536          });\n537        }\n538        setColors(e);\n539        return {\n540          setColors,\n541          getColorAt: function (ratio, out = new l()) {\n542            const scaled = Math.max(0, Math.min(1, ratio)) * (t.length - 1);\n543            const idx = Math.floor(scaled);\n544            const start = i[idx];\n545            if (idx >= t.length - 1) return start.clone();\n546            const alpha = scaled - idx;\n547            const end = i[idx + 1];\n548            out.r = start.r + alpha * (end.r - start.r);\n549            out.g = start.g + alpha * (end.g - start.g);\n550            out.b = start.b + alpha * (end.b - start.b);\n551            return out;\n552          },\n553        };\n554      })(e);\n555      for (let idx = 0; idx < this.count; idx++) {\n556        this.setColorAt(idx, t.getColorAt(idx / this.count));\n557        if (idx === 0) {\n558          this.light.color.copy(t.getColorAt(idx / this.count));\n559        }\n560      }\n561      this.instanceColor.needsUpdate = true;\n562    }\n563  }\n564  update(e) {\n565    this.physics.update(e);\n566    for (let idx = 0; idx < this.count; idx++) {\n567      U.position.fromArray(this.physics.positionData, 3 * idx);\n568      // Hide the first sphere if followCursor is false\n569      if (idx === 0 && this.config.followCursor === false) {\n570        U.scale.setScalar(0);\n571      } else {\n572        U.scale.setScalar(this.physics.sizeData[idx]);\n573      }\n574      U.updateMatrix();\n575      this.setMatrixAt(idx, U.matrix);\n576      if (idx === 0) this.light.position.copy(U.position);\n577    }\n578    this.instanceMatrix.needsUpdate = true;\n579  }\n580}\n581\n582function createBallpit(e, t = {}) {\n583  const i = new x({\n584    canvas: e,\n585    size: \"parent\",\n586    rendererOptions: { antialias: true, alpha: true },\n587  });\n588  let s;\n589  i.renderer.toneMapping = v;\n590  i.camera.position.set(0, 0, 20);\n591  i.camera.lookAt(0, 0, 0);\n592  i.cameraMaxAspect = 1.5;\n593  i.resize();\n594  initialize(t);\n595  const n = new y();\n596  const o = new w(new a(0, 0, 1), 0);\n597  const r = new a();\n598  let c = false;\n599  const h = S({\n600    domElement: e,\n601    onMove() {\n602      n.setFromCamera(h.nPosition, i.camera);\n603      i.camera.getWorldDirection(o.normal);\n604      n.ray.intersectPlane(o, r);\n605      s.physics.center.copy(r);\n606      s.config.controlSphere0 = true;\n607    },\n608    onLeave() {\n609      s.config.controlSphere0 = false;\n610    },\n611  });\n612  function initialize(e) {\n613    if (s) {\n614      i.clear();\n615      i.scene.remove(s);\n616    }\n617    s = new Z(i.renderer, e);\n618    i.scene.add(s);\n619  }\n620  i.onBeforeRender = (e) => {\n621    if (!c) s.update(e);\n622  };\n623  i.onAfterResize = (e) => {\n624    s.config.maxX = e.wWidth / 2;\n625    s.config.maxY = e.wHeight / 2;\n626  };\n627  return {\n628    three: i,\n629    get spheres() {\n630      return s;\n631    },\n632    setCount(e) {\n633      initialize({ ...s.config, count: e });\n634    },\n635    togglePause() {\n636      c = !c;\n637    },\n638    dispose() {\n639      h.dispose();\n640      i.dispose();\n641    },\n642  };\n643}\n644\n645const Ballpit = ({ className = '', followCursor = true, ...props }) => {\n646  const canvasRef = useRef(null);\n647  const spheresInstanceRef = useRef(null);\n648\n649  useEffect(() => {\n650    const canvas = canvasRef.current;\n651    if (!canvas) return;\n652\n653    spheresInstanceRef.current = createBallpit(canvas, { followCursor, ...props });\n654\n655    return () => {\n656      if (spheresInstanceRef.current) {\n657        spheresInstanceRef.current.dispose();\n658      }\n659    };\n660    // Dependencies intentionally left empty for single initialization\n661    // eslint-disable-next-line react-hooks/exhaustive-deps\n662  }, []);\n663\n664  return (\n665    <canvas\n666      className={className}\n667      ref={canvasRef}\n668      style={{ width: '100%', height: '100%' }}\n669    />\n670  );\n671};\n672\n673export default Ballpit;\n674\n\n1import { useRef, useEffect } from 'react';\n2import {\n3  Clock as e,\n4  PerspectiveCamera as t,\n5  Scene as i,\n6  WebGLRenderer as s,\n7  SRGBColorSpace as n,\n8  MathUtils as o,\n9  Vector2 as r,\n10  Vector3 as a,\n11  MeshPhysicalMaterial as c,\n12  ShaderChunk as h,\n13  Color as l,\n14  Object3D as m,\n15  InstancedMesh as d,\n16  PMREMGenerator as p,\n17  SphereGeometry as g,\n18  AmbientLight as f,\n19  PointLight as u,\n20  ACESFilmicToneMapping as v,\n21  Raycaster as y,\n22  Plane as w,\n23} from \"three\";\n24import { RoomEnvironment as z } from \"three/examples/jsm/environments/RoomEnvironment.js\";\n25\n26class x {\n27  #e;\n28  canvas;\n29  camera;\n30  cameraMinAspect;\n31  cameraMaxAspect;\n32  cameraFov;\n33  maxPixelRatio;\n34  minPixelRatio;\n35  scene;\n36  renderer;\n37  #t;\n38  size = { width: 0, height: 0, wWidth: 0, wHeight: 0, ratio: 0, pixelRatio: 0 };\n39  render = this.#i;\n40  onBeforeRender = () => { };\n41  onAfterRender = () => { };\n42  onAfterResize = () => { };\n43  #s = false;\n44  #n = false;\n45  isDisposed = false;\n46  #o;\n47  #r;\n48  #a;\n49  #c = new e();\n50  #h = { elapsed: 0, delta: 0 };\n51  #l;\n52  constructor(e) {\n53    this.#e = { ...e };\n54    this.#m();\n55    this.#d();\n56    this.#p();\n57    this.resize();\n58    this.#g();\n59  }\n60  #m() {\n61    this.camera = new t();\n62    this.cameraFov = this.camera.fov;\n63  }\n64  #d() {\n65    this.scene = new i();\n66  }\n67  #p() {\n68    if (this.#e.canvas) {\n69      this.canvas = this.#e.canvas;\n70    } else if (this.#e.id) {\n71      this.canvas = document.getElementById(this.#e.id);\n72    } else {\n73      console.error(\"Three: Missing canvas or id parameter\");\n74    }\n75    this.canvas.style.display = \"block\";\n76    const e = {\n77      canvas: this.canvas,\n78      powerPreference: \"high-performance\",\n79      ...(this.#e.rendererOptions ?? {}),\n80    };\n81    this.renderer = new s(e);\n82    this.renderer.outputColorSpace = n;\n83  }\n84  #g() {\n85    if (!(this.#e.size instanceof Object)) {\n86      window.addEventListener(\"resize\", this.#f.bind(this));\n87      if (this.#e.size === \"parent\" && this.canvas.parentNode) {\n88        this.#r = new ResizeObserver(this.#f.bind(this));\n89        this.#r.observe(this.canvas.parentNode);\n90      }\n91    }\n92    this.#o = new IntersectionObserver(this.#u.bind(this), {\n93      root: null,\n94      rootMargin: \"0px\",\n95      threshold: 0,\n96    });\n97    this.#o.observe(this.canvas);\n98    document.addEventListener(\"visibilitychange\", this.#v.bind(this));\n99  }\n100  #y() {\n101    window.removeEventListener(\"resize\", this.#f.bind(this));\n102    this.#r?.disconnect();\n103    this.#o?.disconnect();\n104    document.removeEventListener(\"visibilitychange\", this.#v.bind(this));\n105  }\n106  #u(e) {\n107    this.#s = e[0].isIntersecting;\n108    this.#s ? this.#w() : this.#z();\n109  }\n110  #v() {\n111    if (this.#s) {\n112      document.hidden ? this.#z() : this.#w();\n113    }\n114  }\n115  #f() {\n116    if (this.#a) clearTimeout(this.#a);\n117    this.#a = setTimeout(this.resize.bind(this), 100);\n118  }\n119  resize() {\n120    let e, t;\n121    if (this.#e.size instanceof Object) {\n122      e = this.#e.size.width;\n123      t = this.#e.size.height;\n124    } else if (this.#e.size === \"parent\" && this.canvas.parentNode) {\n125      e = this.canvas.parentNode.offsetWidth;\n126      t = this.canvas.parentNode.offsetHeight;\n127    } else {\n128      e = window.innerWidth;\n129      t = window.innerHeight;\n130    }\n131    this.size.width = e;\n132    this.size.height = t;\n133    this.size.ratio = e / t;\n134    this.#x();\n135    this.#b();\n136    this.onAfterResize(this.size);\n137  }\n138  #x() {\n139    this.camera.aspect = this.size.width / this.size.height;\n140    if (this.camera.isPerspectiveCamera && this.cameraFov) {\n141      if (this.cameraMinAspect && this.camera.aspect < this.cameraMinAspect) {\n142        this.#A(this.cameraMinAspect);\n143      } else if (this.cameraMaxAspect && this.camera.aspect > this.cameraMaxAspect) {\n144        this.#A(this.cameraMaxAspect);\n145      } else {\n146        this.camera.fov = this.cameraFov;\n147      }\n148    }\n149    this.camera.updateProjectionMatrix();\n150    this.updateWorldSize();\n151  }\n152  #A(e) {\n153    const t = Math.tan(o.degToRad(this.cameraFov / 2)) / (this.camera.aspect / e);\n154    this.camera.fov = 2 * o.radToDeg(Math.atan(t));\n155  }\n156  updateWorldSize() {\n157    if (this.camera.isPerspectiveCamera) {\n158      const e = (this.camera.fov * Math.PI) / 180;\n159      this.size.wHeight =\n160        2 * Math.tan(e / 2) * this.camera.position.length();\n161      this.size.wWidth = this.size.wHeight * this.camera.aspect;\n162    } else if (this.camera.isOrthographicCamera) {\n163      this.size.wHeight = this.camera.top - this.camera.bottom;\n164      this.size.wWidth = this.camera.right - this.camera.left;\n165    }\n166  }\n167  #b() {\n168    this.renderer.setSize(this.size.width, this.size.height);\n169    this.#t?.setSize(this.size.width, this.size.height);\n170    let e = window.devicePixelRatio;\n171    if (this.maxPixelRatio && e > this.maxPixelRatio) {\n172      e = this.maxPixelRatio;\n173    } else if (this.minPixelRatio && e < this.minPixelRatio) {\n174      e = this.minPixelRatio;\n175    }\n176    this.renderer.setPixelRatio(e);\n177    this.size.pixelRatio = e;\n178  }\n179  get postprocessing() {\n180    return this.#t;\n181  }\n182  set postprocessing(e) {\n183    this.#t = e;\n184    this.render = e.render.bind(e);\n185  }\n186  #w() {\n187    if (this.#n) return;\n188    const animate = () => {\n189      this.#l = requestAnimationFrame(animate);\n190      this.#h.delta = this.#c.getDelta();\n191      this.#h.elapsed += this.#h.delta;\n192      this.onBeforeRender(this.#h);\n193      this.render();\n194      this.onAfterRender(this.#h);\n195    };\n196    this.#n = true;\n197    this.#c.start();\n198    animate();\n199  }\n200  #z() {\n201    if (this.#n) {\n202      cancelAnimationFrame(this.#l);\n203      this.#n = false;\n204      this.#c.stop();\n205    }\n206  }\n207  #i() {\n208    this.renderer.render(this.scene, this.camera);\n209  }\n210  clear() {\n211    this.scene.traverse((e) => {\n212      if (\n213        e.isMesh &&\n214        typeof e.material === \"object\" &&\n215        e.material !== null\n216      ) {\n217        Object.keys(e.material).forEach((t) => {\n218          const i = e.material[t];\n219          if (i !== null && typeof i === \"object\" && typeof i.dispose === \"function\") {\n220            i.dispose();\n221          }\n222        });\n223        e.material.dispose();\n224        e.geometry.dispose();\n225      }\n226    });\n227    this.scene.clear();\n228  }\n229  dispose() {\n230    this.#y();\n231    this.#z();\n232    this.clear();\n233    this.#t?.dispose();\n234    this.renderer.dispose();\n235    this.isDisposed = true;\n236  }\n237}\n238\n239const b = new Map(),\n240  A = new r();\n241let R = false;\n242function S(e) {\n243  const t = {\n244    position: new r(),\n245    nPosition: new r(),\n246    hover: false,\n247    onEnter() { },\n248    onMove() { },\n249    onClick() { },\n250    onLeave() { },\n251    ...e,\n252  };\n253  (function (e, t) {\n254    if (!b.has(e)) {\n255      b.set(e, t);\n256      if (!R) {\n257        document.body.addEventListener(\"pointermove\", M);\n258        document.body.addEventListener(\"pointerleave\", L);\n259        document.body.addEventListener(\"click\", C);\n260        R = true;\n261      }\n262    }\n263  })(e.domElement, t);\n264  t.dispose = () => {\n265    const t = e.domElement;\n266    b.delete(t);\n267    if (b.size === 0) {\n268      document.body.removeEventListener(\"pointermove\", M);\n269      document.body.removeEventListener(\"pointerleave\", L);\n270      R = false;\n271    }\n272  };\n273  return t;\n274}\n275function M(e) {\n276  A.x = e.clientX;\n277  A.y = e.clientY;\n278  for (const [elem, t] of b) {\n279    const i = elem.getBoundingClientRect();\n280    if (D(i)) {\n281      P(t, i);\n282      if (!t.hover) {\n283        t.hover = true;\n284        t.onEnter(t);\n285      }\n286      t.onMove(t);\n287    } else if (t.hover) {\n288      t.hover = false;\n289      t.onLeave(t);\n290    }\n291  }\n292}\n293function C(e) {\n294  A.x = e.clientX;\n295  A.y = e.clientY;\n296  for (const [elem, t] of b) {\n297    const i = elem.getBoundingClientRect();\n298    P(t, i);\n299    if (D(i)) t.onClick(t);\n300  }\n301}\n302function L() {\n303  for (const t of b.values()) {\n304    if (t.hover) {\n305      t.hover = false;\n306      t.onLeave(t);\n307    }\n308  }\n309}\n310function P(e, t) {\n311  const { position: i, nPosition: s } = e;\n312  i.x = A.x - t.left;\n313  i.y = A.y - t.top;\n314  s.x = (i.x / t.width) * 2 - 1;\n315  s.y = (-i.y / t.height) * 2 + 1;\n316}\n317function D(e) {\n318  const { x: t, y: i } = A;\n319  const { left: s, top: n, width: o, height: r } = e;\n320  return t >= s && t <= s + o && i >= n && i <= n + r;\n321}\n322\n323const { randFloat: k, randFloatSpread: E } = o;\n324const F = new a();\n325const I = new a();\n326const O = new a();\n327const V = new a();\n328const B = new a();\n329const N = new a();\n330const _ = new a();\n331const j = new a();\n332const H = new a();\n333const T = new a();\n334\n335class W {\n336  constructor(e) {\n337    this.config = e;\n338    this.positionData = new Float32Array(3 * e.count).fill(0);\n339    this.velocityData = new Float32Array(3 * e.count).fill(0);\n340    this.sizeData = new Float32Array(e.count).fill(1);\n341    this.center = new a();\n342    this.#R();\n343    this.setSizes();\n344  }\n345  #R() {\n346    const { config: e, positionData: t } = this;\n347    this.center.toArray(t, 0);\n348    for (let i = 1; i < e.count; i++) {\n349      const s = 3 * i;\n350      t[s] = E(2 * e.maxX);\n351      t[s + 1] = E(2 * e.maxY);\n352      t[s + 2] = E(2 * e.maxZ);\n353    }\n354  }\n355  setSizes() {\n356    const { config: e, sizeData: t } = this;\n357    t[0] = e.size0;\n358    for (let i = 1; i < e.count; i++) {\n359      t[i] = k(e.minSize, e.maxSize);\n360    }\n361  }\n362  update(e) {\n363    const { config: t, center: i, positionData: s, sizeData: n, velocityData: o } = this;\n364    let r = 0;\n365    if (t.controlSphere0) {\n366      r = 1;\n367      F.fromArray(s, 0);\n368      F.lerp(i, 0.1).toArray(s, 0);\n369      V.set(0, 0, 0).toArray(o, 0);\n370    }\n371    for (let idx = r; idx < t.count; idx++) {\n372      const base = 3 * idx;\n373      I.fromArray(s, base);\n374      B.fromArray(o, base);\n375      B.y -= e.delta * t.gravity * n[idx];\n376      B.multiplyScalar(t.friction);\n377      B.clampLength(0, t.maxVelocity);\n378      I.add(B);\n379      I.toArray(s, base);\n380      B.toArray(o, base);\n381    }\n382    for (let idx = r; idx < t.count; idx++) {\n383      const base = 3 * idx;\n384      I.fromArray(s, base);\n385      B.fromArray(o, base);\n386      const radius = n[idx];\n387      for (let jdx = idx + 1; jdx < t.count; jdx++) {\n388        const otherBase = 3 * jdx;\n389        O.fromArray(s, otherBase);\n390        N.fromArray(o, otherBase);\n391        const otherRadius = n[jdx];\n392        _.copy(O).sub(I);\n393        const dist = _.length();\n394        const sumRadius = radius + otherRadius;\n395        if (dist < sumRadius) {\n396          const overlap = sumRadius - dist;\n397          j.copy(_).normalize().multiplyScalar(0.5 * overlap);\n398          H.copy(j).multiplyScalar(Math.max(B.length(), 1));\n399          T.copy(j).multiplyScalar(Math.max(N.length(), 1));\n400          I.sub(j);\n401          B.sub(H);\n402          I.toArray(s, base);\n403          B.toArray(o, base);\n404          O.add(j);\n405          N.add(T);\n406          O.toArray(s, otherBase);\n407          N.toArray(o, otherBase);\n408        }\n409      }\n410      if (t.controlSphere0) {\n411        _.copy(F).sub(I);\n412        const dist = _.length();\n413        const sumRadius0 = radius + n[0];\n414        if (dist < sumRadius0) {\n415          const diff = sumRadius0 - dist;\n416          j.copy(_.normalize()).multiplyScalar(diff);\n417          H.copy(j).multiplyScalar(Math.max(B.length(), 2));\n418          I.sub(j);\n419          B.sub(H);\n420        }\n421      }\n422      if (Math.abs(I.x) + radius > t.maxX) {\n423        I.x = Math.sign(I.x) * (t.maxX - radius);\n424        B.x = -B.x * t.wallBounce;\n425      }\n426      if (t.gravity === 0) {\n427        if (Math.abs(I.y) + radius > t.maxY) {\n428          I.y = Math.sign(I.y) * (t.maxY - radius);\n429          B.y = -B.y * t.wallBounce;\n430        }\n431      } else if (I.y - radius < -t.maxY) {\n432        I.y = -t.maxY + radius;\n433        B.y = -B.y * t.wallBounce;\n434      }\n435      const maxBoundary = Math.max(t.maxZ, t.maxSize);\n436      if (Math.abs(I.z) + radius > maxBoundary) {\n437        I.z = Math.sign(I.z) * (t.maxZ - radius);\n438        B.z = -B.z * t.wallBounce;\n439      }\n440      I.toArray(s, base);\n441      B.toArray(o, base);\n442    }\n443  }\n444}\n445\n446class Y extends c {\n447  constructor(e) {\n448    super(e);\n449    this.uniforms = {\n450      thicknessDistortion: { value: 0.1 },\n451      thicknessAmbient: { value: 0 },\n452      thicknessAttenuation: { value: 0.1 },\n453      thicknessPower: { value: 2 },\n454      thicknessScale: { value: 10 },\n455    };\n456    this.defines.USE_UV = \"\";\n457    this.onBeforeCompile = (e) => {\n458      Object.assign(e.uniforms, this.uniforms);\n459      e.fragmentShader =\n460        \"\\n        uniform float thicknessPower;\\n        uniform float thicknessScale;\\n        uniform float thicknessDistortion;\\n        uniform float thicknessAmbient;\\n        uniform float thicknessAttenuation;\\n      \" +\n461        e.fragmentShader;\n462      e.fragmentShader = e.fragmentShader.replace(\n463        \"void main() {\",\n464        \"\\n        void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, inout ReflectedLight reflectedLight) {\\n          vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));\\n          float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;\\n          #ifdef USE_COLOR\\n            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * vColor;\\n          #else\\n            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * diffuse;\\n          #endif\\n          reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;\\n        }\\n\\n        void main() {\\n      \"\n465      );\n466      const t = h.lights_fragment_begin.replaceAll(\n467        \"RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\",\n468        \"\\n          RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n          RE_Direct_Scattering(directLight, vUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, reflectedLight);\\n        \"\n469      );\n470      e.fragmentShader = e.fragmentShader.replace(\"#include <lights_fragment_begin>\", t);\n471      if (this.onBeforeCompile2) this.onBeforeCompile2(e);\n472    };\n473  }\n474}\n475\n476const X = {\n477  count: 200,\n478  colors: [0, 0, 0],\n479  ambientColor: 16777215,\n480  ambientIntensity: 1,\n481  lightIntensity: 200,\n482  materialParams: {\n483    metalness: 0.5,\n484    roughness: 0.5,\n485    clearcoat: 1,\n486    clearcoatRoughness: 0.15,\n487  },\n488  minSize: 0.5,\n489  maxSize: 1,\n490  size0: 1,\n491  gravity: 0.5,\n492  friction: 0.9975,\n493  wallBounce: 0.95,\n494  maxVelocity: 0.15,\n495  maxX: 5,\n496  maxY: 5,\n497  maxZ: 2,\n498  controlSphere0: false,\n499  followCursor: true,  // Added default for followCursor\n500};\n501\n502const U = new m();\n503\n504class Z extends d {\n505  constructor(e, t = {}) {\n506    const i = { ...X, ...t };\n507    const s = new z();\n508    const n = new p(e, 0.04).fromScene(s).texture;\n509    const o = new g();\n510    const r = new Y({ envMap: n, ...i.materialParams });\n511    r.envMapRotation.x = -Math.PI / 2;\n512    super(o, r, i.count);\n513    this.config = i;\n514    this.physics = new W(i);\n515    this.#S();\n516    this.setColors(i.colors);\n517  }\n518  #S() {\n519    this.ambientLight = new f(\n520      this.config.ambientColor,\n521      this.config.ambientIntensity\n522    );\n523    this.add(this.ambientLight);\n524    this.light = new u(this.config.colors[0], this.config.lightIntensity);\n525    this.add(this.light);\n526  }\n527  setColors(e) {\n528    if (Array.isArray(e) && e.length > 1) {\n529      const t = (function (e) {\n530        let t, i;\n531        function setColors(e) {\n532          t = e;\n533          i = [];\n534          t.forEach((col) => {\n535            i.push(new l(col));\n536          });\n537        }\n538        setColors(e);\n539        return {\n540          setColors,\n541          getColorAt: function (ratio, out = new l()) {\n542            const scaled = Math.max(0, Math.min(1, ratio)) * (t.length - 1);\n543            const idx = Math.floor(scaled);\n544            const start = i[idx];\n545            if (idx >= t.length - 1) return start.clone();\n546            const alpha = scaled - idx;\n547            const end = i[idx + 1];\n548            out.r = start.r + alpha * (end.r - start.r);\n549            out.g = start.g + alpha * (end.g - start.g);\n550            out.b = start.b + alpha * (end.b - start.b);\n551            return out;\n552          },\n553        };\n554      })(e);\n555      for (let idx = 0; idx < this.count; idx++) {\n556        this.setColorAt(idx, t.getColorAt(idx / this.count));\n557        if (idx === 0) {\n558          this.light.color.copy(t.getColorAt(idx / this.count));\n559        }\n560      }\n561      this.instanceColor.needsUpdate = true;\n562    }\n563  }\n564  update(e) {\n565    this.physics.update(e);\n566    for (let idx = 0; idx < this.count; idx++) {\n567      U.position.fromArray(this.physics.positionData, 3 * idx);\n568      // Hide the first sphere if followCursor is false\n569      if (idx === 0 && this.config.followCursor === false) {\n570        U.scale.setScalar(0);\n571      } else {\n572        U.scale.setScalar(this.physics.sizeData[idx]);\n573      }\n574      U.updateMatrix();\n575      this.setMatrixAt(idx, U.matrix);\n576      if (idx === 0) this.light.position.copy(U.position);\n577    }\n578    this.instanceMatrix.needsUpdate = true;\n579  }\n580}\n581\n582function createBallpit(e, t = {}) {\n583  const i = new x({\n584    canvas: e,\n585    size: \"parent\",\n586    rendererOptions: { antialias: true, alpha: true },\n587  });\n588  let s;\n589  i.renderer.toneMapping = v;\n590  i.camera.position.set(0, 0, 20);\n591  i.camera.lookAt(0, 0, 0);\n592  i.cameraMaxAspect = 1.5;\n593  i.resize();\n594  initialize(t);\n595  const n = new y();\n596  const o = new w(new a(0, 0, 1), 0);\n597  const r = new a();\n598  let c = false;\n599  const h = S({\n600    domElement: e,\n601    onMove() {\n602      n.setFromCamera(h.nPosition, i.camera);\n603      i.camera.getWorldDirection(o.normal);\n604      n.ray.intersectPlane(o, r);\n605      s.physics.center.copy(r);\n606      s.config.controlSphere0 = true;\n607    },\n608    onLeave() {\n609      s.config.controlSphere0 = false;\n610    },\n611  });\n612  function initialize(e) {\n613    if (s) {\n614      i.clear();\n615      i.scene.remove(s);\n616    }\n617    s = new Z(i.renderer, e);\n618    i.scene.add(s);\n619  }\n620  i.onBeforeRender = (e) => {\n621    if (!c) s.update(e);\n622  };\n623  i.onAfterResize = (e) => {\n624    s.config.maxX = e.wWidth / 2;\n625    s.config.maxY = e.wHeight / 2;\n626  };\n627  return {\n628    three: i,\n629    get spheres() {\n630      return s;\n631    },\n632    setCount(e) {\n633      initialize({ ...s.config, count: e });\n634    },\n635    togglePause() {\n636      c = !c;\n637    },\n638    dispose() {\n639      h.dispose();\n640      i.dispose();\n641    },\n642  };\n643}\n644\n645const Ballpit = ({ className = '', followCursor = true, ...props }) => {\n646  const canvasRef = useRef(null);\n647  const spheresInstanceRef = useRef(null);\n648\n649  useEffect(() => {\n650    const canvas = canvasRef.current;\n651    if (!canvas) return;\n652\n653    spheresInstanceRef.current = createBallpit(canvas, { followCursor, ...props });\n654\n655    return () => {\n656      if (spheresInstanceRef.current) {\n657        spheresInstanceRef.current.dispose();\n658      }\n659    };\n660    // Dependencies intentionally left empty for single initialization\n661    // eslint-disable-next-line react-hooks/exhaustive-deps\n662  }, []);\n663\n664  return (\n665    <canvas\n666      className={`${className} w-full h-full`}\n667      ref={canvasRef}\n668    />\n669  );\n670};\n671\n672export default Ballpit;\n673"
}