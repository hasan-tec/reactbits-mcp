{
  "name": "Hyperspeed",
  "description": "An open source collection of high quality, animated, interactive & fully customizable React components for building stunning, memorable user interfaces.",
  "props": {},
  "dependencies": [],
  "url": "https://www.reactbits.dev/backgrounds/hyperspeed",
  "code": "1npm i three postprocessing\n\n1import Hyperspeed from './Hyperspeed';\n2\n3// the component will fill the height/width of its parent container, edit the CSS to change this\n4// the options below are the default values\n5\n6<Hyperspeed\n7  effectOptions={{\n8    onSpeedUp: () => { },\n9    onSlowDown: () => { },\n10    distortion: 'turbulentDistortion',\n11    length: 400,\n12    roadWidth: 10,\n13    islandWidth: 2,\n14    lanesPerRoad: 4,\n15    fov: 90,\n16    fovSpeedUp: 150,\n17    speedUp: 2,\n18    carLightsFade: 0.4,\n19    totalSideLightSticks: 20,\n20    lightPairsPerRoadWay: 40,\n21    shoulderLinesWidthPercentage: 0.05,\n22    brokenLinesWidthPercentage: 0.1,\n23    brokenLinesLengthPercentage: 0.5,\n24    lightStickWidth: [0.12, 0.5],\n25    lightStickHeight: [1.3, 1.7],\n26    movingAwaySpeed: [60, 80],\n27    movingCloserSpeed: [-120, -160],\n28    carLightsLength: [400 * 0.03, 400 * 0.2],\n29    carLightsRadius: [0.05, 0.14],\n30    carWidthPercentage: [0.3, 0.5],\n31    carShiftX: [-0.8, 0.8],\n32    carFloorSeparation: [0, 5],\n33    colors: {\n34      roadColor: 0x080808,\n35      islandColor: 0x0a0a0a,\n36      background: 0x000000,\n37      shoulderLines: 0xFFFFFF,\n38      brokenLines: 0xFFFFFF,\n39      leftCars: [0xD856BF, 0x6750A2, 0xC247AC],\n40      rightCars: [0x03B3C3, 0x0E5EA5, 0x324555],\n41      sticks: 0x03B3C3,\n42    }\n43  }}\n44/>\n\n1export const hyperspeedPresets = {\n2  one: {\n3    onSpeedUp: () => { },\n4    onSlowDown: () => { },\n5    distortion: 'turbulentDistortion',\n6    length: 400,\n7    roadWidth: 10,\n8    islandWidth: 2,\n9    lanesPerRoad: 3,\n10    fov: 90,\n11    fovSpeedUp: 150,\n12    speedUp: 2,\n13    carLightsFade: 0.4,\n14    totalSideLightSticks: 20,\n15    lightPairsPerRoadWay: 40,\n16    shoulderLinesWidthPercentage: 0.05,\n17    brokenLinesWidthPercentage: 0.1,\n18    brokenLinesLengthPercentage: 0.5,\n19    lightStickWidth: [0.12, 0.5],\n20    lightStickHeight: [1.3, 1.7],\n21    movingAwaySpeed: [60, 80],\n22    movingCloserSpeed: [-120, -160],\n23    carLightsLength: [400 * 0.03, 400 * 0.2],\n24    carLightsRadius: [0.05, 0.14],\n25    carWidthPercentage: [0.3, 0.5],\n26    carShiftX: [-0.8, 0.8],\n27    carFloorSeparation: [0, 5],\n28    colors: {\n29      roadColor: 0x080808,\n30      islandColor: 0x0a0a0a,\n31      background: 0x000000,\n32      shoulderLines: 0x131318,\n33      brokenLines: 0x131318,\n34      leftCars: [0xD856BF, 0x6750A2, 0xC247AC],\n35      rightCars: [0x03B3C3, 0x0E5EA5, 0x324555],\n36      sticks: 0x03B3C3,\n37    }\n38  },\n39  two: {\n40    onSpeedUp: () => { },\n41    onSlowDown: () => { },\n42    distortion: 'mountainDistortion',\n43    length: 400,\n44    roadWidth: 9,\n45    islandWidth: 2,\n46    lanesPerRoad: 3,\n47    fov: 90,\n48    fovSpeedUp: 150,\n49    speedUp: 2,\n50    carLightsFade: 0.4,\n51    totalSideLightSticks: 50,\n52    lightPairsPerRoadWay: 50,\n53    shoulderLinesWidthPercentage: 0.05,\n54    brokenLinesWidthPercentage: 0.1,\n55    brokenLinesLengthPercentage: 0.5,\n56    lightStickWidth: [0.12, 0.5],\n57    lightStickHeight: [1.3, 1.7],\n58\n59    movingAwaySpeed: [60, 80],\n60    movingCloserSpeed: [-120, -160],\n61    carLightsLength: [400 * 0.05, 400 * 0.15],\n62    carLightsRadius: [0.05, 0.14],\n63    carWidthPercentage: [0.3, 0.5],\n64    carShiftX: [-0.2, 0.2],\n65    carFloorSeparation: [0.05, 1],\n66    colors: {\n67      roadColor: 0x080808,\n68      islandColor: 0x0a0a0a,\n69      background: 0x000000,\n70      shoulderLines: 0x131318,\n71      brokenLines: 0x131318,\n72      leftCars: [0xff102a, 0xEB383E, 0xff102a],\n73      rightCars: [0xdadafa, 0xBEBAE3, 0x8F97E4],\n74      sticks: 0xdadafa,\n75    }\n76  },\n77  three: {\n78    onSpeedUp: () => { },\n79    onSlowDown: () => { },\n80    distortion: 'xyDistortion',\n81    length: 400,\n82    roadWidth: 9,\n83    islandWidth: 2,\n84    lanesPerRoad: 3,\n85    fov: 90,\n86    fovSpeedUp: 150,\n87    speedUp: 3,\n88    carLightsFade: 0.4,\n89    totalSideLightSticks: 50,\n90    lightPairsPerRoadWay: 30,\n91    shoulderLinesWidthPercentage: 0.05,\n92    brokenLinesWidthPercentage: 0.1,\n93    brokenLinesLengthPercentage: 0.5,\n94    lightStickWidth: [0.02, 0.05],\n95    lightStickHeight: [0.3, 0.7],\n96    movingAwaySpeed: [20, 50],\n97    movingCloserSpeed: [-150, -230],\n98    carLightsLength: [400 * 0.05, 400 * 0.2],\n99    carLightsRadius: [0.03, 0.08],\n100    carWidthPercentage: [0.1, 0.5],\n101    carShiftX: [-0.5, 0.5],\n102    carFloorSeparation: [0, 0.1],\n103    colors: {\n104      roadColor: 0x080808,\n105      islandColor: 0x0a0a0a,\n106      background: 0x000000,\n107      shoulderLines: 0x131318,\n108      brokenLines: 0x131318,\n109      leftCars: [0x7D0D1B, 0xA90519, 0xff102a],\n110      rightCars: [0xF1EECE, 0xE6E2B1, 0xDFD98A],\n111      sticks: 0xF1EECE,\n112    }\n113  },\n114  four: {\n115    onSpeedUp: () => { },\n116    onSlowDown: () => { },\n117    distortion: 'LongRaceDistortion',\n118    length: 400,\n119    roadWidth: 10,\n120    islandWidth: 5,\n121    lanesPerRoad: 2,\n122    fov: 90,\n123    fovSpeedUp: 150,\n124    speedUp: 2,\n125    carLightsFade: 0.4,\n126    totalSideLightSticks: 50,\n127    lightPairsPerRoadWay: 70,\n128    shoulderLinesWidthPercentage: 0.05,\n129    brokenLinesWidthPercentage: 0.1,\n130    brokenLinesLengthPercentage: 0.5,\n131    lightStickWidth: [0.12, 0.5],\n132    lightStickHeight: [1.3, 1.7],\n133    movingAwaySpeed: [60, 80],\n134    movingCloserSpeed: [-120, -160],\n135    carLightsLength: [400 * 0.05, 400 * 0.15],\n136    carLightsRadius: [0.05, 0.14],\n137    carWidthPercentage: [0.3, 0.5],\n138    carShiftX: [-0.2, 0.2],\n139    carFloorSeparation: [0.05, 1],\n140    colors: {\n141      roadColor: 0x080808,\n142      islandColor: 0x0a0a0a,\n143      background: 0x000000,\n144      shoulderLines: 0x131318,\n145      brokenLines: 0x131318,\n146      leftCars: [0xFF5F73, 0xE74D60, 0xff102a],\n147      rightCars: [0xA4E3E6, 0x80D1D4, 0x53C2C6],\n148      sticks: 0xA4E3E6,\n149    }\n150  },\n151  five: {\n152    onSpeedUp: () => { },\n153    onSlowDown: () => { },\n154    distortion: 'turbulentDistortion',\n155    length: 400,\n156    roadWidth: 9,\n157    islandWidth: 2,\n158    lanesPerRoad: 3,\n159    fov: 90,\n160    fovSpeedUp: 150,\n161    speedUp: 2,\n162    carLightsFade: 0.4,\n163    totalSideLightSticks: 50,\n164    lightPairsPerRoadWay: 50,\n165    shoulderLinesWidthPercentage: 0.05,\n166    brokenLinesWidthPercentage: 0.1,\n167    brokenLinesLengthPercentage: 0.5,\n168    lightStickWidth: [0.12, 0.5],\n169    lightStickHeight: [1.3, 1.7],\n170    movingAwaySpeed: [60, 80],\n171    movingCloserSpeed: [-120, -160],\n172    carLightsLength: [400 * 0.05, 400 * 0.15],\n173    carLightsRadius: [0.05, 0.14],\n174    carWidthPercentage: [0.3, 0.5],\n175    carShiftX: [-0.2, 0.2],\n176    carFloorSeparation: [0.05, 1],\n177    colors: {\n178      roadColor: 0x080808,\n179      islandColor: 0x0a0a0a,\n180      background: 0x000000,\n181      shoulderLines: 0x131318,\n182      brokenLines: 0x131318,\n183      /***  Only these colors can be an array ***/\n184      leftCars: [0xDC5B20, 0xDCA320, 0xDC2020],\n185      rightCars: [0x334BF7, 0xE5E6ED, 0xBFC6F3],\n186      sticks: 0xC5E8EB,\n187    }\n188  },\n189  six: {\n190    onSpeedUp: () => { },\n191    onSlowDown: () => { },\n192    distortion: 'deepDistortion',\n193    length: 400,\n194    roadWidth: 18,\n195    islandWidth: 2,\n196    lanesPerRoad: 3,\n197    fov: 90,\n198    fovSpeedUp: 150,\n199    speedUp: 2,\n200    carLightsFade: 0.4,\n201    totalSideLightSticks: 50,\n202    lightPairsPerRoadWay: 50,\n203    shoulderLinesWidthPercentage: 0.05,\n204    brokenLinesWidthPercentage: 0.1,\n205    brokenLinesLengthPercentage: 0.5,\n206    lightStickWidth: [0.12, 0.5],\n207    lightStickHeight: [1.3, 1.7],\n208    movingAwaySpeed: [60, 80],\n209    movingCloserSpeed: [-120, -160],\n210    carLightsLength: [400 * 0.05, 400 * 0.15],\n211    carLightsRadius: [0.05, 0.14],\n212    carWidthPercentage: [0.3, 0.5],\n213    carShiftX: [-0.2, 0.2],\n214    carFloorSeparation: [0.05, 1],\n215    colors: {\n216      roadColor: 0x080808,\n217      islandColor: 0x0a0a0a,\n218      background: 0x000000,\n219      shoulderLines: 0x131318,\n220      brokenLines: 0x131318,\n221      leftCars: [0xFF322F, 0xA33010, 0xA81508],\n222      rightCars: [0xFDFDF0, 0xF3DEA0, 0xE2BB88],\n223      sticks: 0xFDFDF0,\n224    }\n225  }\n226}\n\n1import { useEffect, useRef } from \"react\";\n2import * as THREE from 'three';\n3import { BloomEffect, EffectComposer, EffectPass, RenderPass, SMAAEffect, SMAAPreset } from 'postprocessing';\n4\n5import './Hyperspeed.css';\n6\n7const Hyperspeed = ({ effectOptions = {\n8  onSpeedUp: () => { },\n9  onSlowDown: () => { },\n10  distortion: 'turbulentDistortion',\n11  length: 400,\n12  roadWidth: 10,\n13  islandWidth: 2,\n14  lanesPerRoad: 4,\n15  fov: 90,\n16  fovSpeedUp: 150,\n17  speedUp: 2,\n18  carLightsFade: 0.4,\n19  totalSideLightSticks: 20,\n20  lightPairsPerRoadWay: 40,\n21  shoulderLinesWidthPercentage: 0.05,\n22  brokenLinesWidthPercentage: 0.1,\n23  brokenLinesLengthPercentage: 0.5,\n24  lightStickWidth: [0.12, 0.5],\n25  lightStickHeight: [1.3, 1.7],\n26  movingAwaySpeed: [60, 80],\n27  movingCloserSpeed: [-120, -160],\n28  carLightsLength: [400 * 0.03, 400 * 0.2],\n29  carLightsRadius: [0.05, 0.14],\n30  carWidthPercentage: [0.3, 0.5],\n31  carShiftX: [-0.8, 0.8],\n32  carFloorSeparation: [0, 5],\n33  colors: {\n34    roadColor: 0x080808,\n35    islandColor: 0x0a0a0a,\n36    background: 0x000000,\n37    shoulderLines: 0xFFFFFF,\n38    brokenLines: 0xFFFFFF,\n39    leftCars: [0xD856BF, 0x6750A2, 0xC247AC],\n40    rightCars: [0x03B3C3, 0x0E5EA5, 0x324555],\n41    sticks: 0x03B3C3,\n42  }\n43} }) => {\n44  const hyperspeed = useRef(null);\n45  useEffect(() => {\n46    const mountainUniforms = {\n47      uFreq: { value: new THREE.Vector3(3, 6, 10) },\n48      uAmp: { value: new THREE.Vector3(30, 30, 20) }\n49    };\n50\n51    const xyUniforms = {\n52      uFreq: { value: new THREE.Vector2(5, 2) },\n53      uAmp: { value: new THREE.Vector2(25, 15) }\n54    };\n55\n56    const LongRaceUniforms = {\n57      uFreq: { value: new THREE.Vector2(2, 3) },\n58      uAmp: { value: new THREE.Vector2(35, 10) }\n59    };\n60\n61    const turbulentUniforms = {\n62      uFreq: { value: new THREE.Vector4(4, 8, 8, 1) },\n63      uAmp: { value: new THREE.Vector4(25, 5, 10, 10) }\n64    };\n65\n66    const deepUniforms = {\n67      uFreq: { value: new THREE.Vector2(4, 8) },\n68      uAmp: { value: new THREE.Vector2(10, 20) },\n69      uPowY: { value: new THREE.Vector2(20, 2) }\n70    };\n71\n72    let nsin = val => Math.sin(val) * 0.5 + 0.5;\n73\n74    const distortions = {\n75      mountainDistortion: {\n76        uniforms: mountainUniforms,\n77        getDistortion: `\n78          uniform vec3 uAmp;\n79          uniform vec3 uFreq;\n80          #define PI 3.14159265358979\n81          float nsin(float val){\n82            return sin(val) * 0.5 + 0.5;\n83          }\n84          vec3 getDistortion(float progress){\n85            float movementProgressFix = 0.02;\n86            return vec3( \n87              cos(progress * PI * uFreq.x + uTime) * uAmp.x - cos(movementProgressFix * PI * uFreq.x + uTime) * uAmp.x,\n88              nsin(progress * PI * uFreq.y + uTime) * uAmp.y - nsin(movementProgressFix * PI * uFreq.y + uTime) * uAmp.y,\n89              nsin(progress * PI * uFreq.z + uTime) * uAmp.z - nsin(movementProgressFix * PI * uFreq.z + uTime) * uAmp.z\n90            );\n91          }\n92        `,\n93        getJS: (progress, time) => {\n94          let movementProgressFix = 0.02;\n95          let uFreq = mountainUniforms.uFreq.value;\n96          let uAmp = mountainUniforms.uAmp.value;\n97          let distortion = new THREE.Vector3(\n98            Math.cos(progress * Math.PI * uFreq.x + time) * uAmp.x -\n99            Math.cos(movementProgressFix * Math.PI * uFreq.x + time) * uAmp.x,\n100            nsin(progress * Math.PI * uFreq.y + time) * uAmp.y -\n101            nsin(movementProgressFix * Math.PI * uFreq.y + time) * uAmp.y,\n102            nsin(progress * Math.PI * uFreq.z + time) * uAmp.z -\n103            nsin(movementProgressFix * Math.PI * uFreq.z + time) * uAmp.z\n104          );\n105          let lookAtAmp = new THREE.Vector3(2, 2, 2);\n106          let lookAtOffset = new THREE.Vector3(0, 0, -5);\n107          return distortion.multiply(lookAtAmp).add(lookAtOffset);\n108        }\n109      },\n110      xyDistortion: {\n111        uniforms: xyUniforms,\n112        getDistortion: `\n113          uniform vec2 uFreq;\n114          uniform vec2 uAmp;\n115          #define PI 3.14159265358979\n116          vec3 getDistortion(float progress){\n117            float movementProgressFix = 0.02;\n118            return vec3( \n119              cos(progress * PI * uFreq.x + uTime) * uAmp.x - cos(movementProgressFix * PI * uFreq.x + uTime) * uAmp.x,\n120              sin(progress * PI * uFreq.y + PI/2. + uTime) * uAmp.y - sin(movementProgressFix * PI * uFreq.y + PI/2. + uTime) * uAmp.y,\n121              0.\n122            );\n123          }\n124        `,\n125        getJS: (progress, time) => {\n126          let movementProgressFix = 0.02;\n127          let uFreq = xyUniforms.uFreq.value;\n128          let uAmp = xyUniforms.uAmp.value;\n129          let distortion = new THREE.Vector3(\n130            Math.cos(progress * Math.PI * uFreq.x + time) * uAmp.x -\n131            Math.cos(movementProgressFix * Math.PI * uFreq.x + time) * uAmp.x,\n132            Math.sin(progress * Math.PI * uFreq.y + time + Math.PI / 2) * uAmp.y -\n133            Math.sin(movementProgressFix * Math.PI * uFreq.y + time + Math.PI / 2) * uAmp.y,\n134            0\n135          );\n136          let lookAtAmp = new THREE.Vector3(2, 0.4, 1);\n137          let lookAtOffset = new THREE.Vector3(0, 0, -3);\n138          return distortion.multiply(lookAtAmp).add(lookAtOffset);\n139        }\n140      },\n141      LongRaceDistortion: {\n142        uniforms: LongRaceUniforms,\n143        getDistortion: `\n144          uniform vec2 uFreq;\n145          uniform vec2 uAmp;\n146          #define PI 3.14159265358979\n147          vec3 getDistortion(float progress){\n148            float camProgress = 0.0125;\n149            return vec3( \n150              sin(progress * PI * uFreq.x + uTime) * uAmp.x - sin(camProgress * PI * uFreq.x + uTime) * uAmp.x,\n151              sin(progress * PI * uFreq.y + uTime) * uAmp.y - sin(camProgress * PI * uFreq.y + uTime) * uAmp.y,\n152              0.\n153            );\n154          }\n155        `,\n156        getJS: (progress, time) => {\n157          let camProgress = 0.0125;\n158          let uFreq = LongRaceUniforms.uFreq.value;\n159          let uAmp = LongRaceUniforms.uAmp.value;\n160          let distortion = new THREE.Vector3(\n161            Math.sin(progress * Math.PI * uFreq.x + time) * uAmp.x -\n162            Math.sin(camProgress * Math.PI * uFreq.x + time) * uAmp.x,\n163            Math.sin(progress * Math.PI * uFreq.y + time) * uAmp.y -\n164            Math.sin(camProgress * Math.PI * uFreq.y + time) * uAmp.y,\n165            0\n166          );\n167          let lookAtAmp = new THREE.Vector3(1, 1, 0);\n168          let lookAtOffset = new THREE.Vector3(0, 0, -5);\n169          return distortion.multiply(lookAtAmp).add(lookAtOffset);\n170        }\n171      },\n172      turbulentDistortion: {\n173        uniforms: turbulentUniforms,\n174        getDistortion: `\n175          uniform vec4 uFreq;\n176          uniform vec4 uAmp;\n177          float nsin(float val){\n178            return sin(val) * 0.5 + 0.5;\n179          }\n180          #define PI 3.14159265358979\n181          float getDistortionX(float progress){\n182            return (\n183              cos(PI * progress * uFreq.r + uTime) * uAmp.r +\n184              pow(cos(PI * progress * uFreq.g + uTime * (uFreq.g / uFreq.r)), 2. ) * uAmp.g\n185            );\n186          }\n187          float getDistortionY(float progress){\n188            return (\n189              -nsin(PI * progress * uFreq.b + uTime) * uAmp.b +\n190              -pow(nsin(PI * progress * uFreq.a + uTime / (uFreq.b / uFreq.a)), 5.) * uAmp.a\n191            );\n192          }\n193          vec3 getDistortion(float progress){\n194            return vec3(\n195              getDistortionX(progress) - getDistortionX(0.0125),\n196              getDistortionY(progress) - getDistortionY(0.0125),\n197              0.\n198            );\n199          }\n200        `,\n201        getJS: (progress, time) => {\n202          const uFreq = turbulentUniforms.uFreq.value;\n203          const uAmp = turbulentUniforms.uAmp.value;\n204\n205          const getX = p =>\n206            Math.cos(Math.PI * p * uFreq.x + time) * uAmp.x +\n207            Math.pow(Math.cos(Math.PI * p * uFreq.y + time * (uFreq.y / uFreq.x)), 2) * uAmp.y;\n208\n209          const getY = p =>\n210            -nsin(Math.PI * p * uFreq.z + time) * uAmp.z -\n211            Math.pow(nsin(Math.PI * p * uFreq.w + time / (uFreq.z / uFreq.w)), 5) * uAmp.w;\n212\n213          let distortion = new THREE.Vector3(\n214            getX(progress) - getX(progress + 0.007),\n215            getY(progress) - getY(progress + 0.007),\n216            0\n217          );\n218          let lookAtAmp = new THREE.Vector3(-2, -5, 0);\n219          let lookAtOffset = new THREE.Vector3(0, 0, -10);\n220          return distortion.multiply(lookAtAmp).add(lookAtOffset);\n221        }\n222      },\n223      turbulentDistortionStill: {\n224        uniforms: turbulentUniforms,\n225        getDistortion: `\n226          uniform vec4 uFreq;\n227          uniform vec4 uAmp;\n228          float nsin(float val){\n229            return sin(val) * 0.5 + 0.5;\n230          }\n231          #define PI 3.14159265358979\n232          float getDistortionX(float progress){\n233            return (\n234              cos(PI * progress * uFreq.r) * uAmp.r +\n235              pow(cos(PI * progress * uFreq.g * (uFreq.g / uFreq.r)), 2. ) * uAmp.g\n236            );\n237          }\n238          float getDistortionY(float progress){\n239            return (\n240              -nsin(PI * progress * uFreq.b) * uAmp.b +\n241              -pow(nsin(PI * progress * uFreq.a / (uFreq.b / uFreq.a)), 5.) * uAmp.a\n242            );\n243          }\n244          vec3 getDistortion(float progress){\n245            return vec3(\n246              getDistortionX(progress) - getDistortionX(0.02),\n247              getDistortionY(progress) - getDistortionY(0.02),\n248              0.\n249            );\n250          }\n251        `\n252      },\n253      deepDistortionStill: {\n254        uniforms: deepUniforms,\n255        getDistortion: `\n256          uniform vec4 uFreq;\n257          uniform vec4 uAmp;\n258          uniform vec2 uPowY;\n259          float nsin(float val){\n260            return sin(val) * 0.5 + 0.5;\n261          }\n262          #define PI 3.14159265358979\n263          float getDistortionX(float progress){\n264            return (\n265              sin(progress * PI * uFreq.x) * uAmp.x * 2.\n266            );\n267          }\n268          float getDistortionY(float progress){\n269            return (\n270              pow(abs(progress * uPowY.x), uPowY.y) + sin(progress * PI * uFreq.y) * uAmp.y\n271            );\n272          }\n273          vec3 getDistortion(float progress){\n274            return vec3(\n275              getDistortionX(progress) - getDistortionX(0.02),\n276              getDistortionY(progress) - getDistortionY(0.05),\n277              0.\n278            );\n279          }\n280        `\n281      },\n282      deepDistortion: {\n283        uniforms: deepUniforms,\n284        getDistortion: `\n285          uniform vec4 uFreq;\n286          uniform vec4 uAmp;\n287          uniform vec2 uPowY;\n288          float nsin(float val){\n289            return sin(val) * 0.5 + 0.5;\n290          }\n291          #define PI 3.14159265358979\n292          float getDistortionX(float progress){\n293            return (\n294              sin(progress * PI * uFreq.x + uTime) * uAmp.x\n295            );\n296          }\n297          float getDistortionY(float progress){\n298            return (\n299              pow(abs(progress * uPowY.x), uPowY.y) + sin(progress * PI * uFreq.y + uTime) * uAmp.y\n300            );\n301          }\n302          vec3 getDistortion(float progress){\n303            return vec3(\n304              getDistortionX(progress) - getDistortionX(0.02),\n305              getDistortionY(progress) - getDistortionY(0.02),\n306              0.\n307            );\n308          }\n309        `,\n310        getJS: (progress, time) => {\n311          const uFreq = deepUniforms.uFreq.value;\n312          const uAmp = deepUniforms.uAmp.value;\n313          const uPowY = deepUniforms.uPowY.value;\n314\n315          const getX = p => Math.sin(p * Math.PI * uFreq.x + time) * uAmp.x;\n316          const getY = p =>\n317            Math.pow(p * uPowY.x, uPowY.y) +\n318            Math.sin(p * Math.PI * uFreq.y + time) * uAmp.y;\n319\n320          let distortion = new THREE.Vector3(\n321            getX(progress) - getX(progress + 0.01),\n322            getY(progress) - getY(progress + 0.01),\n323            0\n324          );\n325          let lookAtAmp = new THREE.Vector3(-2, -4, 0);\n326          let lookAtOffset = new THREE.Vector3(0, 0, -10);\n327          return distortion.multiply(lookAtAmp).add(lookAtOffset);\n328        }\n329      }\n330    }\n331\n332    class App {\n333      constructor(container, options = {}) {\n334        this.options = options;\n335        if (this.options.distortion == null) {\n336          this.options.distortion = {\n337            uniforms: distortion_uniforms,\n338            getDistortion: distortion_vertex\n339          };\n340        }\n341        this.container = container;\n342        this.renderer = new THREE.WebGLRenderer({\n343          antialias: false,\n344          alpha: true\n345        });\n346        this.renderer.setSize(container.offsetWidth, container.offsetHeight, false);\n347        this.renderer.setPixelRatio(window.devicePixelRatio);\n348        this.composer = new EffectComposer(this.renderer);\n349        container.append(this.renderer.domElement);\n350\n351        this.camera = new THREE.PerspectiveCamera(\n352          options.fov,\n353          container.offsetWidth / container.offsetHeight,\n354          0.1,\n355          10000\n356        );\n357        this.camera.position.z = -5;\n358        this.camera.position.y = 8;\n359        this.camera.position.x = 0;\n360        this.scene = new THREE.Scene();\n361        this.scene.background = null;  // Ensure scene background is transparent\n362\n363        let fog = new THREE.Fog(\n364          options.colors.background,\n365          options.length * 0.2,\n366          options.length * 500\n367        );\n368        this.scene.fog = fog;\n369        this.fogUniforms = {\n370          fogColor: { value: fog.color },\n371          fogNear: { value: fog.near },\n372          fogFar: { value: fog.far }\n373        };\n374        this.clock = new THREE.Clock();\n375        this.assets = {};\n376        this.disposed = false;\n377\n378        this.road = new Road(this, options);\n379        this.leftCarLights = new CarLights(\n380          this,\n381          options,\n382          options.colors.leftCars,\n383          options.movingAwaySpeed,\n384          new THREE.Vector2(0, 1 - options.carLightsFade)\n385        );\n386        this.rightCarLights = new CarLights(\n387          this,\n388          options,\n389          options.colors.rightCars,\n390          options.movingCloserSpeed,\n391          new THREE.Vector2(1, 0 + options.carLightsFade)\n392        );\n393        this.leftSticks = new LightsSticks(this, options);\n394\n395        this.fovTarget = options.fov;\n396        this.speedUpTarget = 0;\n397        this.speedUp = 0;\n398        this.timeOffset = 0;\n399\n400        this.tick = this.tick.bind(this);\n401        this.init = this.init.bind(this);\n402        this.setSize = this.setSize.bind(this);\n403        this.onMouseDown = this.onMouseDown.bind(this);\n404        this.onMouseUp = this.onMouseUp.bind(this);\n405\n406        window.addEventListener(\"resize\", this.onWindowResize.bind(this));\n407      }\n408\n409      onWindowResize() {\n410        const width = this.container.offsetWidth;\n411        const height = this.container.offsetHeight;\n412\n413        this.renderer.setSize(width, height);\n414        this.camera.aspect = width / height;\n415        this.camera.updateProjectionMatrix();\n416        this.composer.setSize(width, height);\n417      }\n418\n419      initPasses() {\n420        this.renderPass = new RenderPass(this.scene, this.camera);\n421        this.bloomPass = new EffectPass(\n422          this.camera,\n423          new BloomEffect({\n424            luminanceThreshold: 0.2,\n425            luminanceSmoothing: 0,\n426            resolutionScale: 1\n427          })\n428        );\n429\n430        const smaaPass = new EffectPass(\n431          this.camera,\n432          new SMAAEffect({\n433            preset: SMAAPreset.MEDIUM,\n434            searchImage: SMAAEffect.searchImageDataURL,\n435            areaImage: SMAAEffect.areaImageDataURL\n436          })\n437        );\n438        this.renderPass.renderToScreen = false;\n439        this.bloomPass.renderToScreen = false;\n440        smaaPass.renderToScreen = true;\n441        this.composer.addPass(this.renderPass);\n442        this.composer.addPass(this.bloomPass);\n443        this.composer.addPass(smaaPass);\n444      }\n445\n446      loadAssets() {\n447        const assets = this.assets;\n448        return new Promise((resolve) => {\n449          const manager = new THREE.LoadingManager(resolve);\n450\n451          const searchImage = new Image();\n452          const areaImage = new Image();\n453          assets.smaa = {};\n454          searchImage.addEventListener(\"load\", function () {\n455            assets.smaa.search = this;\n456            manager.itemEnd(\"smaa-search\");\n457          });\n458\n459          areaImage.addEventListener(\"load\", function () {\n460            assets.smaa.area = this;\n461            manager.itemEnd(\"smaa-area\");\n462          });\n463          manager.itemStart(\"smaa-search\");\n464          manager.itemStart(\"smaa-area\");\n465\n466          searchImage.src = SMAAEffect.searchImageDataURL;\n467          areaImage.src = SMAAEffect.areaImageDataURL;\n468        });\n469      }\n470\n471      init() {\n472        this.initPasses();\n473        const options = this.options;\n474        this.road.init();\n475        this.leftCarLights.init();\n476\n477        this.leftCarLights.mesh.position.setX(\n478          -options.roadWidth / 2 - options.islandWidth / 2\n479        );\n480        this.rightCarLights.init();\n481        this.rightCarLights.mesh.position.setX(\n482          options.roadWidth / 2 + options.islandWidth / 2\n483        );\n484        this.leftSticks.init();\n485        this.leftSticks.mesh.position.setX(\n486          -(options.roadWidth + options.islandWidth / 2)\n487        );\n488\n489        this.container.addEventListener(\"mousedown\", this.onMouseDown);\n490        this.container.addEventListener(\"mouseup\", this.onMouseUp);\n491        this.container.addEventListener(\"mouseout\", this.onMouseUp);\n492\n493        this.tick();\n494      }\n495\n496      onMouseDown(ev) {\n497        if (this.options.onSpeedUp) this.options.onSpeedUp(ev);\n498        this.fovTarget = this.options.fovSpeedUp;\n499        this.speedUpTarget = this.options.speedUp;\n500      }\n501\n502      onMouseUp(ev) {\n503        if (this.options.onSlowDown) this.options.onSlowDown(ev);\n504        this.fovTarget = this.options.fov;\n505        this.speedUpTarget = 0;\n506      }\n507\n508      update(delta) {\n509        let lerpPercentage = Math.exp(-(-60 * Math.log2(1 - 0.1)) * delta);\n510        this.speedUp += lerp(\n511          this.speedUp,\n512          this.speedUpTarget,\n513          lerpPercentage,\n514          0.00001\n515        );\n516        this.timeOffset += this.speedUp * delta;\n517\n518        let time = this.clock.elapsedTime + this.timeOffset;\n519\n520        this.rightCarLights.update(time);\n521        this.leftCarLights.update(time);\n522        this.leftSticks.update(time);\n523        this.road.update(time);\n524\n525        let updateCamera = false;\n526        let fovChange = lerp(this.camera.fov, this.fovTarget, lerpPercentage);\n527        if (fovChange !== 0) {\n528          this.camera.fov += fovChange * delta * 6;\n529          updateCamera = true;\n530        }\n531\n532        if (this.options.distortion.getJS) {\n533          const distortion = this.options.distortion.getJS(0.025, time);\n534\n535          this.camera.lookAt(\n536            new THREE.Vector3(\n537              this.camera.position.x + distortion.x,\n538              this.camera.position.y + distortion.y,\n539              this.camera.position.z + distortion.z\n540            )\n541          );\n542          updateCamera = true;\n543        }\n544        if (updateCamera) {\n545          this.camera.updateProjectionMatrix();\n546        }\n547\n548        if (this.options.isHyper) {\n549          console.log(this.options.isHyper);\n550        }\n551      }\n552\n553      render(delta) {\n554        this.composer.render(delta);\n555      }\n556\n557      dispose() {\n558        this.disposed = true;\n559      }\n560\n561      setSize(width, height, updateStyles) {\n562        this.composer.setSize(width, height, updateStyles);\n563      }\n564\n565      tick() {\n566        if (this.disposed || !this) return;\n567        if (resizeRendererToDisplaySize(this.renderer, this.setSize)) {\n568          const canvas = this.renderer.domElement;\n569          this.camera.aspect = canvas.clientWidth / canvas.clientHeight;\n570          this.camera.updateProjectionMatrix();\n571        }\n572        const delta = this.clock.getDelta();\n573        this.render(delta);\n574        this.update(delta);\n575        requestAnimationFrame(this.tick);\n576      }\n577    }\n578\n579    const distortion_uniforms = {\n580      uDistortionX: { value: new THREE.Vector2(80, 3) },\n581      uDistortionY: { value: new THREE.Vector2(-40, 2.5) }\n582    };\n583\n584    const distortion_vertex = `\n585      #define PI 3.14159265358979\n586      uniform vec2 uDistortionX;\n587      uniform vec2 uDistortionY;\n588      float nsin(float val){\n589        return sin(val) * 0.5 + 0.5;\n590      }\n591      vec3 getDistortion(float progress){\n592        progress = clamp(progress, 0., 1.);\n593        float xAmp = uDistortionX.r;\n594        float xFreq = uDistortionX.g;\n595        float yAmp = uDistortionY.r;\n596        float yFreq = uDistortionY.g;\n597        return vec3( \n598          xAmp * nsin(progress * PI * xFreq - PI / 2.),\n599          yAmp * nsin(progress * PI * yFreq - PI / 2.),\n600          0.\n601        );\n602      }\n603    `;\n604\n605    const random = base => {\n606      if (Array.isArray(base)) return Math.random() * (base[1] - base[0]) + base[0];\n607      return Math.random() * base;\n608    };\n609\n610    const pickRandom = arr => {\n611      if (Array.isArray(arr)) return arr[Math.floor(Math.random() * arr.length)];\n612      return arr;\n613    };\n614\n615    function lerp(current, target, speed = 0.1, limit = 0.001) {\n616      let change = (target - current) * speed;\n617      if (Math.abs(change) < limit) {\n618        change = target - current;\n619      }\n620      return change;\n621    }\n622\n623    class CarLights {\n624      constructor(webgl, options, colors, speed, fade) {\n625        this.webgl = webgl;\n626        this.options = options;\n627        this.colors = colors;\n628        this.speed = speed;\n629        this.fade = fade;\n630      }\n631\n632      init() {\n633        const options = this.options;\n634        let curve = new THREE.LineCurve3(\n635          new THREE.Vector3(0, 0, 0),\n636          new THREE.Vector3(0, 0, -1)\n637        );\n638        let geometry = new THREE.TubeGeometry(curve, 40, 1, 8, false);\n639\n640        let instanced = new THREE.InstancedBufferGeometry().copy(geometry);\n641        instanced.instanceCount = options.lightPairsPerRoadWay * 2;\n642\n643        let laneWidth = options.roadWidth / options.lanesPerRoad;\n644\n645        let aOffset = [];\n646        let aMetrics = [];\n647        let aColor = [];\n648\n649        let colors = this.colors;\n650        if (Array.isArray(colors)) {\n651          colors = colors.map(c => new THREE.Color(c));\n652        } else {\n653          colors = new THREE.Color(colors);\n654        }\n655\n656        for (let i = 0; i < options.lightPairsPerRoadWay; i++) {\n657          let radius = random(options.carLightsRadius);\n658          let length = random(options.carLightsLength);\n659          let speed = random(this.speed);\n660\n661          let carLane = i % options.lanesPerRoad;  // Fix lane assignment to spread across lanes\n662          let laneX = carLane * laneWidth - options.roadWidth / 2 + laneWidth / 2;\n663\n664          let carWidth = random(options.carWidthPercentage) * laneWidth;\n665          let carShiftX = random(options.carShiftX) * laneWidth;\n666          laneX += carShiftX;\n667\n668          let offsetY = random(options.carFloorSeparation) + radius * 1.3;\n669\n670          let offsetZ = -random(options.length);\n671\n672          aOffset.push(laneX - carWidth / 2);\n673          aOffset.push(offsetY);\n674          aOffset.push(offsetZ);\n675\n676          aOffset.push(laneX + carWidth / 2);\n677          aOffset.push(offsetY);\n678          aOffset.push(offsetZ);\n679\n680          aMetrics.push(radius);\n681          aMetrics.push(length);\n682          aMetrics.push(speed);\n683\n684          aMetrics.push(radius);\n685          aMetrics.push(length);\n686          aMetrics.push(speed);\n687\n688          let color = pickRandom(colors);\n689          aColor.push(color.r);\n690          aColor.push(color.g);\n691          aColor.push(color.b);\n692\n693          aColor.push(color.r);\n694          aColor.push(color.g);\n695          aColor.push(color.b);\n696        }\n697\n698        instanced.setAttribute(\n699          \"aOffset\",\n700          new THREE.InstancedBufferAttribute(new Float32Array(aOffset), 3, false)\n701        );\n702        instanced.setAttribute(\n703          \"aMetrics\",\n704          new THREE.InstancedBufferAttribute(new Float32Array(aMetrics), 3, false)\n705        );\n706        instanced.setAttribute(\n707          \"aColor\",\n708          new THREE.InstancedBufferAttribute(new Float32Array(aColor), 3, false)\n709        );\n710\n711        let material = new THREE.ShaderMaterial({\n712          fragmentShader: carLightsFragment,\n713          vertexShader: carLightsVertex,\n714          transparent: true,\n715          uniforms: Object.assign(\n716            {\n717              uTime: { value: 0 },\n718              uTravelLength: { value: options.length },\n719              uFade: { value: this.fade }\n720            },\n721            this.webgl.fogUniforms,\n722            options.distortion.uniforms\n723          )\n724        });\n725\n726        material.onBeforeCompile = shader => {\n727          shader.vertexShader = shader.vertexShader.replace(\n728            \"#include <getDistortion_vertex>\",\n729            options.distortion.getDistortion\n730          );\n731        };\n732\n733        let mesh = new THREE.Mesh(instanced, material);\n734        mesh.frustumCulled = false;\n735        this.webgl.scene.add(mesh);\n736        this.mesh = mesh;\n737      }\n738\n739      update(time) {\n740        this.mesh.material.uniforms.uTime.value = time;\n741      }\n742    }\n743\n744    const carLightsFragment = `\n745      #define USE_FOG;\n746      ${THREE.ShaderChunk[\"fog_pars_fragment\"]}\n747      varying vec3 vColor;\n748      varying vec2 vUv; \n749      uniform vec2 uFade;\n750      void main() {\n751        vec3 color = vec3(vColor);\n752        float alpha = smoothstep(uFade.x, uFade.y, vUv.x);\n753        gl_FragColor = vec4(color, alpha);\n754        if (gl_FragColor.a < 0.0001) discard;\n755        ${THREE.ShaderChunk[\"fog_fragment\"]}\n756      }\n757    `;\n758\n759    const carLightsVertex = `\n760      #define USE_FOG;\n761      ${THREE.ShaderChunk[\"fog_pars_vertex\"]}\n762      attribute vec3 aOffset;\n763      attribute vec3 aMetrics;\n764      attribute vec3 aColor;\n765      uniform float uTravelLength;\n766      uniform float uTime;\n767      varying vec2 vUv; \n768      varying vec3 vColor; \n769      #include <getDistortion_vertex>\n770      void main() {\n771        vec3 transformed = position.xyz;\n772        float radius = aMetrics.r;\n773        float myLength = aMetrics.g;\n774        float speed = aMetrics.b;\n775\n776        transformed.xy *= radius;\n777        transformed.z *= myLength;\n778\n779        transformed.z += myLength - mod(uTime * speed + aOffset.z, uTravelLength);\n780        transformed.xy += aOffset.xy;\n781\n782        float progress = abs(transformed.z / uTravelLength);\n783        transformed.xyz += getDistortion(progress);\n784\n785        vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.);\n786        gl_Position = projectionMatrix * mvPosition;\n787        vUv = uv;\n788        vColor = aColor;\n789        ${THREE.ShaderChunk[\"fog_vertex\"]}\n790      }\n791    `;\n792\n793    class LightsSticks {\n794      constructor(webgl, options) {\n795        this.webgl = webgl;\n796        this.options = options;\n797      }\n798\n799      init() {\n800        const options = this.options;\n801        const geometry = new THREE.PlaneGeometry(1, 1);\n802        let instanced = new THREE.InstancedBufferGeometry().copy(geometry);\n803        let totalSticks = options.totalSideLightSticks;\n804        instanced.instanceCount = totalSticks;\n805\n806        let stickoffset = options.length / (totalSticks - 1);\n807        const aOffset = [];\n808        const aColor = [];\n809        const aMetrics = [];\n810\n811        let colors = options.colors.sticks;\n812        if (Array.isArray(colors)) {\n813          colors = colors.map(c => new THREE.Color(c));\n814        } else {\n815          colors = new THREE.Color(colors);\n816        }\n817\n818        for (let i = 0; i < totalSticks; i++) {\n819          let width = random(options.lightStickWidth);\n820          let height = random(options.lightStickHeight);\n821          aOffset.push((i - 1) * stickoffset * 2 + stickoffset * Math.random());\n822\n823          let color = pickRandom(colors);\n824          aColor.push(color.r);\n825          aColor.push(color.g);\n826          aColor.push(color.b);\n827\n828          aMetrics.push(width);\n829          aMetrics.push(height);\n830        }\n831\n832        instanced.setAttribute(\n833          \"aOffset\",\n834          new THREE.InstancedBufferAttribute(new Float32Array(aOffset), 1, false)\n835        );\n836        instanced.setAttribute(\n837          \"aColor\",\n838          new THREE.InstancedBufferAttribute(new Float32Array(aColor), 3, false)\n839        );\n840        instanced.setAttribute(\n841          \"aMetrics\",\n842          new THREE.InstancedBufferAttribute(new Float32Array(aMetrics), 2, false)\n843        );\n844\n845        const material = new THREE.ShaderMaterial({\n846          fragmentShader: sideSticksFragment,\n847          vertexShader: sideSticksVertex,\n848          side: THREE.DoubleSide,\n849          uniforms: Object.assign(\n850            {\n851              uTravelLength: { value: options.length },\n852              uTime: { value: 0 }\n853            },\n854            this.webgl.fogUniforms,\n855            options.distortion.uniforms\n856          )\n857        });\n858\n859        material.onBeforeCompile = shader => {\n860          shader.vertexShader = shader.vertexShader.replace(\n861            \"#include <getDistortion_vertex>\",\n862            options.distortion.getDistortion\n863          );\n864        };\n865\n866        const mesh = new THREE.Mesh(instanced, material);\n867        mesh.frustumCulled = false;\n868        this.webgl.scene.add(mesh);\n869        this.mesh = mesh;\n870      }\n871\n872      update(time) {\n873        this.mesh.material.uniforms.uTime.value = time;\n874      }\n875    }\n876\n877    const sideSticksVertex = `\n878      #define USE_FOG;\n879      ${THREE.ShaderChunk[\"fog_pars_vertex\"]}\n880      attribute float aOffset;\n881      attribute vec3 aColor;\n882      attribute vec2 aMetrics;\n883      uniform float uTravelLength;\n884      uniform float uTime;\n885      varying vec3 vColor;\n886      mat4 rotationY( in float angle ) {\n887        return mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n888                     0,\t\t1.0,\t\t\t 0,\t0,\n889                -sin(angle),\t0,\t\tcos(angle),\t0,\n890                0, \t\t0,\t\t\t\t0,\t1);\n891      }\n892      #include <getDistortion_vertex>\n893      void main(){\n894        vec3 transformed = position.xyz;\n895        float width = aMetrics.x;\n896        float height = aMetrics.y;\n897\n898        transformed.xy *= vec2(width, height);\n899        float time = mod(uTime * 60. * 2. + aOffset, uTravelLength);\n900\n901        transformed = (rotationY(3.14/2.) * vec4(transformed,1.)).xyz;\n902\n903        transformed.z += - uTravelLength + time;\n904\n905        float progress = abs(transformed.z / uTravelLength);\n906        transformed.xyz += getDistortion(progress);\n907\n908        transformed.y += height / 2.;\n909        transformed.x += -width / 2.;\n910        vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.);\n911        gl_Position = projectionMatrix * mvPosition;\n912        vColor = aColor;\n913        ${THREE.ShaderChunk[\"fog_vertex\"]}\n914      }\n915    `;\n916\n917    const sideSticksFragment = `\n918      #define USE_FOG;\n919      ${THREE.ShaderChunk[\"fog_pars_fragment\"]}\n920      varying vec3 vColor;\n921      void main(){\n922        vec3 color = vec3(vColor);\n923        gl_FragColor = vec4(color,1.);\n924        ${THREE.ShaderChunk[\"fog_fragment\"]}\n925      }\n926    `;\n927\n928    class Road {\n929      constructor(webgl, options) {\n930        this.webgl = webgl;\n931        this.options = options;\n932        this.uTime = { value: 0 };\n933      }\n934\n935      createPlane(side, width, isRoad) {\n936        const options = this.options;\n937        let segments = 100;\n938        const geometry = new THREE.PlaneGeometry(\n939          isRoad ? options.roadWidth : options.islandWidth,\n940          options.length,\n941          20,\n942          segments\n943        );\n944        let uniforms = {\n945          uTravelLength: { value: options.length },\n946          uColor: { value: new THREE.Color(isRoad ? options.colors.roadColor : options.colors.islandColor) },\n947          uTime: this.uTime\n948        };\n949\n950        if (isRoad) {\n951          uniforms = Object.assign(uniforms, {\n952            uLanes: { value: options.lanesPerRoad },\n953            uBrokenLinesColor: { value: new THREE.Color(options.colors.brokenLines) },\n954            uShoulderLinesColor: { value: new THREE.Color(options.colors.shoulderLines) },\n955            uShoulderLinesWidthPercentage: { value: options.shoulderLinesWidthPercentage },\n956            uBrokenLinesLengthPercentage: { value: options.brokenLinesLengthPercentage },\n957            uBrokenLinesWidthPercentage: { value: options.brokenLinesWidthPercentage }\n958          });\n959        }\n960\n961        const material = new THREE.ShaderMaterial({\n962          fragmentShader: isRoad ? roadFragment : islandFragment,\n963          vertexShader: roadVertex,\n964          side: THREE.DoubleSide,\n965          uniforms: Object.assign(\n966            uniforms,\n967            this.webgl.fogUniforms,\n968            options.distortion.uniforms\n969          )\n970        });\n971\n972        material.onBeforeCompile = shader => {\n973          shader.vertexShader = shader.vertexShader.replace(\n974            \"#include <getDistortion_vertex>\",\n975            options.distortion.getDistortion\n976          );\n977        };\n978\n979        const mesh = new THREE.Mesh(geometry, material);\n980        mesh.rotation.x = -Math.PI / 2;\n981        mesh.position.z = -options.length / 2;\n982        mesh.position.x +=\n983          (this.options.islandWidth / 2 + options.roadWidth / 2) * side;\n984        this.webgl.scene.add(mesh);\n985\n986        return mesh;\n987      }\n988\n989      init() {\n990        this.leftRoadWay = this.createPlane(-1, this.options.roadWidth, true);\n991        this.rightRoadWay = this.createPlane(1, this.options.roadWidth, true);\n992        this.island = this.createPlane(0, this.options.islandWidth, false);\n993      }\n994\n995      update(time) {\n996        this.uTime.value = time;\n997      }\n998    }\n999\n1000    const roadBaseFragment = `\n1001      #define USE_FOG;\n1002      varying vec2 vUv; \n1003      uniform vec3 uColor;\n1004      uniform float uTime;\n1005      #include <roadMarkings_vars>\n1006      ${THREE.ShaderChunk[\"fog_pars_fragment\"]}\n1007      void main() {\n1008        vec2 uv = vUv;\n1009        vec3 color = vec3(uColor);\n1010        #include <roadMarkings_fragment>\n1011        gl_FragColor = vec4(color, 1.);\n1012        ${THREE.ShaderChunk[\"fog_fragment\"]}\n1013      }\n1014    `;\n1015\n1016    const islandFragment = roadBaseFragment\n1017      .replace(\"#include <roadMarkings_fragment>\", \"\")\n1018      .replace(\"#include <roadMarkings_vars>\", \"\");\n1019\n1020    const roadMarkings_vars = `\n1021      uniform float uLanes;\n1022      uniform vec3 uBrokenLinesColor;\n1023      uniform vec3 uShoulderLinesColor;\n1024      uniform float uShoulderLinesWidthPercentage;\n1025      uniform float uBrokenLinesWidthPercentage;\n1026      uniform float uBrokenLinesLengthPercentage;\n1027      highp float random(vec2 co) {\n1028        highp float a = 12.9898;\n1029        highp float b = 78.233;\n1030        highp float c = 43758.5453;\n1031        highp float dt = dot(co.xy, vec2(a, b));\n1032        highp float sn = mod(dt, 3.14);\n1033        return fract(sin(sn) * c);\n1034      }\n1035    `;\n1036\n1037    const roadMarkings_fragment = `\n1038      uv.y = mod(uv.y + uTime * 0.05, 1.);  // Adjust speed of markings\n1039      float laneWidth = 1.0 / uLanes;\n1040      float brokenLineWidth = laneWidth * uBrokenLinesWidthPercentage;\n1041      float laneEmptySpace = 1. - uBrokenLinesLengthPercentage;\n1042\n1043      float brokenLines = step(1.0 - brokenLineWidth, fract(uv.x * 2.0)) * step(laneEmptySpace, fract(uv.y * 10.0));  // Dashes in the middle\n1044      float sideLines = step(1.0 - brokenLineWidth, fract((uv.x - laneWidth * (uLanes - 1.0)) * 2.0)) + step(brokenLineWidth, uv.x); // Side continuous lines\n1045\n1046      brokenLines = mix(brokenLines, sideLines, uv.x);\n1047      // color = mix(color, uBrokenLinesColor, brokenLines);\n1048\n1049      // vec2 noiseFreq = vec2(4., 7000.);\n1050      // float roadNoise = random(floor(uv * noiseFreq) / noiseFreq) * 0.02 - 0.01; \n1051      // color += roadNoise;\n1052    `;\n1053\n1054    const roadFragment = roadBaseFragment\n1055      .replace(\"#include <roadMarkings_fragment>\", roadMarkings_fragment)\n1056      .replace(\"#include <roadMarkings_vars>\", roadMarkings_vars);\n1057\n1058    const roadVertex = `\n1059      #define USE_FOG;\n1060      uniform float uTime;\n1061      ${THREE.ShaderChunk[\"fog_pars_vertex\"]}\n1062      uniform float uTravelLength;\n1063      varying vec2 vUv; \n1064      #include <getDistortion_vertex>\n1065      void main() {\n1066        vec3 transformed = position.xyz;\n1067        vec3 distortion = getDistortion((transformed.y + uTravelLength / 2.) / uTravelLength);\n1068        transformed.x += distortion.x;\n1069        transformed.z += distortion.y;\n1070        transformed.y += -1. * distortion.z;  \n1071        \n1072        vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.);\n1073        gl_Position = projectionMatrix * mvPosition;\n1074        vUv = uv;\n1075        ${THREE.ShaderChunk[\"fog_vertex\"]}\n1076      }\n1077    `;\n1078\n1079    function resizeRendererToDisplaySize(renderer, setSize) {\n1080      const canvas = renderer.domElement;\n1081      const width = canvas.clientWidth;\n1082      const height = canvas.clientHeight;\n1083      const needResize = canvas.width !== width || canvas.height !== height;\n1084      if (needResize) {\n1085        setSize(width, height, false);\n1086      }\n1087      return needResize;\n1088    }\n1089\n1090    (function () {\n1091      const container = document.getElementById('lights');\n1092      effectOptions.distortion = distortions[effectOptions.distortion];\n1093\n1094      const myApp = new App(container, effectOptions);\n1095      myApp.loadAssets().then(myApp.init);\n1096    })();\n1097    // eslint-disable-next-line react-hooks/exhaustive-deps\n1098  }, []);\n1099\n1100  return (\n1101    <div id=\"lights\" ref={hyperspeed}></div>\n1102  );\n1103}\n1104\n1105export default Hyperspeed;\n1106\n\n1#lights {\n2  width: 100%;\n3  height: 100%;\n4  overflow: hidden;\n5  position: absolute;\n6}\n7\n8canvas {\n9  width: 100%;\n10  height: 100%;\n11}\n\n1import { useEffect, useRef } from \"react\";\n2import * as THREE from 'three';\n3import { BloomEffect, EffectComposer, EffectPass, RenderPass, SMAAEffect, SMAAPreset } from 'postprocessing';\n4\n5const Hyperspeed = ({ effectOptions = {\n6  onSpeedUp: () => { },\n7  onSlowDown: () => { },\n8  distortion: 'turbulentDistortion',\n9  length: 400,\n10  roadWidth: 10,\n11  islandWidth: 2,\n12  lanesPerRoad: 4,\n13  fov: 90,\n14  fovSpeedUp: 150,\n15  speedUp: 2,\n16  carLightsFade: 0.4,\n17  totalSideLightSticks: 20,\n18  lightPairsPerRoadWay: 40,\n19  shoulderLinesWidthPercentage: 0.05,\n20  brokenLinesWidthPercentage: 0.1,\n21  brokenLinesLengthPercentage: 0.5,\n22  lightStickWidth: [0.12, 0.5],\n23  lightStickHeight: [1.3, 1.7],\n24  movingAwaySpeed: [60, 80],\n25  movingCloserSpeed: [-120, -160],\n26  carLightsLength: [400 * 0.03, 400 * 0.2],\n27  carLightsRadius: [0.05, 0.14],\n28  carWidthPercentage: [0.3, 0.5],\n29  carShiftX: [-0.8, 0.8],\n30  carFloorSeparation: [0, 5],\n31  colors: {\n32    roadColor: 0x080808,\n33    islandColor: 0x0a0a0a,\n34    background: 0x000000,\n35    shoulderLines: 0xFFFFFF,\n36    brokenLines: 0xFFFFFF,\n37    leftCars: [0xD856BF, 0x6750A2, 0xC247AC],\n38    rightCars: [0x03B3C3, 0x0E5EA5, 0x324555],\n39    sticks: 0x03B3C3,\n40  }\n41} }) => {\n42  const hyperspeed = useRef(null);\n43  useEffect(() => {\n44    const mountainUniforms = {\n45      uFreq: { value: new THREE.Vector3(3, 6, 10) },\n46      uAmp: { value: new THREE.Vector3(30, 30, 20) }\n47    };\n48\n49    const xyUniforms = {\n50      uFreq: { value: new THREE.Vector2(5, 2) },\n51      uAmp: { value: new THREE.Vector2(25, 15) }\n52    };\n53\n54    const LongRaceUniforms = {\n55      uFreq: { value: new THREE.Vector2(2, 3) },\n56      uAmp: { value: new THREE.Vector2(35, 10) }\n57    };\n58\n59    const turbulentUniforms = {\n60      uFreq: { value: new THREE.Vector4(4, 8, 8, 1) },\n61      uAmp: { value: new THREE.Vector4(25, 5, 10, 10) }\n62    };\n63\n64    const deepUniforms = {\n65      uFreq: { value: new THREE.Vector2(4, 8) },\n66      uAmp: { value: new THREE.Vector2(10, 20) },\n67      uPowY: { value: new THREE.Vector2(20, 2) }\n68    };\n69\n70    let nsin = val => Math.sin(val) * 0.5 + 0.5;\n71\n72    const distortions = {\n73      mountainDistortion: {\n74        uniforms: mountainUniforms,\n75        getDistortion: `\n76          uniform vec3 uAmp;\n77          uniform vec3 uFreq;\n78          #define PI 3.14159265358979\n79          float nsin(float val){\n80            return sin(val) * 0.5 + 0.5;\n81          }\n82          vec3 getDistortion(float progress){\n83            float movementProgressFix = 0.02;\n84            return vec3( \n85              cos(progress * PI * uFreq.x + uTime) * uAmp.x - cos(movementProgressFix * PI * uFreq.x + uTime) * uAmp.x,\n86              nsin(progress * PI * uFreq.y + uTime) * uAmp.y - nsin(movementProgressFix * PI * uFreq.y + uTime) * uAmp.y,\n87              nsin(progress * PI * uFreq.z + uTime) * uAmp.z - nsin(movementProgressFix * PI * uFreq.z + uTime) * uAmp.z\n88            );\n89          }\n90        `,\n91        getJS: (progress, time) => {\n92          let movementProgressFix = 0.02;\n93          let uFreq = mountainUniforms.uFreq.value;\n94          let uAmp = mountainUniforms.uAmp.value;\n95          let distortion = new THREE.Vector3(\n96            Math.cos(progress * Math.PI * uFreq.x + time) * uAmp.x -\n97            Math.cos(movementProgressFix * Math.PI * uFreq.x + time) * uAmp.x,\n98            nsin(progress * Math.PI * uFreq.y + time) * uAmp.y -\n99            nsin(movementProgressFix * Math.PI * uFreq.y + time) * uAmp.y,\n100            nsin(progress * Math.PI * uFreq.z + time) * uAmp.z -\n101            nsin(movementProgressFix * Math.PI * uFreq.z + time) * uAmp.z\n102          );\n103          let lookAtAmp = new THREE.Vector3(2, 2, 2);\n104          let lookAtOffset = new THREE.Vector3(0, 0, -5);\n105          return distortion.multiply(lookAtAmp).add(lookAtOffset);\n106        }\n107      },\n108      xyDistortion: {\n109        uniforms: xyUniforms,\n110        getDistortion: `\n111          uniform vec2 uFreq;\n112          uniform vec2 uAmp;\n113          #define PI 3.14159265358979\n114          vec3 getDistortion(float progress){\n115            float movementProgressFix = 0.02;\n116            return vec3( \n117              cos(progress * PI * uFreq.x + uTime) * uAmp.x - cos(movementProgressFix * PI * uFreq.x + uTime) * uAmp.x,\n118              sin(progress * PI * uFreq.y + PI/2. + uTime) * uAmp.y - sin(movementProgressFix * PI * uFreq.y + PI/2. + uTime) * uAmp.y,\n119              0.\n120            );\n121          }\n122        `,\n123        getJS: (progress, time) => {\n124          let movementProgressFix = 0.02;\n125          let uFreq = xyUniforms.uFreq.value;\n126          let uAmp = xyUniforms.uAmp.value;\n127          let distortion = new THREE.Vector3(\n128            Math.cos(progress * Math.PI * uFreq.x + time) * uAmp.x -\n129            Math.cos(movementProgressFix * Math.PI * uFreq.x + time) * uAmp.x,\n130            Math.sin(progress * Math.PI * uFreq.y + time + Math.PI / 2) * uAmp.y -\n131            Math.sin(movementProgressFix * Math.PI * uFreq.y + time + Math.PI / 2) * uAmp.y,\n132            0\n133          );\n134          let lookAtAmp = new THREE.Vector3(2, 0.4, 1);\n135          let lookAtOffset = new THREE.Vector3(0, 0, -3);\n136          return distortion.multiply(lookAtAmp).add(lookAtOffset);\n137        }\n138      },\n139      LongRaceDistortion: {\n140        uniforms: LongRaceUniforms,\n141        getDistortion: `\n142          uniform vec2 uFreq;\n143          uniform vec2 uAmp;\n144          #define PI 3.14159265358979\n145          vec3 getDistortion(float progress){\n146            float camProgress = 0.0125;\n147            return vec3( \n148              sin(progress * PI * uFreq.x + uTime) * uAmp.x - sin(camProgress * PI * uFreq.x + uTime) * uAmp.x,\n149              sin(progress * PI * uFreq.y + uTime) * uAmp.y - sin(camProgress * PI * uFreq.y + uTime) * uAmp.y,\n150              0.\n151            );\n152          }\n153        `,\n154        getJS: (progress, time) => {\n155          let camProgress = 0.0125;\n156          let uFreq = LongRaceUniforms.uFreq.value;\n157          let uAmp = LongRaceUniforms.uAmp.value;\n158          let distortion = new THREE.Vector3(\n159            Math.sin(progress * Math.PI * uFreq.x + time) * uAmp.x -\n160            Math.sin(camProgress * Math.PI * uFreq.x + time) * uAmp.x,\n161            Math.sin(progress * Math.PI * uFreq.y + time) * uAmp.y -\n162            Math.sin(camProgress * Math.PI * uFreq.y + time) * uAmp.y,\n163            0\n164          );\n165          let lookAtAmp = new THREE.Vector3(1, 1, 0);\n166          let lookAtOffset = new THREE.Vector3(0, 0, -5);\n167          return distortion.multiply(lookAtAmp).add(lookAtOffset);\n168        }\n169      },\n170      turbulentDistortion: {\n171        uniforms: turbulentUniforms,\n172        getDistortion: `\n173          uniform vec4 uFreq;\n174          uniform vec4 uAmp;\n175          float nsin(float val){\n176            return sin(val) * 0.5 + 0.5;\n177          }\n178          #define PI 3.14159265358979\n179          float getDistortionX(float progress){\n180            return (\n181              cos(PI * progress * uFreq.r + uTime) * uAmp.r +\n182              pow(cos(PI * progress * uFreq.g + uTime * (uFreq.g / uFreq.r)), 2. ) * uAmp.g\n183            );\n184          }\n185          float getDistortionY(float progress){\n186            return (\n187              -nsin(PI * progress * uFreq.b + uTime) * uAmp.b +\n188              -pow(nsin(PI * progress * uFreq.a + uTime / (uFreq.b / uFreq.a)), 5.) * uAmp.a\n189            );\n190          }\n191          vec3 getDistortion(float progress){\n192            return vec3(\n193              getDistortionX(progress) - getDistortionX(0.0125),\n194              getDistortionY(progress) - getDistortionY(0.0125),\n195              0.\n196            );\n197          }\n198        `,\n199        getJS: (progress, time) => {\n200          const uFreq = turbulentUniforms.uFreq.value;\n201          const uAmp = turbulentUniforms.uAmp.value;\n202\n203          const getX = p =>\n204            Math.cos(Math.PI * p * uFreq.x + time) * uAmp.x +\n205            Math.pow(Math.cos(Math.PI * p * uFreq.y + time * (uFreq.y / uFreq.x)), 2) * uAmp.y;\n206\n207          const getY = p =>\n208            -nsin(Math.PI * p * uFreq.z + time) * uAmp.z -\n209            Math.pow(nsin(Math.PI * p * uFreq.w + time / (uFreq.z / uFreq.w)), 5) * uAmp.w;\n210\n211          let distortion = new THREE.Vector3(\n212            getX(progress) - getX(progress + 0.007),\n213            getY(progress) - getY(progress + 0.007),\n214            0\n215          );\n216          let lookAtAmp = new THREE.Vector3(-2, -5, 0);\n217          let lookAtOffset = new THREE.Vector3(0, 0, -10);\n218          return distortion.multiply(lookAtAmp).add(lookAtOffset);\n219        }\n220      },\n221      turbulentDistortionStill: {\n222        uniforms: turbulentUniforms,\n223        getDistortion: `\n224          uniform vec4 uFreq;\n225          uniform vec4 uAmp;\n226          float nsin(float val){\n227            return sin(val) * 0.5 + 0.5;\n228          }\n229          #define PI 3.14159265358979\n230          float getDistortionX(float progress){\n231            return (\n232              cos(PI * progress * uFreq.r) * uAmp.r +\n233              pow(cos(PI * progress * uFreq.g * (uFreq.g / uFreq.r)), 2. ) * uAmp.g\n234            );\n235          }\n236          float getDistortionY(float progress){\n237            return (\n238              -nsin(PI * progress * uFreq.b) * uAmp.b +\n239              -pow(nsin(PI * progress * uFreq.a / (uFreq.b / uFreq.a)), 5.) * uAmp.a\n240            );\n241          }\n242          vec3 getDistortion(float progress){\n243            return vec3(\n244              getDistortionX(progress) - getDistortionX(0.02),\n245              getDistortionY(progress) - getDistortionY(0.02),\n246              0.\n247            );\n248          }\n249        `\n250      },\n251      deepDistortionStill: {\n252        uniforms: deepUniforms,\n253        getDistortion: `\n254          uniform vec4 uFreq;\n255          uniform vec4 uAmp;\n256          uniform vec2 uPowY;\n257          float nsin(float val){\n258            return sin(val) * 0.5 + 0.5;\n259          }\n260          #define PI 3.14159265358979\n261          float getDistortionX(float progress){\n262            return (\n263              sin(progress * PI * uFreq.x) * uAmp.x * 2.\n264            );\n265          }\n266          float getDistortionY(float progress){\n267            return (\n268              pow(abs(progress * uPowY.x), uPowY.y) + sin(progress * PI * uFreq.y) * uAmp.y\n269            );\n270          }\n271          vec3 getDistortion(float progress){\n272            return vec3(\n273              getDistortionX(progress) - getDistortionX(0.02),\n274              getDistortionY(progress) - getDistortionY(0.05),\n275              0.\n276            );\n277          }\n278        `\n279      },\n280      deepDistortion: {\n281        uniforms: deepUniforms,\n282        getDistortion: `\n283          uniform vec4 uFreq;\n284          uniform vec4 uAmp;\n285          uniform vec2 uPowY;\n286          float nsin(float val){\n287            return sin(val) * 0.5 + 0.5;\n288          }\n289          #define PI 3.14159265358979\n290          float getDistortionX(float progress){\n291            return (\n292              sin(progress * PI * uFreq.x + uTime) * uAmp.x\n293            );\n294          }\n295          float getDistortionY(float progress){\n296            return (\n297              pow(abs(progress * uPowY.x), uPowY.y) + sin(progress * PI * uFreq.y + uTime) * uAmp.y\n298            );\n299          }\n300          vec3 getDistortion(float progress){\n301            return vec3(\n302              getDistortionX(progress) - getDistortionX(0.02),\n303              getDistortionY(progress) - getDistortionY(0.02),\n304              0.\n305            );\n306          }\n307        `,\n308        getJS: (progress, time) => {\n309          const uFreq = deepUniforms.uFreq.value;\n310          const uAmp = deepUniforms.uAmp.value;\n311          const uPowY = deepUniforms.uPowY.value;\n312\n313          const getX = p => Math.sin(p * Math.PI * uFreq.x + time) * uAmp.x;\n314          const getY = p =>\n315            Math.pow(p * uPowY.x, uPowY.y) +\n316            Math.sin(p * Math.PI * uFreq.y + time) * uAmp.y;\n317\n318          let distortion = new THREE.Vector3(\n319            getX(progress) - getX(progress + 0.01),\n320            getY(progress) - getY(progress + 0.01),\n321            0\n322          );\n323          let lookAtAmp = new THREE.Vector3(-2, -4, 0);\n324          let lookAtOffset = new THREE.Vector3(0, 0, -10);\n325          return distortion.multiply(lookAtAmp).add(lookAtOffset);\n326        }\n327      }\n328    }\n329\n330    class App {\n331      constructor(container, options = {}) {\n332        this.options = options;\n333        if (this.options.distortion == null) {\n334          this.options.distortion = {\n335            uniforms: distortion_uniforms,\n336            getDistortion: distortion_vertex\n337          };\n338        }\n339        this.container = container;\n340        this.renderer = new THREE.WebGLRenderer({\n341          antialias: false,\n342          alpha: true\n343        });\n344        this.renderer.setSize(container.offsetWidth, container.offsetHeight, false);\n345        this.renderer.setPixelRatio(window.devicePixelRatio);\n346        this.composer = new EffectComposer(this.renderer);\n347        container.append(this.renderer.domElement);\n348\n349        this.camera = new THREE.PerspectiveCamera(\n350          options.fov,\n351          container.offsetWidth / container.offsetHeight,\n352          0.1,\n353          10000\n354        );\n355        this.camera.position.z = -5;\n356        this.camera.position.y = 8;\n357        this.camera.position.x = 0;\n358        this.scene = new THREE.Scene();\n359        this.scene.background = null;  // Ensure scene background is transparent\n360\n361        let fog = new THREE.Fog(\n362          options.colors.background,\n363          options.length * 0.2,\n364          options.length * 500\n365        );\n366        this.scene.fog = fog;\n367        this.fogUniforms = {\n368          fogColor: { value: fog.color },\n369          fogNear: { value: fog.near },\n370          fogFar: { value: fog.far }\n371        };\n372        this.clock = new THREE.Clock();\n373        this.assets = {};\n374        this.disposed = false;\n375\n376        this.road = new Road(this, options);\n377        this.leftCarLights = new CarLights(\n378          this,\n379          options,\n380          options.colors.leftCars,\n381          options.movingAwaySpeed,\n382          new THREE.Vector2(0, 1 - options.carLightsFade)\n383        );\n384        this.rightCarLights = new CarLights(\n385          this,\n386          options,\n387          options.colors.rightCars,\n388          options.movingCloserSpeed,\n389          new THREE.Vector2(1, 0 + options.carLightsFade)\n390        );\n391        this.leftSticks = new LightsSticks(this, options);\n392\n393        this.fovTarget = options.fov;\n394        this.speedUpTarget = 0;\n395        this.speedUp = 0;\n396        this.timeOffset = 0;\n397\n398        this.tick = this.tick.bind(this);\n399        this.init = this.init.bind(this);\n400        this.setSize = this.setSize.bind(this);\n401        this.onMouseDown = this.onMouseDown.bind(this);\n402        this.onMouseUp = this.onMouseUp.bind(this);\n403\n404        window.addEventListener(\"resize\", this.onWindowResize.bind(this));\n405      }\n406\n407      onWindowResize() {\n408        const width = this.container.offsetWidth;\n409        const height = this.container.offsetHeight;\n410\n411        this.renderer.setSize(width, height);\n412        this.camera.aspect = width / height;\n413        this.camera.updateProjectionMatrix();\n414        this.composer.setSize(width, height);\n415      }\n416\n417      initPasses() {\n418        this.renderPass = new RenderPass(this.scene, this.camera);\n419        this.bloomPass = new EffectPass(\n420          this.camera,\n421          new BloomEffect({\n422            luminanceThreshold: 0.2,\n423            luminanceSmoothing: 0,\n424            resolutionScale: 1\n425          })\n426        );\n427\n428        const smaaPass = new EffectPass(\n429          this.camera,\n430          new SMAAEffect({\n431            preset: SMAAPreset.MEDIUM,\n432            searchImage: SMAAEffect.searchImageDataURL,\n433            areaImage: SMAAEffect.areaImageDataURL\n434          })\n435        );\n436        this.renderPass.renderToScreen = false;\n437        this.bloomPass.renderToScreen = false;\n438        smaaPass.renderToScreen = true;\n439        this.composer.addPass(this.renderPass);\n440        this.composer.addPass(this.bloomPass);\n441        this.composer.addPass(smaaPass);\n442      }\n443\n444      loadAssets() {\n445        const assets = this.assets;\n446        return new Promise((resolve) => {\n447          const manager = new THREE.LoadingManager(resolve);\n448\n449          const searchImage = new Image();\n450          const areaImage = new Image();\n451          assets.smaa = {};\n452          searchImage.addEventListener(\"load\", function () {\n453            assets.smaa.search = this;\n454            manager.itemEnd(\"smaa-search\");\n455          });\n456\n457          areaImage.addEventListener(\"load\", function () {\n458            assets.smaa.area = this;\n459            manager.itemEnd(\"smaa-area\");\n460          });\n461          manager.itemStart(\"smaa-search\");\n462          manager.itemStart(\"smaa-area\");\n463\n464          searchImage.src = SMAAEffect.searchImageDataURL;\n465          areaImage.src = SMAAEffect.areaImageDataURL;\n466        });\n467      }\n468\n469      init() {\n470        this.initPasses();\n471        const options = this.options;\n472        this.road.init();\n473        this.leftCarLights.init();\n474\n475        this.leftCarLights.mesh.position.setX(\n476          -options.roadWidth / 2 - options.islandWidth / 2\n477        );\n478        this.rightCarLights.init();\n479        this.rightCarLights.mesh.position.setX(\n480          options.roadWidth / 2 + options.islandWidth / 2\n481        );\n482        this.leftSticks.init();\n483        this.leftSticks.mesh.position.setX(\n484          -(options.roadWidth + options.islandWidth / 2)\n485        );\n486\n487        this.container.addEventListener(\"mousedown\", this.onMouseDown);\n488        this.container.addEventListener(\"mouseup\", this.onMouseUp);\n489        this.container.addEventListener(\"mouseout\", this.onMouseUp);\n490\n491        this.tick();\n492      }\n493\n494      onMouseDown(ev) {\n495        if (this.options.onSpeedUp) this.options.onSpeedUp(ev);\n496        this.fovTarget = this.options.fovSpeedUp;\n497        this.speedUpTarget = this.options.speedUp;\n498      }\n499\n500      onMouseUp(ev) {\n501        if (this.options.onSlowDown) this.options.onSlowDown(ev);\n502        this.fovTarget = this.options.fov;\n503        this.speedUpTarget = 0;\n504      }\n505\n506      update(delta) {\n507        let lerpPercentage = Math.exp(-(-60 * Math.log2(1 - 0.1)) * delta);\n508        this.speedUp += lerp(\n509          this.speedUp,\n510          this.speedUpTarget,\n511          lerpPercentage,\n512          0.00001\n513        );\n514        this.timeOffset += this.speedUp * delta;\n515\n516        let time = this.clock.elapsedTime + this.timeOffset;\n517\n518        this.rightCarLights.update(time);\n519        this.leftCarLights.update(time);\n520        this.leftSticks.update(time);\n521        this.road.update(time);\n522\n523        let updateCamera = false;\n524        let fovChange = lerp(this.camera.fov, this.fovTarget, lerpPercentage);\n525        if (fovChange !== 0) {\n526          this.camera.fov += fovChange * delta * 6;\n527          updateCamera = true;\n528        }\n529\n530        if (this.options.distortion.getJS) {\n531          const distortion = this.options.distortion.getJS(0.025, time);\n532\n533          this.camera.lookAt(\n534            new THREE.Vector3(\n535              this.camera.position.x + distortion.x,\n536              this.camera.position.y + distortion.y,\n537              this.camera.position.z + distortion.z\n538            )\n539          );\n540          updateCamera = true;\n541        }\n542        if (updateCamera) {\n543          this.camera.updateProjectionMatrix();\n544        }\n545\n546        if (this.options.isHyper) {\n547          console.log(this.options.isHyper);\n548        }\n549      }\n550\n551      render(delta) {\n552        this.composer.render(delta);\n553      }\n554\n555      dispose() {\n556        this.disposed = true;\n557      }\n558\n559      setSize(width, height, updateStyles) {\n560        this.composer.setSize(width, height, updateStyles);\n561      }\n562\n563      tick() {\n564        if (this.disposed || !this) return;\n565        if (resizeRendererToDisplaySize(this.renderer, this.setSize)) {\n566          const canvas = this.renderer.domElement;\n567          this.camera.aspect = canvas.clientWidth / canvas.clientHeight;\n568          this.camera.updateProjectionMatrix();\n569        }\n570        const delta = this.clock.getDelta();\n571        this.render(delta);\n572        this.update(delta);\n573        requestAnimationFrame(this.tick);\n574      }\n575    }\n576\n577    const distortion_uniforms = {\n578      uDistortionX: { value: new THREE.Vector2(80, 3) },\n579      uDistortionY: { value: new THREE.Vector2(-40, 2.5) }\n580    };\n581\n582    const distortion_vertex = `\n583      #define PI 3.14159265358979\n584      uniform vec2 uDistortionX;\n585      uniform vec2 uDistortionY;\n586      float nsin(float val){\n587        return sin(val) * 0.5 + 0.5;\n588      }\n589      vec3 getDistortion(float progress){\n590        progress = clamp(progress, 0., 1.);\n591        float xAmp = uDistortionX.r;\n592        float xFreq = uDistortionX.g;\n593        float yAmp = uDistortionY.r;\n594        float yFreq = uDistortionY.g;\n595        return vec3( \n596          xAmp * nsin(progress * PI * xFreq - PI / 2.),\n597          yAmp * nsin(progress * PI * yFreq - PI / 2.),\n598          0.\n599        );\n600      }\n601    `;\n602\n603    const random = base => {\n604      if (Array.isArray(base)) return Math.random() * (base[1] - base[0]) + base[0];\n605      return Math.random() * base;\n606    };\n607\n608    const pickRandom = arr => {\n609      if (Array.isArray(arr)) return arr[Math.floor(Math.random() * arr.length)];\n610      return arr;\n611    };\n612\n613    function lerp(current, target, speed = 0.1, limit = 0.001) {\n614      let change = (target - current) * speed;\n615      if (Math.abs(change) < limit) {\n616        change = target - current;\n617      }\n618      return change;\n619    }\n620\n621    class CarLights {\n622      constructor(webgl, options, colors, speed, fade) {\n623        this.webgl = webgl;\n624        this.options = options;\n625        this.colors = colors;\n626        this.speed = speed;\n627        this.fade = fade;\n628      }\n629\n630      init() {\n631        const options = this.options;\n632        let curve = new THREE.LineCurve3(\n633          new THREE.Vector3(0, 0, 0),\n634          new THREE.Vector3(0, 0, -1)\n635        );\n636        let geometry = new THREE.TubeGeometry(curve, 40, 1, 8, false);\n637\n638        let instanced = new THREE.InstancedBufferGeometry().copy(geometry);\n639        instanced.instanceCount = options.lightPairsPerRoadWay * 2;\n640\n641        let laneWidth = options.roadWidth / options.lanesPerRoad;\n642\n643        let aOffset = [];\n644        let aMetrics = [];\n645        let aColor = [];\n646\n647        let colors = this.colors;\n648        if (Array.isArray(colors)) {\n649          colors = colors.map(c => new THREE.Color(c));\n650        } else {\n651          colors = new THREE.Color(colors);\n652        }\n653\n654        for (let i = 0; i < options.lightPairsPerRoadWay; i++) {\n655          let radius = random(options.carLightsRadius);\n656          let length = random(options.carLightsLength);\n657          let speed = random(this.speed);\n658\n659          let carLane = i % options.lanesPerRoad;  // Fix lane assignment to spread across lanes\n660          let laneX = carLane * laneWidth - options.roadWidth / 2 + laneWidth / 2;\n661\n662          let carWidth = random(options.carWidthPercentage) * laneWidth;\n663          let carShiftX = random(options.carShiftX) * laneWidth;\n664          laneX += carShiftX;\n665\n666          let offsetY = random(options.carFloorSeparation) + radius * 1.3;\n667\n668          let offsetZ = -random(options.length);\n669\n670          aOffset.push(laneX - carWidth / 2);\n671          aOffset.push(offsetY);\n672          aOffset.push(offsetZ);\n673\n674          aOffset.push(laneX + carWidth / 2);\n675          aOffset.push(offsetY);\n676          aOffset.push(offsetZ);\n677\n678          aMetrics.push(radius);\n679          aMetrics.push(length);\n680          aMetrics.push(speed);\n681\n682          aMetrics.push(radius);\n683          aMetrics.push(length);\n684          aMetrics.push(speed);\n685\n686          let color = pickRandom(colors);\n687          aColor.push(color.r);\n688          aColor.push(color.g);\n689          aColor.push(color.b);\n690\n691          aColor.push(color.r);\n692          aColor.push(color.g);\n693          aColor.push(color.b);\n694        }\n695\n696        instanced.setAttribute(\n697          \"aOffset\",\n698          new THREE.InstancedBufferAttribute(new Float32Array(aOffset), 3, false)\n699        );\n700        instanced.setAttribute(\n701          \"aMetrics\",\n702          new THREE.InstancedBufferAttribute(new Float32Array(aMetrics), 3, false)\n703        );\n704        instanced.setAttribute(\n705          \"aColor\",\n706          new THREE.InstancedBufferAttribute(new Float32Array(aColor), 3, false)\n707        );\n708\n709        let material = new THREE.ShaderMaterial({\n710          fragmentShader: carLightsFragment,\n711          vertexShader: carLightsVertex,\n712          transparent: true,\n713          uniforms: Object.assign(\n714            {\n715              uTime: { value: 0 },\n716              uTravelLength: { value: options.length },\n717              uFade: { value: this.fade }\n718            },\n719            this.webgl.fogUniforms,\n720            options.distortion.uniforms\n721          )\n722        });\n723\n724        material.onBeforeCompile = shader => {\n725          shader.vertexShader = shader.vertexShader.replace(\n726            \"#include <getDistortion_vertex>\",\n727            options.distortion.getDistortion\n728          );\n729        };\n730\n731        let mesh = new THREE.Mesh(instanced, material);\n732        mesh.frustumCulled = false;\n733        this.webgl.scene.add(mesh);\n734        this.mesh = mesh;\n735      }\n736\n737      update(time) {\n738        this.mesh.material.uniforms.uTime.value = time;\n739      }\n740    }\n741\n742    const carLightsFragment = `\n743      #define USE_FOG;\n744      ${THREE.ShaderChunk[\"fog_pars_fragment\"]}\n745      varying vec3 vColor;\n746      varying vec2 vUv; \n747      uniform vec2 uFade;\n748      void main() {\n749        vec3 color = vec3(vColor);\n750        float alpha = smoothstep(uFade.x, uFade.y, vUv.x);\n751        gl_FragColor = vec4(color, alpha);\n752        if (gl_FragColor.a < 0.0001) discard;\n753        ${THREE.ShaderChunk[\"fog_fragment\"]}\n754      }\n755    `;\n756\n757    const carLightsVertex = `\n758      #define USE_FOG;\n759      ${THREE.ShaderChunk[\"fog_pars_vertex\"]}\n760      attribute vec3 aOffset;\n761      attribute vec3 aMetrics;\n762      attribute vec3 aColor;\n763      uniform float uTravelLength;\n764      uniform float uTime;\n765      varying vec2 vUv; \n766      varying vec3 vColor; \n767      #include <getDistortion_vertex>\n768      void main() {\n769        vec3 transformed = position.xyz;\n770        float radius = aMetrics.r;\n771        float myLength = aMetrics.g;\n772        float speed = aMetrics.b;\n773\n774        transformed.xy *= radius;\n775        transformed.z *= myLength;\n776\n777        transformed.z += myLength - mod(uTime * speed + aOffset.z, uTravelLength);\n778        transformed.xy += aOffset.xy;\n779\n780        float progress = abs(transformed.z / uTravelLength);\n781        transformed.xyz += getDistortion(progress);\n782\n783        vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.);\n784        gl_Position = projectionMatrix * mvPosition;\n785        vUv = uv;\n786        vColor = aColor;\n787        ${THREE.ShaderChunk[\"fog_vertex\"]}\n788      }\n789    `;\n790\n791    class LightsSticks {\n792      constructor(webgl, options) {\n793        this.webgl = webgl;\n794        this.options = options;\n795      }\n796\n797      init() {\n798        const options = this.options;\n799        const geometry = new THREE.PlaneGeometry(1, 1);\n800        let instanced = new THREE.InstancedBufferGeometry().copy(geometry);\n801        let totalSticks = options.totalSideLightSticks;\n802        instanced.instanceCount = totalSticks;\n803\n804        let stickoffset = options.length / (totalSticks - 1);\n805        const aOffset = [];\n806        const aColor = [];\n807        const aMetrics = [];\n808\n809        let colors = options.colors.sticks;\n810        if (Array.isArray(colors)) {\n811          colors = colors.map(c => new THREE.Color(c));\n812        } else {\n813          colors = new THREE.Color(colors);\n814        }\n815\n816        for (let i = 0; i < totalSticks; i++) {\n817          let width = random(options.lightStickWidth);\n818          let height = random(options.lightStickHeight);\n819          aOffset.push((i - 1) * stickoffset * 2 + stickoffset * Math.random());\n820\n821          let color = pickRandom(colors);\n822          aColor.push(color.r);\n823          aColor.push(color.g);\n824          aColor.push(color.b);\n825\n826          aMetrics.push(width);\n827          aMetrics.push(height);\n828        }\n829\n830        instanced.setAttribute(\n831          \"aOffset\",\n832          new THREE.InstancedBufferAttribute(new Float32Array(aOffset), 1, false)\n833        );\n834        instanced.setAttribute(\n835          \"aColor\",\n836          new THREE.InstancedBufferAttribute(new Float32Array(aColor), 3, false)\n837        );\n838        instanced.setAttribute(\n839          \"aMetrics\",\n840          new THREE.InstancedBufferAttribute(new Float32Array(aMetrics), 2, false)\n841        );\n842\n843        const material = new THREE.ShaderMaterial({\n844          fragmentShader: sideSticksFragment,\n845          vertexShader: sideSticksVertex,\n846          side: THREE.DoubleSide,\n847          uniforms: Object.assign(\n848            {\n849              uTravelLength: { value: options.length },\n850              uTime: { value: 0 }\n851            },\n852            this.webgl.fogUniforms,\n853            options.distortion.uniforms\n854          )\n855        });\n856\n857        material.onBeforeCompile = shader => {\n858          shader.vertexShader = shader.vertexShader.replace(\n859            \"#include <getDistortion_vertex>\",\n860            options.distortion.getDistortion\n861          );\n862        };\n863\n864        const mesh = new THREE.Mesh(instanced, material);\n865        mesh.frustumCulled = false;\n866        this.webgl.scene.add(mesh);\n867        this.mesh = mesh;\n868      }\n869\n870      update(time) {\n871        this.mesh.material.uniforms.uTime.value = time;\n872      }\n873    }\n874\n875    const sideSticksVertex = `\n876      #define USE_FOG;\n877      ${THREE.ShaderChunk[\"fog_pars_vertex\"]}\n878      attribute float aOffset;\n879      attribute vec3 aColor;\n880      attribute vec2 aMetrics;\n881      uniform float uTravelLength;\n882      uniform float uTime;\n883      varying vec3 vColor;\n884      mat4 rotationY( in float angle ) {\n885        return mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n886                     0,\t\t1.0,\t\t\t 0,\t0,\n887                -sin(angle),\t0,\t\tcos(angle),\t0,\n888                0, \t\t0,\t\t\t\t0,\t1);\n889      }\n890      #include <getDistortion_vertex>\n891      void main(){\n892        vec3 transformed = position.xyz;\n893        float width = aMetrics.x;\n894        float height = aMetrics.y;\n895\n896        transformed.xy *= vec2(width, height);\n897        float time = mod(uTime * 60. * 2. + aOffset, uTravelLength);\n898\n899        transformed = (rotationY(3.14/2.) * vec4(transformed,1.)).xyz;\n900\n901        transformed.z += - uTravelLength + time;\n902\n903        float progress = abs(transformed.z / uTravelLength);\n904        transformed.xyz += getDistortion(progress);\n905\n906        transformed.y += height / 2.;\n907        transformed.x += -width / 2.;\n908        vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.);\n909        gl_Position = projectionMatrix * mvPosition;\n910        vColor = aColor;\n911        ${THREE.ShaderChunk[\"fog_vertex\"]}\n912      }\n913    `;\n914\n915    const sideSticksFragment = `\n916      #define USE_FOG;\n917      ${THREE.ShaderChunk[\"fog_pars_fragment\"]}\n918      varying vec3 vColor;\n919      void main(){\n920        vec3 color = vec3(vColor);\n921        gl_FragColor = vec4(color,1.);\n922        ${THREE.ShaderChunk[\"fog_fragment\"]}\n923      }\n924    `;\n925\n926    class Road {\n927      constructor(webgl, options) {\n928        this.webgl = webgl;\n929        this.options = options;\n930        this.uTime = { value: 0 };\n931      }\n932\n933      createPlane(side, width, isRoad) {\n934        const options = this.options;\n935        let segments = 100;\n936        const geometry = new THREE.PlaneGeometry(\n937          isRoad ? options.roadWidth : options.islandWidth,\n938          options.length,\n939          20,\n940          segments\n941        );\n942        let uniforms = {\n943          uTravelLength: { value: options.length },\n944          uColor: { value: new THREE.Color(isRoad ? options.colors.roadColor : options.colors.islandColor) },\n945          uTime: this.uTime\n946        };\n947\n948        if (isRoad) {\n949          uniforms = Object.assign(uniforms, {\n950            uLanes: { value: options.lanesPerRoad },\n951            uBrokenLinesColor: { value: new THREE.Color(options.colors.brokenLines) },\n952            uShoulderLinesColor: { value: new THREE.Color(options.colors.shoulderLines) },\n953            uShoulderLinesWidthPercentage: { value: options.shoulderLinesWidthPercentage },\n954            uBrokenLinesLengthPercentage: { value: options.brokenLinesLengthPercentage },\n955            uBrokenLinesWidthPercentage: { value: options.brokenLinesWidthPercentage }\n956          });\n957        }\n958\n959        const material = new THREE.ShaderMaterial({\n960          fragmentShader: isRoad ? roadFragment : islandFragment,\n961          vertexShader: roadVertex,\n962          side: THREE.DoubleSide,\n963          uniforms: Object.assign(\n964            uniforms,\n965            this.webgl.fogUniforms,\n966            options.distortion.uniforms\n967          )\n968        });\n969\n970        material.onBeforeCompile = shader => {\n971          shader.vertexShader = shader.vertexShader.replace(\n972            \"#include <getDistortion_vertex>\",\n973            options.distortion.getDistortion\n974          );\n975        };\n976\n977        const mesh = new THREE.Mesh(geometry, material);\n978        mesh.rotation.x = -Math.PI / 2;\n979        mesh.position.z = -options.length / 2;\n980        mesh.position.x +=\n981          (this.options.islandWidth / 2 + options.roadWidth / 2) * side;\n982        this.webgl.scene.add(mesh);\n983\n984        return mesh;\n985      }\n986\n987      init() {\n988        this.leftRoadWay = this.createPlane(-1, this.options.roadWidth, true);\n989        this.rightRoadWay = this.createPlane(1, this.options.roadWidth, true);\n990        this.island = this.createPlane(0, this.options.islandWidth, false);\n991      }\n992\n993      update(time) {\n994        this.uTime.value = time;\n995      }\n996    }\n997\n998    const roadBaseFragment = `\n999      #define USE_FOG;\n1000      varying vec2 vUv; \n1001      uniform vec3 uColor;\n1002      uniform float uTime;\n1003      #include <roadMarkings_vars>\n1004      ${THREE.ShaderChunk[\"fog_pars_fragment\"]}\n1005      void main() {\n1006        vec2 uv = vUv;\n1007        vec3 color = vec3(uColor);\n1008        #include <roadMarkings_fragment>\n1009        gl_FragColor = vec4(color, 1.);\n1010        ${THREE.ShaderChunk[\"fog_fragment\"]}\n1011      }\n1012    `;\n1013\n1014    const islandFragment = roadBaseFragment\n1015      .replace(\"#include <roadMarkings_fragment>\", \"\")\n1016      .replace(\"#include <roadMarkings_vars>\", \"\");\n1017\n1018    const roadMarkings_vars = `\n1019      uniform float uLanes;\n1020      uniform vec3 uBrokenLinesColor;\n1021      uniform vec3 uShoulderLinesColor;\n1022      uniform float uShoulderLinesWidthPercentage;\n1023      uniform float uBrokenLinesWidthPercentage;\n1024      uniform float uBrokenLinesLengthPercentage;\n1025      highp float random(vec2 co) {\n1026        highp float a = 12.9898;\n1027        highp float b = 78.233;\n1028        highp float c = 43758.5453;\n1029        highp float dt = dot(co.xy, vec2(a, b));\n1030        highp float sn = mod(dt, 3.14);\n1031        return fract(sin(sn) * c);\n1032      }\n1033    `;\n1034\n1035    const roadMarkings_fragment = `\n1036      uv.y = mod(uv.y + uTime * 0.05, 1.);  // Adjust speed of markings\n1037      float laneWidth = 1.0 / uLanes;\n1038      float brokenLineWidth = laneWidth * uBrokenLinesWidthPercentage;\n1039      float laneEmptySpace = 1. - uBrokenLinesLengthPercentage;\n1040\n1041      float brokenLines = step(1.0 - brokenLineWidth, fract(uv.x * 2.0)) * step(laneEmptySpace, fract(uv.y * 10.0));  // Dashes in the middle\n1042      float sideLines = step(1.0 - brokenLineWidth, fract((uv.x - laneWidth * (uLanes - 1.0)) * 2.0)) + step(brokenLineWidth, uv.x); // Side continuous lines\n1043\n1044      brokenLines = mix(brokenLines, sideLines, uv.x);\n1045      // color = mix(color, uBrokenLinesColor, brokenLines);\n1046\n1047      // vec2 noiseFreq = vec2(4., 7000.);\n1048      // float roadNoise = random(floor(uv * noiseFreq) / noiseFreq) * 0.02 - 0.01; \n1049      // color += roadNoise;\n1050    `;\n1051\n1052    const roadFragment = roadBaseFragment\n1053      .replace(\"#include <roadMarkings_fragment>\", roadMarkings_fragment)\n1054      .replace(\"#include <roadMarkings_vars>\", roadMarkings_vars);\n1055\n1056    const roadVertex = `\n1057      #define USE_FOG;\n1058      uniform float uTime;\n1059      ${THREE.ShaderChunk[\"fog_pars_vertex\"]}\n1060      uniform float uTravelLength;\n1061      varying vec2 vUv; \n1062      #include <getDistortion_vertex>\n1063      void main() {\n1064        vec3 transformed = position.xyz;\n1065        vec3 distortion = getDistortion((transformed.y + uTravelLength / 2.) / uTravelLength);\n1066        transformed.x += distortion.x;\n1067        transformed.z += distortion.y;\n1068        transformed.y += -1. * distortion.z;  \n1069        \n1070        vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.);\n1071        gl_Position = projectionMatrix * mvPosition;\n1072        vUv = uv;\n1073        ${THREE.ShaderChunk[\"fog_vertex\"]}\n1074      }\n1075    `;\n1076\n1077    function resizeRendererToDisplaySize(renderer, setSize) {\n1078      const canvas = renderer.domElement;\n1079      const width = canvas.clientWidth;\n1080      const height = canvas.clientHeight;\n1081      const needResize = canvas.width !== width || canvas.height !== height;\n1082      if (needResize) {\n1083        setSize(width, height, false);\n1084      }\n1085      return needResize;\n1086    }\n1087\n1088    (function () {\n1089      const container = document.getElementById('lights');\n1090      effectOptions.distortion = distortions[effectOptions.distortion];\n1091\n1092      const myApp = new App(container, effectOptions);\n1093      myApp.loadAssets().then(myApp.init);\n1094    })();\n1095    // eslint-disable-next-line react-hooks/exhaustive-deps\n1096  }, []);\n1097\n1098  return (\n1099    <div id=\"lights\" className=\"w-full h-full\" ref={hyperspeed}></div>\n1100  );\n1101}\n1102\n1103export default Hyperspeed;\n1104",
  "category": "backgrounds",
  "scrapedAt": "2025-04-27T11:47:57.951Z",
  "previewImage": "hyperspeed-preview.png"
}