{
  "name": "Orb",
  "description": "An open source collection of high quality, animated, interactive & fully customizable React components for building stunning, memorable user interfaces.",
  "props": {},
  "dependencies": [],
  "url": "https://www.reactbits.dev/backgrounds/orb",
  "code": "1npm i ogl\n\n1import Orb from './Orb';\n2\n3<div style={{ width: '100%', height: '600px', position: 'relative' }}>\n4  <Orb\n5    hoverIntensity={0.5}\n6    rotateOnHover={true}\n7    hue={0}\n8    forceHoverState={false}\n9  />\n10</div>\n\n1import { useEffect, useRef } from \"react\";\n2import { Renderer, Program, Mesh, Triangle, Vec3 } from \"ogl\";\n3\n4import \"./Orb.css\";\n5\n6export default function Orb({\n7  hue = 0,\n8  hoverIntensity = 0.2,\n9  rotateOnHover = true,\n10  forceHoverState = false,\n11}) {\n12  const ctnDom = useRef(null);\n13\n14  const vert = /* glsl */ `\n15    precision highp float;\n16    attribute vec2 position;\n17    attribute vec2 uv;\n18    varying vec2 vUv;\n19    void main() {\n20      vUv = uv;\n21      gl_Position = vec4(position, 0.0, 1.0);\n22    }\n23  `;\n24\n25  const frag = /* glsl */ `\n26    precision highp float;\n27\n28    uniform float iTime;\n29    uniform vec3 iResolution;\n30    uniform float hue;\n31    uniform float hover;\n32    uniform float rot;\n33    uniform float hoverIntensity;\n34    varying vec2 vUv;\n35\n36    vec3 rgb2yiq(vec3 c) {\n37      float y = dot(c, vec3(0.299, 0.587, 0.114));\n38      float i = dot(c, vec3(0.596, -0.274, -0.322));\n39      float q = dot(c, vec3(0.211, -0.523, 0.312));\n40      return vec3(y, i, q);\n41    }\n42    \n43    vec3 yiq2rgb(vec3 c) {\n44      float r = c.x + 0.956 * c.y + 0.621 * c.z;\n45      float g = c.x - 0.272 * c.y - 0.647 * c.z;\n46      float b = c.x - 1.106 * c.y + 1.703 * c.z;\n47      return vec3(r, g, b);\n48    }\n49    \n50    vec3 adjustHue(vec3 color, float hueDeg) {\n51      float hueRad = hueDeg * 3.14159265 / 180.0;\n52      vec3 yiq = rgb2yiq(color);\n53      float cosA = cos(hueRad);\n54      float sinA = sin(hueRad);\n55      float i = yiq.y * cosA - yiq.z * sinA;\n56      float q = yiq.y * sinA + yiq.z * cosA;\n57      yiq.y = i;\n58      yiq.z = q;\n59      return yiq2rgb(yiq);\n60    }\n61\n62    vec3 hash33(vec3 p3) {\n63      p3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787));\n64      p3 += dot(p3, p3.yxz + 19.19);\n65      return -1.0 + 2.0 * fract(vec3(\n66        p3.x + p3.y,\n67        p3.x + p3.z,\n68        p3.y + p3.z\n69      ) * p3.zyx);\n70    }\n71\n72    float snoise3(vec3 p) {\n73      const float K1 = 0.333333333;\n74      const float K2 = 0.166666667;\n75      vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n76      vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n77      vec3 e = step(vec3(0.0), d0 - d0.yzx);\n78      vec3 i1 = e * (1.0 - e.zxy);\n79      vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n80      vec3 d1 = d0 - (i1 - K2);\n81      vec3 d2 = d0 - (i2 - K1);\n82      vec3 d3 = d0 - 0.5;\n83      vec4 h = max(0.6 - vec4(\n84        dot(d0, d0),\n85        dot(d1, d1),\n86        dot(d2, d2),\n87        dot(d3, d3)\n88      ), 0.0);\n89      vec4 n = h * h * h * h * vec4(\n90        dot(d0, hash33(i)),\n91        dot(d1, hash33(i + i1)),\n92        dot(d2, hash33(i + i2)),\n93        dot(d3, hash33(i + 1.0))\n94      );\n95      return dot(vec4(31.316), n);\n96    }\n97\n98    // Instead of \"extractAlpha\" that normalizes the color,\n99    // we keep the computed color as-is and later multiply by alpha.\n100    vec4 extractAlpha(vec3 colorIn) {\n101      float a = max(max(colorIn.r, colorIn.g), colorIn.b);\n102      return vec4(colorIn.rgb / (a + 1e-5), a);\n103    }\n104\n105    const vec3 baseColor1 = vec3(0.611765, 0.262745, 0.996078);\n106    const vec3 baseColor2 = vec3(0.298039, 0.760784, 0.913725);\n107    const vec3 baseColor3 = vec3(0.062745, 0.078431, 0.600000);\n108    const float innerRadius = 0.6;\n109    const float noiseScale = 0.65;\n110\n111    float light1(float intensity, float attenuation, float dist) {\n112      return intensity / (1.0 + dist * attenuation);\n113    }\n114    float light2(float intensity, float attenuation, float dist) {\n115      return intensity / (1.0 + dist * dist * attenuation);\n116    }\n117\n118    vec4 draw(vec2 uv) {\n119      vec3 color1 = adjustHue(baseColor1, hue);\n120      vec3 color2 = adjustHue(baseColor2, hue);\n121      vec3 color3 = adjustHue(baseColor3, hue);\n122      \n123      float ang = atan(uv.y, uv.x);\n124      float len = length(uv);\n125      float invLen = len > 0.0 ? 1.0 / len : 0.0;\n126      \n127      float n0 = snoise3(vec3(uv * noiseScale, iTime * 0.5)) * 0.5 + 0.5;\n128      float r0 = mix(mix(innerRadius, 1.0, 0.4), mix(innerRadius, 1.0, 0.6), n0);\n129      float d0 = distance(uv, (r0 * invLen) * uv);\n130      float v0 = light1(1.0, 10.0, d0);\n131      v0 *= smoothstep(r0 * 1.05, r0, len);\n132      float cl = cos(ang + iTime * 2.0) * 0.5 + 0.5;\n133      \n134      float a = iTime * -1.0;\n135      vec2 pos = vec2(cos(a), sin(a)) * r0;\n136      float d = distance(uv, pos);\n137      float v1 = light2(1.5, 5.0, d);\n138      v1 *= light1(1.0, 50.0, d0);\n139      \n140      float v2 = smoothstep(1.0, mix(innerRadius, 1.0, n0 * 0.5), len);\n141      float v3 = smoothstep(innerRadius, mix(innerRadius, 1.0, 0.5), len);\n142      \n143      vec3 col = mix(color1, color2, cl);\n144      col = mix(color3, col, v0);\n145      col = (col + v1) * v2 * v3;\n146      col = clamp(col, 0.0, 1.0);\n147      \n148      return extractAlpha(col);\n149    }\n150\n151    vec4 mainImage(vec2 fragCoord) {\n152      vec2 center = iResolution.xy * 0.5;\n153      float size = min(iResolution.x, iResolution.y);\n154      vec2 uv = (fragCoord - center) / size * 2.0;\n155      \n156      float angle = rot;\n157      float s = sin(angle);\n158      float c = cos(angle);\n159      uv = vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y);\n160      \n161      uv.x += hover * hoverIntensity * 0.1 * sin(uv.y * 10.0 + iTime);\n162      uv.y += hover * hoverIntensity * 0.1 * sin(uv.x * 10.0 + iTime);\n163      \n164      return draw(uv);\n165    }\n166\n167    void main() {\n168      vec2 fragCoord = vUv * iResolution.xy;\n169      vec4 col = mainImage(fragCoord);\n170      gl_FragColor = vec4(col.rgb * col.a, col.a);\n171    }\n172  `;\n173\n174  useEffect(() => {\n175    const container = ctnDom.current;\n176    if (!container) return;\n177\n178    const renderer = new Renderer({ alpha: true, premultipliedAlpha: false });\n179    const gl = renderer.gl;\n180    gl.clearColor(0, 0, 0, 0);\n181    container.appendChild(gl.canvas);\n182\n183    const geometry = new Triangle(gl);\n184    const program = new Program(gl, {\n185      vertex: vert,\n186      fragment: frag,\n187      uniforms: {\n188        iTime: { value: 0 },\n189        iResolution: {\n190          value: new Vec3(\n191            gl.canvas.width,\n192            gl.canvas.height,\n193            gl.canvas.width / gl.canvas.height\n194          ),\n195        },\n196        hue: { value: hue },\n197        hover: { value: 0 },\n198        rot: { value: 0 },\n199        hoverIntensity: { value: hoverIntensity },\n200      },\n201    });\n202\n203    const mesh = new Mesh(gl, { geometry, program });\n204\n205    function resize() {\n206      if (!container) return;\n207      const dpr = window.devicePixelRatio || 1;\n208      const width = container.clientWidth;\n209      const height = container.clientHeight;\n210      renderer.setSize(width * dpr, height * dpr);\n211      gl.canvas.style.width = width + \"px\";\n212      gl.canvas.style.height = height + \"px\";\n213      program.uniforms.iResolution.value.set(\n214        gl.canvas.width,\n215        gl.canvas.height,\n216        gl.canvas.width / gl.canvas.height\n217      );\n218    }\n219    window.addEventListener(\"resize\", resize);\n220    resize();\n221\n222    let targetHover = 0;\n223    let lastTime = 0;\n224    let currentRot = 0;\n225    const rotationSpeed = 0.3; // radians per second\n226\n227    const handleMouseMove = (e) => {\n228      const rect = container.getBoundingClientRect();\n229      const x = e.clientX - rect.left;\n230      const y = e.clientY - rect.top;\n231      const width = rect.width;\n232      const height = rect.height;\n233      const size = Math.min(width, height);\n234      const centerX = width / 2;\n235      const centerY = height / 2;\n236      const uvX = ((x - centerX) / size) * 2.0;\n237      const uvY = ((y - centerY) / size) * 2.0;\n238\n239      if (Math.sqrt(uvX * uvX + uvY * uvY) < 0.8) {\n240        targetHover = 1;\n241      } else {\n242        targetHover = 0;\n243      }\n244    };\n245\n246    const handleMouseLeave = () => {\n247      targetHover = 0;\n248    };\n249\n250    container.addEventListener(\"mousemove\", handleMouseMove);\n251    container.addEventListener(\"mouseleave\", handleMouseLeave);\n252\n253    let rafId;\n254    const update = (t) => {\n255      rafId = requestAnimationFrame(update);\n256      const dt = (t - lastTime) * 0.001;\n257      lastTime = t;\n258      program.uniforms.iTime.value = t * 0.001;\n259      program.uniforms.hue.value = hue;\n260      program.uniforms.hoverIntensity.value = hoverIntensity;\n261\n262      const effectiveHover = forceHoverState ? 1 : targetHover;\n263      program.uniforms.hover.value += (effectiveHover - program.uniforms.hover.value) * 0.1;\n264\n265      if (rotateOnHover && effectiveHover > 0.5) {\n266        currentRot += dt * rotationSpeed;\n267      }\n268      program.uniforms.rot.value = currentRot;\n269\n270      renderer.render({ scene: mesh });\n271    };\n272    rafId = requestAnimationFrame(update);\n273\n274    return () => {\n275      cancelAnimationFrame(rafId);\n276      window.removeEventListener(\"resize\", resize);\n277      container.removeEventListener(\"mousemove\", handleMouseMove);\n278      container.removeEventListener(\"mouseleave\", handleMouseLeave);\n279      container.removeChild(gl.canvas);\n280      gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n281    };\n282  // eslint-disable-next-line react-hooks/exhaustive-deps\n283  }, [hue, hoverIntensity, rotateOnHover, forceHoverState]);\n284\n285  return <div ref={ctnDom} className=\"orb-container\" />;\n286}\n287\n\n1.orb-container {\n2  position: relative;\n3  z-index: 2;\n4  width: 100%;\n5  height: 100%;\n6}\n\n1import { useEffect, useRef } from \"react\";\n2import { Renderer, Program, Mesh, Triangle, Vec3 } from \"ogl\";\n3\n4export default function Orb({\n5  hue = 0,\n6  hoverIntensity = 0.2,\n7  rotateOnHover = true,\n8  forceHoverState = false,\n9}) {\n10  const ctnDom = useRef(null);\n11\n12  const vert = /* glsl */ `\n13    precision highp float;\n14    attribute vec2 position;\n15    attribute vec2 uv;\n16    varying vec2 vUv;\n17    void main() {\n18      vUv = uv;\n19      gl_Position = vec4(position, 0.0, 1.0);\n20    }\n21  `;\n22\n23  const frag = /* glsl */ `\n24    precision highp float;\n25\n26    uniform float iTime;\n27    uniform vec3 iResolution;\n28    uniform float hue;\n29    uniform float hover;\n30    uniform float rot;\n31    uniform float hoverIntensity;\n32    varying vec2 vUv;\n33\n34    vec3 rgb2yiq(vec3 c) {\n35      float y = dot(c, vec3(0.299, 0.587, 0.114));\n36      float i = dot(c, vec3(0.596, -0.274, -0.322));\n37      float q = dot(c, vec3(0.211, -0.523, 0.312));\n38      return vec3(y, i, q);\n39    }\n40    \n41    vec3 yiq2rgb(vec3 c) {\n42      float r = c.x + 0.956 * c.y + 0.621 * c.z;\n43      float g = c.x - 0.272 * c.y - 0.647 * c.z;\n44      float b = c.x - 1.106 * c.y + 1.703 * c.z;\n45      return vec3(r, g, b);\n46    }\n47    \n48    vec3 adjustHue(vec3 color, float hueDeg) {\n49      float hueRad = hueDeg * 3.14159265 / 180.0;\n50      vec3 yiq = rgb2yiq(color);\n51      float cosA = cos(hueRad);\n52      float sinA = sin(hueRad);\n53      float i = yiq.y * cosA - yiq.z * sinA;\n54      float q = yiq.y * sinA + yiq.z * cosA;\n55      yiq.y = i;\n56      yiq.z = q;\n57      return yiq2rgb(yiq);\n58    }\n59\n60    vec3 hash33(vec3 p3) {\n61      p3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787));\n62      p3 += dot(p3, p3.yxz + 19.19);\n63      return -1.0 + 2.0 * fract(vec3(\n64        p3.x + p3.y,\n65        p3.x + p3.z,\n66        p3.y + p3.z\n67      ) * p3.zyx);\n68    }\n69\n70    float snoise3(vec3 p) {\n71      const float K1 = 0.333333333;\n72      const float K2 = 0.166666667;\n73      vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n74      vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n75      vec3 e = step(vec3(0.0), d0 - d0.yzx);\n76      vec3 i1 = e * (1.0 - e.zxy);\n77      vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n78      vec3 d1 = d0 - (i1 - K2);\n79      vec3 d2 = d0 - (i2 - K1);\n80      vec3 d3 = d0 - 0.5;\n81      vec4 h = max(0.6 - vec4(\n82        dot(d0, d0),\n83        dot(d1, d1),\n84        dot(d2, d2),\n85        dot(d3, d3)\n86      ), 0.0);\n87      vec4 n = h * h * h * h * vec4(\n88        dot(d0, hash33(i)),\n89        dot(d1, hash33(i + i1)),\n90        dot(d2, hash33(i + i2)),\n91        dot(d3, hash33(i + 1.0))\n92      );\n93      return dot(vec4(31.316), n);\n94    }\n95\n96    vec4 extractAlpha(vec3 colorIn) {\n97      float a = max(max(colorIn.r, colorIn.g), colorIn.b);\n98      return vec4(colorIn.rgb / (a + 1e-5), a);\n99    }\n100\n101    const vec3 baseColor1 = vec3(0.611765, 0.262745, 0.996078);\n102    const vec3 baseColor2 = vec3(0.298039, 0.760784, 0.913725);\n103    const vec3 baseColor3 = vec3(0.062745, 0.078431, 0.600000);\n104    const float innerRadius = 0.6;\n105    const float noiseScale = 0.65;\n106\n107    float light1(float intensity, float attenuation, float dist) {\n108      return intensity / (1.0 + dist * attenuation);\n109    }\n110    float light2(float intensity, float attenuation, float dist) {\n111      return intensity / (1.0 + dist * dist * attenuation);\n112    }\n113\n114    vec4 draw(vec2 uv) {\n115      vec3 color1 = adjustHue(baseColor1, hue);\n116      vec3 color2 = adjustHue(baseColor2, hue);\n117      vec3 color3 = adjustHue(baseColor3, hue);\n118      \n119      float ang = atan(uv.y, uv.x);\n120      float len = length(uv);\n121      float invLen = len > 0.0 ? 1.0 / len : 0.0;\n122      \n123      float n0 = snoise3(vec3(uv * noiseScale, iTime * 0.5)) * 0.5 + 0.5;\n124      float r0 = mix(mix(innerRadius, 1.0, 0.4), mix(innerRadius, 1.0, 0.6), n0);\n125      float d0 = distance(uv, (r0 * invLen) * uv);\n126      float v0 = light1(1.0, 10.0, d0);\n127      v0 *= smoothstep(r0 * 1.05, r0, len);\n128      float cl = cos(ang + iTime * 2.0) * 0.5 + 0.5;\n129      \n130      float a = iTime * -1.0;\n131      vec2 pos = vec2(cos(a), sin(a)) * r0;\n132      float d = distance(uv, pos);\n133      float v1 = light2(1.5, 5.0, d);\n134      v1 *= light1(1.0, 50.0, d0);\n135      \n136      float v2 = smoothstep(1.0, mix(innerRadius, 1.0, n0 * 0.5), len);\n137      float v3 = smoothstep(innerRadius, mix(innerRadius, 1.0, 0.5), len);\n138      \n139      vec3 col = mix(color1, color2, cl);\n140      col = mix(color3, col, v0);\n141      col = (col + v1) * v2 * v3;\n142      col = clamp(col, 0.0, 1.0);\n143      \n144      return extractAlpha(col);\n145    }\n146\n147    vec4 mainImage(vec2 fragCoord) {\n148      vec2 center = iResolution.xy * 0.5;\n149      float size = min(iResolution.x, iResolution.y);\n150      vec2 uv = (fragCoord - center) / size * 2.0;\n151      \n152      float angle = rot;\n153      float s = sin(angle);\n154      float c = cos(angle);\n155      uv = vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y);\n156      \n157      uv.x += hover * hoverIntensity * 0.1 * sin(uv.y * 10.0 + iTime);\n158      uv.y += hover * hoverIntensity * 0.1 * sin(uv.x * 10.0 + iTime);\n159      \n160      return draw(uv);\n161    }\n162\n163    void main() {\n164      vec2 fragCoord = vUv * iResolution.xy;\n165      vec4 col = mainImage(fragCoord);\n166      gl_FragColor = vec4(col.rgb * col.a, col.a);\n167    }\n168  `;\n169\n170  useEffect(() => {\n171    const container = ctnDom.current;\n172    if (!container) return;\n173\n174    const renderer = new Renderer({ alpha: true, premultipliedAlpha: false });\n175    const gl = renderer.gl;\n176    gl.clearColor(0, 0, 0, 0);\n177    container.appendChild(gl.canvas);\n178\n179    const geometry = new Triangle(gl);\n180    const program = new Program(gl, {\n181      vertex: vert,\n182      fragment: frag,\n183      uniforms: {\n184        iTime: { value: 0 },\n185        iResolution: {\n186          value: new Vec3(\n187            gl.canvas.width,\n188            gl.canvas.height,\n189            gl.canvas.width / gl.canvas.height\n190          ),\n191        },\n192        hue: { value: hue },\n193        hover: { value: 0 },\n194        rot: { value: 0 },\n195        hoverIntensity: { value: hoverIntensity },\n196      },\n197    });\n198\n199    const mesh = new Mesh(gl, { geometry, program });\n200\n201    function resize() {\n202      if (!container) return;\n203      const dpr = window.devicePixelRatio || 1;\n204      const width = container.clientWidth;\n205      const height = container.clientHeight;\n206      renderer.setSize(width * dpr, height * dpr);\n207      gl.canvas.style.width = width + \"px\";\n208      gl.canvas.style.height = height + \"px\";\n209      program.uniforms.iResolution.value.set(\n210        gl.canvas.width,\n211        gl.canvas.height,\n212        gl.canvas.width / gl.canvas.height\n213      );\n214    }\n215    window.addEventListener(\"resize\", resize);\n216    resize();\n217\n218    let targetHover = 0;\n219    let lastTime = 0;\n220    let currentRot = 0;\n221    const rotationSpeed = 0.3; // radians per second\n222\n223    const handleMouseMove = (e) => {\n224      const rect = container.getBoundingClientRect();\n225      const x = e.clientX - rect.left;\n226      const y = e.clientY - rect.top;\n227      const width = rect.width;\n228      const height = rect.height;\n229      const size = Math.min(width, height);\n230      const centerX = width / 2;\n231      const centerY = height / 2;\n232      const uvX = ((x - centerX) / size) * 2.0;\n233      const uvY = ((y - centerY) / size) * 2.0;\n234\n235      if (Math.sqrt(uvX * uvX + uvY * uvY) < 0.8) {\n236        targetHover = 1;\n237      } else {\n238        targetHover = 0;\n239      }\n240    };\n241\n242    const handleMouseLeave = () => {\n243      targetHover = 0;\n244    };\n245\n246    container.addEventListener(\"mousemove\", handleMouseMove);\n247    container.addEventListener(\"mouseleave\", handleMouseLeave);\n248\n249    let rafId;\n250    const update = (t) => {\n251      rafId = requestAnimationFrame(update);\n252      const dt = (t - lastTime) * 0.001;\n253      lastTime = t;\n254      program.uniforms.iTime.value = t * 0.001;\n255      program.uniforms.hue.value = hue;\n256      program.uniforms.hoverIntensity.value = hoverIntensity;\n257\n258      const effectiveHover = forceHoverState ? 1 : targetHover;\n259      program.uniforms.hover.value += (effectiveHover - program.uniforms.hover.value) * 0.1;\n260\n261      if (rotateOnHover && effectiveHover > 0.5) {\n262        currentRot += dt * rotationSpeed;\n263      }\n264      program.uniforms.rot.value = currentRot;\n265\n266      renderer.render({ scene: mesh });\n267    };\n268    rafId = requestAnimationFrame(update);\n269\n270    return () => {\n271      cancelAnimationFrame(rafId);\n272      window.removeEventListener(\"resize\", resize);\n273      container.removeEventListener(\"mousemove\", handleMouseMove);\n274      container.removeEventListener(\"mouseleave\", handleMouseLeave);\n275      container.removeChild(gl.canvas);\n276      gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n277    };\n278  // eslint-disable-next-line react-hooks/exhaustive-deps\n279  }, [hue, hoverIntensity, rotateOnHover, forceHoverState]);\n280\n281  return <div ref={ctnDom} className=\"w-full h-full\" />;\n282}\n283",
  "category": "backgrounds",
  "scrapedAt": "2025-04-27T11:48:04.225Z",
  "previewImage": "orb-preview.png"
}