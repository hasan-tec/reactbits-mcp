{
  "name": "Balatro",
  "description": "An open source collection of high quality, animated, interactive & fully customizable React components for building stunning, memorable user interfaces.",
  "props": {},
  "dependencies": [],
  "url": "https://www.reactbits.dev/backgrounds/balatro",
  "code": "1npm i ogl\n\n1import Balatro from './Balatro';\n2  \n3<Balatro\n4  isRotate={false}\n5  mouseInteraction={true}\n6  pixelFilter={700}\n7/>\n\n1import { Renderer, Program, Mesh, Triangle } from \"ogl\";\n2import { useEffect, useRef } from \"react\";\n3\n4import \"./Balatro.css\";\n5\n6function hexToVec4(hex) {\n7  let hexStr = hex.replace(\"#\", \"\");\n8  let r = 0,\n9    g = 0,\n10    b = 0,\n11    a = 1;\n12  if (hexStr.length === 6) {\n13    r = parseInt(hexStr.slice(0, 2), 16) / 255;\n14    g = parseInt(hexStr.slice(2, 4), 16) / 255;\n15    b = parseInt(hexStr.slice(4, 6), 16) / 255;\n16  } else if (hexStr.length === 8) {\n17    r = parseInt(hexStr.slice(0, 2), 16) / 255;\n18    g = parseInt(hexStr.slice(2, 4), 16) / 255;\n19    b = parseInt(hexStr.slice(4, 6), 16) / 255;\n20    a = parseInt(hexStr.slice(6, 8), 16) / 255;\n21  }\n22  return [r, g, b, a];\n23}\n24\n25const vertexShader = `\n26attribute vec2 uv;\n27attribute vec2 position;\n28varying vec2 vUv;\n29void main() {\n30  vUv = uv;\n31  gl_Position = vec4(position, 0, 1);\n32}\n33`;\n34\n35const fragmentShader = `\n36precision highp float;\n37\n38#define PI 3.14159265359\n39\n40uniform float iTime;\n41uniform vec3 iResolution;\n42uniform float uSpinRotation;\n43uniform float uSpinSpeed;\n44uniform vec2 uOffset;\n45uniform vec4 uColor1;\n46uniform vec4 uColor2;\n47uniform vec4 uColor3;\n48uniform float uContrast;\n49uniform float uLighting;\n50uniform float uSpinAmount;\n51uniform float uPixelFilter;\n52uniform float uSpinEase;\n53uniform bool uIsRotate;\n54uniform vec2 uMouse;\n55\n56varying vec2 vUv;\n57\n58vec4 effect(vec2 screenSize, vec2 screen_coords) {\n59    float pixel_size = length(screenSize.xy) / uPixelFilter;\n60    vec2 uv = (floor(screen_coords.xy * (1.0 / pixel_size)) * pixel_size - 0.5 * screenSize.xy) / length(screenSize.xy) - uOffset;\n61    float uv_len = length(uv);\n62    \n63    float speed = (uSpinRotation * uSpinEase * 0.2);\n64    if(uIsRotate){\n65       speed = iTime * speed;\n66    }\n67    speed += 302.2;\n68    \n69    // Mouse influence for gentle rotation (applied additively)\n70    float mouseInfluence = (uMouse.x * 2.0 - 1.0);\n71    speed += mouseInfluence * 0.1;\n72    \n73    float new_pixel_angle = atan(uv.y, uv.x) + speed - uSpinEase * 20.0 * (uSpinAmount * uv_len + (1.0 - uSpinAmount));\n74    vec2 mid = (screenSize.xy / length(screenSize.xy)) / 2.0;\n75    uv = (vec2(uv_len * cos(new_pixel_angle) + mid.x, uv_len * sin(new_pixel_angle) + mid.y) - mid);\n76    \n77    uv *= 30.0;\n78    // Fix: Apply mouse influence additively rather than scaling with time.\n79    float baseSpeed = iTime * uSpinSpeed;\n80    speed = baseSpeed + mouseInfluence * 2.0;\n81    \n82    vec2 uv2 = vec2(uv.x + uv.y);\n83    \n84    for(int i = 0; i < 5; i++) {\n85        uv2 += sin(max(uv.x, uv.y)) + uv;\n86        uv += 0.5 * vec2(\n87            cos(5.1123314 + 0.353 * uv2.y + speed * 0.131121),\n88            sin(uv2.x - 0.113 * speed)\n89        );\n90        uv -= cos(uv.x + uv.y) - sin(uv.x * 0.711 - uv.y);\n91    }\n92    \n93    float contrast_mod = (0.25 * uContrast + 0.5 * uSpinAmount + 1.2);\n94    float paint_res = min(2.0, max(0.0, length(uv) * 0.035 * contrast_mod));\n95    float c1p = max(0.0, 1.0 - contrast_mod * abs(1.0 - paint_res));\n96    float c2p = max(0.0, 1.0 - contrast_mod * abs(paint_res));\n97    float c3p = 1.0 - min(1.0, c1p + c2p);\n98    float light = (uLighting - 0.2) * max(c1p * 5.0 - 4.0, 0.0) + uLighting * max(c2p * 5.0 - 4.0, 0.0);\n99    \n100    return (0.3 / uContrast) * uColor1 + (1.0 - 0.3 / uContrast) * (uColor1 * c1p + uColor2 * c2p + vec4(c3p * uColor3.rgb, c3p * uColor1.a)) + light;\n101}\n102\n103void main() {\n104    vec2 uv = vUv * iResolution.xy;\n105    gl_FragColor = effect(iResolution.xy, uv);\n106}\n107`;\n108\n109export default function Balatro({\n110  spinRotation = -2.0,\n111  spinSpeed = 7.0,\n112  offset = [0.0, 0.0],\n113  color1 = \"#DE443B\",\n114  color2 = \"#006BB4\",\n115  color3 = \"#162325\",\n116  contrast = 3.5,\n117  lighting = 0.4,\n118  spinAmount = 0.25,\n119  pixelFilter = 745.0,\n120  spinEase = 1.0,\n121  isRotate = false,\n122  mouseInteraction = true,\n123}) {\n124  const containerRef = useRef(null);\n125\n126  useEffect(() => {\n127    if (!containerRef.current) return;\n128    const container = containerRef.current;\n129    const renderer = new Renderer();\n130    const gl = renderer.gl;\n131    gl.clearColor(0, 0, 0, 1);\n132\n133    let program;\n134\n135    function resize() {\n136      renderer.setSize(container.offsetWidth, container.offsetHeight);\n137      if (program) {\n138        program.uniforms.iResolution.value = [\n139          gl.canvas.width,\n140          gl.canvas.height,\n141          gl.canvas.width / gl.canvas.height,\n142        ];\n143      }\n144    }\n145    window.addEventListener(\"resize\", resize);\n146    resize();\n147\n148    const geometry = new Triangle(gl);\n149    program = new Program(gl, {\n150      vertex: vertexShader,\n151      fragment: fragmentShader,\n152      uniforms: {\n153        iTime: { value: 0 },\n154        iResolution: {\n155          value: [\n156            gl.canvas.width,\n157            gl.canvas.height,\n158            gl.canvas.width / gl.canvas.height,\n159          ],\n160        },\n161        uSpinRotation: { value: spinRotation },\n162        uSpinSpeed: { value: spinSpeed },\n163        uOffset: { value: offset },\n164        uColor1: { value: hexToVec4(color1) },\n165        uColor2: { value: hexToVec4(color2) },\n166        uColor3: { value: hexToVec4(color3) },\n167        uContrast: { value: contrast },\n168        uLighting: { value: lighting },\n169        uSpinAmount: { value: spinAmount },\n170        uPixelFilter: { value: pixelFilter },\n171        uSpinEase: { value: spinEase },\n172        uIsRotate: { value: isRotate },\n173        uMouse: { value: [0.5, 0.5] },\n174      },\n175    });\n176\n177    const mesh = new Mesh(gl, { geometry, program });\n178    let animationFrameId;\n179\n180    function update(time) {\n181      animationFrameId = requestAnimationFrame(update);\n182      program.uniforms.iTime.value = time * 0.001;\n183      renderer.render({ scene: mesh });\n184    }\n185    animationFrameId = requestAnimationFrame(update);\n186    container.appendChild(gl.canvas);\n187\n188    function handleMouseMove(e) {\n189      if (!mouseInteraction) return;\n190      const rect = container.getBoundingClientRect();\n191      const x = (e.clientX - rect.left) / rect.width;\n192      const y = 1.0 - (e.clientY - rect.top) / rect.height;\n193      program.uniforms.uMouse.value = [x, y];\n194    }\n195    container.addEventListener(\"mousemove\", handleMouseMove);\n196\n197    return () => {\n198      cancelAnimationFrame(animationFrameId);\n199      window.removeEventListener(\"resize\", resize);\n200      container.removeEventListener(\"mousemove\", handleMouseMove);\n201      container.removeChild(gl.canvas);\n202      gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n203    };\n204  }, [\n205    spinRotation,\n206    spinSpeed,\n207    offset,\n208    color1,\n209    color2,\n210    color3,\n211    contrast,\n212    lighting,\n213    spinAmount,\n214    pixelFilter,\n215    spinEase,\n216    isRotate,\n217    mouseInteraction,\n218    containerRef\n219  ]);\n220\n221  return <div ref={containerRef} className=\"balatro-container\" />;\n222}\n223\n\n1.balatro-container {\n2  width: 100%;\n3  height: 100%;\n4}\n\n1import { Renderer, Program, Mesh, Triangle } from \"ogl\";\n2import { useEffect, useRef } from \"react\";\n3\n4function hexToVec4(hex) {\n5  let hexStr = hex.replace(\"#\", \"\");\n6  let r = 0,\n7    g = 0,\n8    b = 0,\n9    a = 1;\n10  if (hexStr.length === 6) {\n11    r = parseInt(hexStr.slice(0, 2), 16) / 255;\n12    g = parseInt(hexStr.slice(2, 4), 16) / 255;\n13    b = parseInt(hexStr.slice(4, 6), 16) / 255;\n14  } else if (hexStr.length === 8) {\n15    r = parseInt(hexStr.slice(0, 2), 16) / 255;\n16    g = parseInt(hexStr.slice(2, 4), 16) / 255;\n17    b = parseInt(hexStr.slice(4, 6), 16) / 255;\n18    a = parseInt(hexStr.slice(6, 8), 16) / 255;\n19  }\n20  return [r, g, b, a];\n21}\n22\n23const vertexShader = `\n24attribute vec2 uv;\n25attribute vec2 position;\n26varying vec2 vUv;\n27void main() {\n28  vUv = uv;\n29  gl_Position = vec4(position, 0, 1);\n30}\n31`;\n32\n33const fragmentShader = `\n34precision highp float;\n35\n36#define PI 3.14159265359\n37\n38uniform float iTime;\n39uniform vec3 iResolution;\n40uniform float uSpinRotation;\n41uniform float uSpinSpeed;\n42uniform vec2 uOffset;\n43uniform vec4 uColor1;\n44uniform vec4 uColor2;\n45uniform vec4 uColor3;\n46uniform float uContrast;\n47uniform float uLighting;\n48uniform float uSpinAmount;\n49uniform float uPixelFilter;\n50uniform float uSpinEase;\n51uniform bool uIsRotate;\n52uniform vec2 uMouse;\n53\n54varying vec2 vUv;\n55\n56vec4 effect(vec2 screenSize, vec2 screen_coords) {\n57    float pixel_size = length(screenSize.xy) / uPixelFilter;\n58    vec2 uv = (floor(screen_coords.xy * (1.0 / pixel_size)) * pixel_size - 0.5 * screenSize.xy) / length(screenSize.xy) - uOffset;\n59    float uv_len = length(uv);\n60    \n61    float speed = (uSpinRotation * uSpinEase * 0.2);\n62    if(uIsRotate){\n63       speed = iTime * speed;\n64    }\n65    speed += 302.2;\n66    \n67    // Mouse influence for gentle rotation (applied additively)\n68    float mouseInfluence = (uMouse.x * 2.0 - 1.0);\n69    speed += mouseInfluence * 0.1;\n70    \n71    float new_pixel_angle = atan(uv.y, uv.x) + speed - uSpinEase * 20.0 * (uSpinAmount * uv_len + (1.0 - uSpinAmount));\n72    vec2 mid = (screenSize.xy / length(screenSize.xy)) / 2.0;\n73    uv = (vec2(uv_len * cos(new_pixel_angle) + mid.x, uv_len * sin(new_pixel_angle) + mid.y) - mid);\n74    \n75    uv *= 30.0;\n76    // Fix: Apply mouse influence additively rather than scaling with time.\n77    float baseSpeed = iTime * uSpinSpeed;\n78    speed = baseSpeed + mouseInfluence * 2.0;\n79    \n80    vec2 uv2 = vec2(uv.x + uv.y);\n81    \n82    for(int i = 0; i < 5; i++) {\n83        uv2 += sin(max(uv.x, uv.y)) + uv;\n84        uv += 0.5 * vec2(\n85            cos(5.1123314 + 0.353 * uv2.y + speed * 0.131121),\n86            sin(uv2.x - 0.113 * speed)\n87        );\n88        uv -= cos(uv.x + uv.y) - sin(uv.x * 0.711 - uv.y);\n89    }\n90    \n91    float contrast_mod = (0.25 * uContrast + 0.5 * uSpinAmount + 1.2);\n92    float paint_res = min(2.0, max(0.0, length(uv) * 0.035 * contrast_mod));\n93    float c1p = max(0.0, 1.0 - contrast_mod * abs(1.0 - paint_res));\n94    float c2p = max(0.0, 1.0 - contrast_mod * abs(paint_res));\n95    float c3p = 1.0 - min(1.0, c1p + c2p);\n96    float light = (uLighting - 0.2) * max(c1p * 5.0 - 4.0, 0.0) + uLighting * max(c2p * 5.0 - 4.0, 0.0);\n97    \n98    return (0.3 / uContrast) * uColor1 + (1.0 - 0.3 / uContrast) * (uColor1 * c1p + uColor2 * c2p + vec4(c3p * uColor3.rgb, c3p * uColor1.a)) + light;\n99}\n100\n101void main() {\n102    vec2 uv = vUv * iResolution.xy;\n103    gl_FragColor = effect(iResolution.xy, uv);\n104}\n105`;\n106\n107export default function Balatro({\n108  spinRotation = -2.0,\n109  spinSpeed = 7.0,\n110  offset = [0.0, 0.0],\n111  color1 = \"#DE443B\",\n112  color2 = \"#006BB4\",\n113  color3 = \"#162325\",\n114  contrast = 3.5,\n115  lighting = 0.4,\n116  spinAmount = 0.25,\n117  pixelFilter = 745.0,\n118  spinEase = 1.0,\n119  isRotate = false,\n120  mouseInteraction = true,\n121}) {\n122  const containerRef = useRef(null);\n123\n124  useEffect(() => {\n125    if (!containerRef.current) return;\n126    const container = containerRef.current;\n127    const renderer = new Renderer();\n128    const gl = renderer.gl;\n129    gl.clearColor(0, 0, 0, 1);\n130\n131    let program;\n132\n133    function resize() {\n134      renderer.setSize(container.offsetWidth, container.offsetHeight);\n135      if (program) {\n136        program.uniforms.iResolution.value = [\n137          gl.canvas.width,\n138          gl.canvas.height,\n139          gl.canvas.width / gl.canvas.height,\n140        ];\n141      }\n142    }\n143    window.addEventListener(\"resize\", resize);\n144    resize();\n145\n146    const geometry = new Triangle(gl);\n147    program = new Program(gl, {\n148      vertex: vertexShader,\n149      fragment: fragmentShader,\n150      uniforms: {\n151        iTime: { value: 0 },\n152        iResolution: {\n153          value: [\n154            gl.canvas.width,\n155            gl.canvas.height,\n156            gl.canvas.width / gl.canvas.height,\n157          ],\n158        },\n159        uSpinRotation: { value: spinRotation },\n160        uSpinSpeed: { value: spinSpeed },\n161        uOffset: { value: offset },\n162        uColor1: { value: hexToVec4(color1) },\n163        uColor2: { value: hexToVec4(color2) },\n164        uColor3: { value: hexToVec4(color3) },\n165        uContrast: { value: contrast },\n166        uLighting: { value: lighting },\n167        uSpinAmount: { value: spinAmount },\n168        uPixelFilter: { value: pixelFilter },\n169        uSpinEase: { value: spinEase },\n170        uIsRotate: { value: isRotate },\n171        uMouse: { value: [0.5, 0.5] },\n172      },\n173    });\n174\n175    const mesh = new Mesh(gl, { geometry, program });\n176    let animationFrameId;\n177\n178    function update(time) {\n179      animationFrameId = requestAnimationFrame(update);\n180      program.uniforms.iTime.value = time * 0.001;\n181      renderer.render({ scene: mesh });\n182    }\n183    animationFrameId = requestAnimationFrame(update);\n184    container.appendChild(gl.canvas);\n185\n186    function handleMouseMove(e) {\n187      if (!mouseInteraction) return;\n188      const rect = container.getBoundingClientRect();\n189      const x = (e.clientX - rect.left) / rect.width;\n190      const y = 1.0 - (e.clientY - rect.top) / rect.height;\n191      program.uniforms.uMouse.value = [x, y];\n192    }\n193    container.addEventListener(\"mousemove\", handleMouseMove);\n194\n195    return () => {\n196      cancelAnimationFrame(animationFrameId);\n197      window.removeEventListener(\"resize\", resize);\n198      container.removeEventListener(\"mousemove\", handleMouseMove);\n199      container.removeChild(gl.canvas);\n200      gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n201    };\n202  }, [\n203    spinRotation,\n204    spinSpeed,\n205    offset,\n206    color1,\n207    color2,\n208    color3,\n209    contrast,\n210    lighting,\n211    spinAmount,\n212    pixelFilter,\n213    spinEase,\n214    isRotate,\n215    mouseInteraction,\n216    containerRef\n217  ]);\n218\n219  return <div ref={containerRef} className=\"w-full h-full\" />;\n220}\n221",
  "category": "backgrounds",
  "scrapedAt": "2025-04-27T11:47:23.989Z",
  "previewImage": "balatro-preview.png"
}