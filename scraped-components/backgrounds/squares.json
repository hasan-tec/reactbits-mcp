{
  "name": "Squares",
  "description": "An open source collection of high quality, animated, interactive & fully customizable React components for building stunning, memorable user interfaces.",
  "props": {},
  "dependencies": [],
  "url": "https://www.reactbits.dev/backgrounds/squares",
  "code": "1import Squares from './Squares';\n2  \n3<Squares \n4speed={0.5} \n5squareSize={40}\n6direction='diagonal' // up, down, left, right, diagonal\n7borderColor='#fff'\n8hoverFillColor='#222'\n9/>\n\n1import { useRef, useEffect } from 'react';\n2import './Squares.css';\n3\n4const Squares = ({\n5  direction = 'right',\n6  speed = 1,\n7  borderColor = '#999',\n8  squareSize = 40,\n9  hoverFillColor = '#222',\n10  className = ''\n11}) => {\n12  const canvasRef = useRef(null);\n13  const requestRef = useRef(null);\n14  const numSquaresX = useRef();\n15  const numSquaresY = useRef();\n16  const gridOffset = useRef({ x: 0, y: 0 });\n17  const hoveredSquare = useRef(null);\n18\n19  useEffect(() => {\n20    const canvas = canvasRef.current;\n21    const ctx = canvas.getContext('2d');\n22\n23    const resizeCanvas = () => {\n24      canvas.width = canvas.offsetWidth;\n25      canvas.height = canvas.offsetHeight;\n26      numSquaresX.current = Math.ceil(canvas.width / squareSize) + 1;\n27      numSquaresY.current = Math.ceil(canvas.height / squareSize) + 1;\n28    };\n29\n30    window.addEventListener('resize', resizeCanvas);\n31    resizeCanvas();\n32\n33    const drawGrid = () => {\n34      ctx.clearRect(0, 0, canvas.width, canvas.height);\n35\n36      const startX = Math.floor(gridOffset.current.x / squareSize) * squareSize;\n37      const startY = Math.floor(gridOffset.current.y / squareSize) * squareSize;\n38\n39      for (let x = startX; x < canvas.width + squareSize; x += squareSize) {\n40        for (let y = startY; y < canvas.height + squareSize; y += squareSize) {\n41          const squareX = x - (gridOffset.current.x % squareSize);\n42          const squareY = y - (gridOffset.current.y % squareSize);\n43\n44          if (\n45            hoveredSquare.current &&\n46            Math.floor((x - startX) / squareSize) === hoveredSquare.current.x &&\n47            Math.floor((y - startY) / squareSize) === hoveredSquare.current.y\n48          ) {\n49            ctx.fillStyle = hoverFillColor;\n50            ctx.fillRect(squareX, squareY, squareSize, squareSize);\n51          }\n52\n53          ctx.strokeStyle = borderColor;\n54          ctx.strokeRect(squareX, squareY, squareSize, squareSize);\n55        }\n56      }\n57\n58      const gradient = ctx.createRadialGradient(\n59        canvas.width / 2,\n60        canvas.height / 2,\n61        0,\n62        canvas.width / 2,\n63        canvas.height / 2,\n64        Math.sqrt(canvas.width ** 2 + canvas.height ** 2) / 2\n65      );\n66      gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');\n67      // gradient.addColorStop(1, '#060606'); // uncomment for gradient\n68\n69      ctx.fillStyle = gradient;\n70      ctx.fillRect(0, 0, canvas.width, canvas.height);\n71    };\n72\n73    const updateAnimation = () => {\n74      const effectiveSpeed = Math.max(speed, 0.1);\n75      switch (direction) {\n76        case 'right':\n77          gridOffset.current.x = (gridOffset.current.x - effectiveSpeed + squareSize) % squareSize;\n78          break;\n79        case 'left':\n80          gridOffset.current.x = (gridOffset.current.x + effectiveSpeed + squareSize) % squareSize;\n81          break;\n82        case 'up':\n83          gridOffset.current.y = (gridOffset.current.y + effectiveSpeed + squareSize) % squareSize;\n84          break;\n85        case 'down':\n86          gridOffset.current.y = (gridOffset.current.y - effectiveSpeed + squareSize) % squareSize;\n87          break;\n88        case 'diagonal':\n89          gridOffset.current.x = (gridOffset.current.x - effectiveSpeed + squareSize) % squareSize;\n90          gridOffset.current.y = (gridOffset.current.y - effectiveSpeed + squareSize) % squareSize;\n91          break;\n92        default:\n93          break;\n94      }\n95\n96      drawGrid();\n97      requestRef.current = requestAnimationFrame(updateAnimation);\n98    };\n99\n100    const handleMouseMove = (event) => {\n101      const rect = canvas.getBoundingClientRect();\n102      const mouseX = event.clientX - rect.left;\n103      const mouseY = event.clientY - rect.top;\n104\n105      const startX = Math.floor(gridOffset.current.x / squareSize) * squareSize;\n106      const startY = Math.floor(gridOffset.current.y / squareSize) * squareSize;\n107\n108      const hoveredSquareX = Math.floor((mouseX + gridOffset.current.x - startX) / squareSize);\n109      const hoveredSquareY = Math.floor((mouseY + gridOffset.current.y - startY) / squareSize);\n110\n111      if (\n112        !hoveredSquare.current ||\n113        hoveredSquare.current.x !== hoveredSquareX ||\n114        hoveredSquare.current.y !== hoveredSquareY\n115      ) {\n116        hoveredSquare.current = { x: hoveredSquareX, y: hoveredSquareY };\n117      }\n118    };\n119\n120    const handleMouseLeave = () => {\n121      hoveredSquare.current = null;\n122    };\n123\n124    canvas.addEventListener('mousemove', handleMouseMove);\n125    canvas.addEventListener('mouseleave', handleMouseLeave);\n126\n127    requestRef.current = requestAnimationFrame(updateAnimation);\n128\n129    return () => {\n130      window.removeEventListener('resize', resizeCanvas);\n131      cancelAnimationFrame(requestRef.current);\n132      canvas.removeEventListener('mousemove', handleMouseMove);\n133      canvas.removeEventListener('mouseleave', handleMouseLeave);\n134    };\n135  }, [direction, speed, borderColor, hoverFillColor, squareSize]);\n136\n137  return <canvas ref={canvasRef} className={`squares-canvas ${className}`}></canvas>;\n138};\n139\n140export default Squares;\n141\n\n1.squares-canvas {\n2  width: 100%;\n3  height: 100%;\n4  border: none;\n5  display: block;\n6}\n7\n\n1import { useRef, useEffect } from \"react\";\n2\n3const Squares = ({\n4  direction = \"right\",\n5  speed = 1,\n6  borderColor = \"#999\",\n7  squareSize = 40,\n8  hoverFillColor = \"#222\",\n9}) => {\n10  const canvasRef = useRef(null);\n11  const requestRef = useRef(null);\n12  const numSquaresX = useRef(0);\n13  const numSquaresY = useRef(0);\n14  const gridOffset = useRef({ x: 0, y: 0 });\n15  const hoveredSquareRef = useRef(null);\n16\n17  useEffect(() => {\n18    const canvas = canvasRef.current;\n19    if (!canvas) return;\n20    const ctx = canvas.getContext(\"2d\");\n21\n22    const resizeCanvas = () => {\n23      canvas.width = canvas.offsetWidth;\n24      canvas.height = canvas.offsetHeight;\n25      numSquaresX.current = Math.ceil(canvas.width / squareSize) + 1;\n26      numSquaresY.current = Math.ceil(canvas.height / squareSize) + 1;\n27    };\n28\n29    window.addEventListener(\"resize\", resizeCanvas);\n30    resizeCanvas();\n31\n32    const drawGrid = () => {\n33      if (!ctx) return;\n34\n35      ctx.clearRect(0, 0, canvas.width, canvas.height);\n36\n37      const startX = Math.floor(gridOffset.current.x / squareSize) * squareSize;\n38      const startY = Math.floor(gridOffset.current.y / squareSize) * squareSize;\n39\n40      for (let x = startX; x < canvas.width + squareSize; x += squareSize) {\n41        for (let y = startY; y < canvas.height + squareSize; y += squareSize) {\n42          const squareX = x - (gridOffset.current.x % squareSize);\n43          const squareY = y - (gridOffset.current.y % squareSize);\n44\n45          if (\n46            hoveredSquareRef.current &&\n47            Math.floor((x - startX) / squareSize) ===\n48            hoveredSquareRef.current.x &&\n49            Math.floor((y - startY) / squareSize) === hoveredSquareRef.current.y\n50          ) {\n51            ctx.fillStyle = hoverFillColor;\n52            ctx.fillRect(squareX, squareY, squareSize, squareSize);\n53          }\n54\n55          ctx.strokeStyle = borderColor;\n56          ctx.strokeRect(squareX, squareY, squareSize, squareSize);\n57        }\n58      }\n59\n60      const gradient = ctx.createRadialGradient(\n61        canvas.width / 2,\n62        canvas.height / 2,\n63        0,\n64        canvas.width / 2,\n65        canvas.height / 2,\n66        Math.sqrt(canvas.width ** 2 + canvas.height ** 2) / 2\n67      );\n68      gradient.addColorStop(0, \"rgba(0, 0, 0, 0)\");\n69      gradient.addColorStop(1, \"#060606\");\n70\n71      ctx.fillStyle = gradient;\n72      ctx.fillRect(0, 0, canvas.width, canvas.height);\n73    };\n74\n75    const updateAnimation = () => {\n76      const effectiveSpeed = Math.max(speed, 0.1);\n77      switch (direction) {\n78        case \"right\":\n79          gridOffset.current.x =\n80            (gridOffset.current.x - effectiveSpeed + squareSize) % squareSize;\n81          break;\n82        case \"left\":\n83          gridOffset.current.x =\n84            (gridOffset.current.x + effectiveSpeed + squareSize) % squareSize;\n85          break;\n86        case \"up\":\n87          gridOffset.current.y =\n88            (gridOffset.current.y + effectiveSpeed + squareSize) % squareSize;\n89          break;\n90        case \"down\":\n91          gridOffset.current.y =\n92            (gridOffset.current.y - effectiveSpeed + squareSize) % squareSize;\n93          break;\n94        case \"diagonal\":\n95          gridOffset.current.x =\n96            (gridOffset.current.x - effectiveSpeed + squareSize) % squareSize;\n97          gridOffset.current.y =\n98            (gridOffset.current.y - effectiveSpeed + squareSize) % squareSize;\n99          break;\n100        default:\n101          break;\n102      }\n103\n104      drawGrid();\n105      requestRef.current = requestAnimationFrame(updateAnimation);\n106    };\n107\n108    const handleMouseMove = (event) => {\n109      const rect = canvas.getBoundingClientRect();\n110      const mouseX = event.clientX - rect.left;\n111      const mouseY = event.clientY - rect.top;\n112\n113      const startX = Math.floor(gridOffset.current.x / squareSize) * squareSize;\n114      const startY = Math.floor(gridOffset.current.y / squareSize) * squareSize;\n115\n116      const hoveredSquareX = Math.floor(\n117        (mouseX + gridOffset.current.x - startX) / squareSize\n118      );\n119      const hoveredSquareY = Math.floor(\n120        (mouseY + gridOffset.current.y - startY) / squareSize\n121      );\n122\n123      if (\n124        !hoveredSquareRef.current ||\n125        hoveredSquareRef.current.x !== hoveredSquareX ||\n126        hoveredSquareRef.current.y !== hoveredSquareY\n127      ) {\n128        hoveredSquareRef.current = { x: hoveredSquareX, y: hoveredSquareY };\n129      }\n130    };\n131\n132    const handleMouseLeave = () => {\n133      hoveredSquareRef.current = null;\n134    };\n135\n136    canvas.addEventListener(\"mousemove\", handleMouseMove);\n137    canvas.addEventListener(\"mouseleave\", handleMouseLeave);\n138    requestRef.current = requestAnimationFrame(updateAnimation);\n139\n140    return () => {\n141      window.removeEventListener(\"resize\", resizeCanvas);\n142      if (requestRef.current) cancelAnimationFrame(requestRef.current);\n143      canvas.removeEventListener(\"mousemove\", handleMouseMove);\n144      canvas.removeEventListener(\"mouseleave\", handleMouseLeave);\n145    };\n146  }, [direction, speed, borderColor, hoverFillColor, squareSize]);\n147\n148  return (\n149    <canvas\n150      ref={canvasRef}\n151      className=\"w-full h-full border-none block\"\n152    ></canvas>\n153  );\n154};\n155\n156export default Squares;\n157",
  "category": "backgrounds",
  "scrapedAt": "2025-04-27T11:48:21.490Z",
  "previewImage": "squares-preview.png"
}