{
  "name": "Lightning",
  "description": "An open source collection of high quality, animated, interactive & fully customizable React components for building stunning, memorable user interfaces.",
  "props": {},
  "dependencies": [],
  "url": "https://www.reactbits.dev/backgrounds/lightning",
  "code": "1import Lightning from './Lightning';\n2\n3<div style={{ width: '100%', height: '600px', position: 'relative' }}>\n4  <Lightning\n5    hue={220}\n6    xOffset={0}\n7    speed={1}\n8    intensity={1}\n9    size={1}\n10  />\n11</div>\n\n1import { useRef, useEffect } from \"react\";\n2import \"./Lightning.css\";\n3\n4const Lightning = ({\n5  hue = 230,\n6  xOffset = 0,\n7  speed = 1,\n8  intensity = 1,\n9  size = 1,\n10}) => {\n11  const canvasRef = useRef(null);\n12\n13  useEffect(() => {\n14    const canvas = canvasRef.current;\n15    if (!canvas) return;\n16\n17    const resizeCanvas = () => {\n18      canvas.width = canvas.clientWidth;\n19      canvas.height = canvas.clientHeight;\n20    };\n21    resizeCanvas();\n22    window.addEventListener(\"resize\", resizeCanvas);\n23\n24    const gl = canvas.getContext(\"webgl\");\n25    if (!gl) {\n26      console.error(\"WebGL not supported\");\n27      return;\n28    }\n29\n30    const vertexShaderSource = `\n31      attribute vec2 aPosition;\n32      void main() {\n33        gl_Position = vec4(aPosition, 0.0, 1.0);\n34      }\n35    `;\n36\n37    const fragmentShaderSource = `\n38      precision mediump float;\n39      uniform vec2 iResolution;\n40      uniform float iTime;\n41      uniform float uHue;\n42      uniform float uXOffset;\n43      uniform float uSpeed;\n44      uniform float uIntensity;\n45      uniform float uSize;\n46      \n47      #define OCTAVE_COUNT 10\n48\n49      // Convert HSV to RGB.\n50      vec3 hsv2rgb(vec3 c) {\n51          vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0,4.0,2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n52          return c.z * mix(vec3(1.0), rgb, c.y);\n53      }\n54\n55      float hash11(float p) {\n56          p = fract(p * .1031);\n57          p *= p + 33.33;\n58          p *= p + p;\n59          return fract(p);\n60      }\n61\n62      float hash12(vec2 p) {\n63          vec3 p3 = fract(vec3(p.xyx) * .1031);\n64          p3 += dot(p3, p3.yzx + 33.33);\n65          return fract((p3.x + p3.y) * p3.z);\n66      }\n67\n68      mat2 rotate2d(float theta) {\n69          float c = cos(theta);\n70          float s = sin(theta);\n71          return mat2(c, -s, s, c);\n72      }\n73\n74      float noise(vec2 p) {\n75          vec2 ip = floor(p);\n76          vec2 fp = fract(p);\n77          float a = hash12(ip);\n78          float b = hash12(ip + vec2(1.0, 0.0));\n79          float c = hash12(ip + vec2(0.0, 1.0));\n80          float d = hash12(ip + vec2(1.0, 1.0));\n81          \n82          vec2 t = smoothstep(0.0, 1.0, fp);\n83          return mix(mix(a, b, t.x), mix(c, d, t.x), t.y);\n84      }\n85\n86      float fbm(vec2 p) {\n87          float value = 0.0;\n88          float amplitude = 0.5;\n89          for (int i = 0; i < OCTAVE_COUNT; ++i) {\n90              value += amplitude * noise(p);\n91              p *= rotate2d(0.45);\n92              p *= 2.0;\n93              amplitude *= 0.5;\n94          }\n95          return value;\n96      }\n97\n98      void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n99          // Normalized pixel coordinates.\n100          vec2 uv = fragCoord / iResolution.xy;\n101          uv = 2.0 * uv - 1.0;\n102          uv.x *= iResolution.x / iResolution.y;\n103          // Apply horizontal offset.\n104          uv.x += uXOffset;\n105          \n106          // Adjust uv based on size and animate with speed.\n107          uv += 2.0 * fbm(uv * uSize + 0.8 * iTime * uSpeed) - 1.0;\n108          \n109          float dist = abs(uv.x);\n110          // Compute base color using hue.\n111          vec3 baseColor = hsv2rgb(vec3(uHue / 360.0, 0.7, 0.8));\n112          // Compute color with intensity and speed affecting time.\n113          vec3 col = baseColor * pow(mix(0.0, 0.07, hash11(iTime * uSpeed)) / dist, 1.0) * uIntensity;\n114          col = pow(col, vec3(1.0));\n115          fragColor = vec4(col, 1.0);\n116      }\n117\n118      void main() {\n119          mainImage(gl_FragColor, gl_FragCoord.xy);\n120      }\n121    `;\n122\n123    const compileShader = (\n124      source,\n125      type\n126    ) => {\n127      const shader = gl.createShader(type);\n128      if (!shader) return null;\n129      gl.shaderSource(shader, source);\n130      gl.compileShader(shader);\n131      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n132        console.error(\"Shader compile error:\", gl.getShaderInfoLog(shader));\n133        gl.deleteShader(shader);\n134        return null;\n135      }\n136      return shader;\n137    };\n138\n139    const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);\n140    const fragmentShader = compileShader(\n141      fragmentShaderSource,\n142      gl.FRAGMENT_SHADER\n143    );\n144    if (!vertexShader || !fragmentShader) return;\n145\n146    const program = gl.createProgram();\n147    if (!program) return;\n148    gl.attachShader(program, vertexShader);\n149    gl.attachShader(program, fragmentShader);\n150    gl.linkProgram(program);\n151    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n152      console.error(\"Program linking error:\", gl.getProgramInfoLog(program));\n153      return;\n154    }\n155    gl.useProgram(program);\n156\n157    const vertices = new Float32Array([\n158      -1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1,\n159    ]);\n160    const vertexBuffer = gl.createBuffer();\n161    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n162    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n163\n164    const aPosition = gl.getAttribLocation(program, \"aPosition\");\n165    gl.enableVertexAttribArray(aPosition);\n166    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\n167\n168    const iResolutionLocation = gl.getUniformLocation(program, \"iResolution\");\n169    const iTimeLocation = gl.getUniformLocation(program, \"iTime\");\n170    const uHueLocation = gl.getUniformLocation(program, \"uHue\");\n171    const uXOffsetLocation = gl.getUniformLocation(program, \"uXOffset\");\n172    const uSpeedLocation = gl.getUniformLocation(program, \"uSpeed\");\n173    const uIntensityLocation = gl.getUniformLocation(program, \"uIntensity\");\n174    const uSizeLocation = gl.getUniformLocation(program, \"uSize\");\n175\n176    const startTime = performance.now();\n177    const render = () => {\n178      resizeCanvas();\n179      gl.viewport(0, 0, canvas.width, canvas.height);\n180      gl.uniform2f(iResolutionLocation, canvas.width, canvas.height);\n181      const currentTime = performance.now();\n182      gl.uniform1f(iTimeLocation, (currentTime - startTime) / 1000.0);\n183      gl.uniform1f(uHueLocation, hue);\n184      gl.uniform1f(uXOffsetLocation, xOffset);\n185      gl.uniform1f(uSpeedLocation, speed);\n186      gl.uniform1f(uIntensityLocation, intensity);\n187      gl.uniform1f(uSizeLocation, size);\n188      gl.drawArrays(gl.TRIANGLES, 0, 6);\n189      requestAnimationFrame(render);\n190    };\n191    requestAnimationFrame(render);\n192\n193    return () => {\n194      window.removeEventListener(\"resize\", resizeCanvas);\n195    };\n196  }, [hue, xOffset, speed, intensity, size]);\n197\n198  return <canvas ref={canvasRef} className=\"lightning-container\" />;\n199};\n200\n201export default Lightning;\n202\n\n1.lightning-container {\n2  width: 100%;\n3  height: 100%;\n4  position: relative;\n5}\n\n1import { useRef, useEffect } from \"react\";\n2\n3const Lightning = ({\n4  hue = 230,\n5  xOffset = 0,\n6  speed = 1,\n7  intensity = 1,\n8  size = 1,\n9}) => {\n10  const canvasRef = useRef(null);\n11\n12  useEffect(() => {\n13    const canvas = canvasRef.current;\n14    if (!canvas) return;\n15\n16    const resizeCanvas = () => {\n17      canvas.width = canvas.clientWidth;\n18      canvas.height = canvas.clientHeight;\n19    };\n20    resizeCanvas();\n21    window.addEventListener(\"resize\", resizeCanvas);\n22\n23    const gl = canvas.getContext(\"webgl\");\n24    if (!gl) {\n25      console.error(\"WebGL not supported\");\n26      return;\n27    }\n28\n29    const vertexShaderSource = `\n30      attribute vec2 aPosition;\n31      void main() {\n32        gl_Position = vec4(aPosition, 0.0, 1.0);\n33      }\n34    `;\n35\n36    const fragmentShaderSource = `\n37      precision mediump float;\n38      uniform vec2 iResolution;\n39      uniform float iTime;\n40      uniform float uHue;\n41      uniform float uXOffset;\n42      uniform float uSpeed;\n43      uniform float uIntensity;\n44      uniform float uSize;\n45      \n46      #define OCTAVE_COUNT 10\n47\n48      // Convert HSV to RGB.\n49      vec3 hsv2rgb(vec3 c) {\n50          vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0,4.0,2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n51          return c.z * mix(vec3(1.0), rgb, c.y);\n52      }\n53\n54      float hash11(float p) {\n55          p = fract(p * .1031);\n56          p *= p + 33.33;\n57          p *= p + p;\n58          return fract(p);\n59      }\n60\n61      float hash12(vec2 p) {\n62          vec3 p3 = fract(vec3(p.xyx) * .1031);\n63          p3 += dot(p3, p3.yzx + 33.33);\n64          return fract((p3.x + p3.y) * p3.z);\n65      }\n66\n67      mat2 rotate2d(float theta) {\n68          float c = cos(theta);\n69          float s = sin(theta);\n70          return mat2(c, -s, s, c);\n71      }\n72\n73      float noise(vec2 p) {\n74          vec2 ip = floor(p);\n75          vec2 fp = fract(p);\n76          float a = hash12(ip);\n77          float b = hash12(ip + vec2(1.0, 0.0));\n78          float c = hash12(ip + vec2(0.0, 1.0));\n79          float d = hash12(ip + vec2(1.0, 1.0));\n80          \n81          vec2 t = smoothstep(0.0, 1.0, fp);\n82          return mix(mix(a, b, t.x), mix(c, d, t.x), t.y);\n83      }\n84\n85      float fbm(vec2 p) {\n86          float value = 0.0;\n87          float amplitude = 0.5;\n88          for (int i = 0; i < OCTAVE_COUNT; ++i) {\n89              value += amplitude * noise(p);\n90              p *= rotate2d(0.45);\n91              p *= 2.0;\n92              amplitude *= 0.5;\n93          }\n94          return value;\n95      }\n96\n97      void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n98          // Normalized pixel coordinates.\n99          vec2 uv = fragCoord / iResolution.xy;\n100          uv = 2.0 * uv - 1.0;\n101          uv.x *= iResolution.x / iResolution.y;\n102          // Apply horizontal offset.\n103          uv.x += uXOffset;\n104          \n105          // Adjust uv based on size and animate with speed.\n106          uv += 2.0 * fbm(uv * uSize + 0.8 * iTime * uSpeed) - 1.0;\n107          \n108          float dist = abs(uv.x);\n109          // Compute base color using hue.\n110          vec3 baseColor = hsv2rgb(vec3(uHue / 360.0, 0.7, 0.8));\n111          // Compute color with intensity and speed affecting time.\n112          vec3 col = baseColor * pow(mix(0.0, 0.07, hash11(iTime * uSpeed)) / dist, 1.0) * uIntensity;\n113          col = pow(col, vec3(1.0));\n114          fragColor = vec4(col, 1.0);\n115      }\n116\n117      void main() {\n118          mainImage(gl_FragColor, gl_FragCoord.xy);\n119      }\n120    `;\n121\n122    const compileShader = (\n123      source,\n124      type\n125    ) => {\n126      const shader = gl.createShader(type);\n127      if (!shader) return null;\n128      gl.shaderSource(shader, source);\n129      gl.compileShader(shader);\n130      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n131        console.error(\"Shader compile error:\", gl.getShaderInfoLog(shader));\n132        gl.deleteShader(shader);\n133        return null;\n134      }\n135      return shader;\n136    };\n137\n138    const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);\n139    const fragmentShader = compileShader(\n140      fragmentShaderSource,\n141      gl.FRAGMENT_SHADER\n142    );\n143    if (!vertexShader || !fragmentShader) return;\n144\n145    const program = gl.createProgram();\n146    if (!program) return;\n147    gl.attachShader(program, vertexShader);\n148    gl.attachShader(program, fragmentShader);\n149    gl.linkProgram(program);\n150    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n151      console.error(\"Program linking error:\", gl.getProgramInfoLog(program));\n152      return;\n153    }\n154    gl.useProgram(program);\n155\n156    const vertices = new Float32Array([\n157      -1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1,\n158    ]);\n159    const vertexBuffer = gl.createBuffer();\n160    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n161    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n162\n163    const aPosition = gl.getAttribLocation(program, \"aPosition\");\n164    gl.enableVertexAttribArray(aPosition);\n165    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\n166\n167    const iResolutionLocation = gl.getUniformLocation(program, \"iResolution\");\n168    const iTimeLocation = gl.getUniformLocation(program, \"iTime\");\n169    const uHueLocation = gl.getUniformLocation(program, \"uHue\");\n170    const uXOffsetLocation = gl.getUniformLocation(program, \"uXOffset\");\n171    const uSpeedLocation = gl.getUniformLocation(program, \"uSpeed\");\n172    const uIntensityLocation = gl.getUniformLocation(program, \"uIntensity\");\n173    const uSizeLocation = gl.getUniformLocation(program, \"uSize\");\n174\n175    const startTime = performance.now();\n176    const render = () => {\n177      resizeCanvas();\n178      gl.viewport(0, 0, canvas.width, canvas.height);\n179      gl.uniform2f(iResolutionLocation, canvas.width, canvas.height);\n180      const currentTime = performance.now();\n181      gl.uniform1f(iTimeLocation, (currentTime - startTime) / 1000.0);\n182      gl.uniform1f(uHueLocation, hue);\n183      gl.uniform1f(uXOffsetLocation, xOffset);\n184      gl.uniform1f(uSpeedLocation, speed);\n185      gl.uniform1f(uIntensityLocation, intensity);\n186      gl.uniform1f(uSizeLocation, size);\n187      gl.drawArrays(gl.TRIANGLES, 0, 6);\n188      requestAnimationFrame(render);\n189    };\n190    requestAnimationFrame(render);\n191\n192    return () => {\n193      window.removeEventListener(\"resize\", resizeCanvas);\n194    };\n195  }, [hue, xOffset, speed, intensity, size]);\n196\n197  return <canvas ref={canvasRef} className=\"w-full h-full relative\" />;\n198};\n199\n200export default Lightning;\n201",
  "category": "backgrounds",
  "scrapedAt": "2025-04-27T11:48:09.859Z",
  "previewImage": "lightning-preview.png"
}