{
  "name": "Iridescence",
  "description": "An open source collection of high quality, animated, interactive & fully customizable React components for building stunning, memorable user interfaces.",
  "props": {},
  "dependencies": [],
  "url": "https://www.reactbits.dev/backgrounds/iridescence",
  "code": "1npm i ogl\n\n1import Iridescence from './Iridescence';\n2  \n3<Iridescence\n4  color={[1, 1, 1]}\n5  mouseReact={false}\n6  amplitude={0.1}\n7  speed={1.0}\n8/>\n\n1import { Renderer, Program, Mesh, Color, Triangle } from \"ogl\";\n2import { useEffect, useRef } from \"react\";\n3\n4import './Iridescence.css';\n5\n6const vertexShader = `\n7attribute vec2 uv;\n8attribute vec2 position;\n9\n10varying vec2 vUv;\n11\n12void main() {\n13  vUv = uv;\n14  gl_Position = vec4(position, 0, 1);\n15}\n16`;\n17\n18const fragmentShader = `\n19precision highp float;\n20\n21uniform float uTime;\n22uniform vec3 uColor;\n23uniform vec3 uResolution;\n24uniform vec2 uMouse;\n25uniform float uAmplitude;\n26uniform float uSpeed;\n27\n28varying vec2 vUv;\n29\n30void main() {\n31  float mr = min(uResolution.x, uResolution.y);\n32  vec2 uv = (vUv.xy * 2.0 - 1.0) * uResolution.xy / mr;\n33\n34  // Add a subtle offset based on the mouse position\n35  uv += (uMouse - vec2(0.5)) * uAmplitude;\n36\n37  float d = -uTime * 0.5 * uSpeed;\n38  float a = 0.0;\n39  for (float i = 0.0; i < 8.0; ++i) {\n40    a += cos(i - d - a * uv.x);\n41    d += sin(uv.y * i + a);\n42  }\n43  d += uTime * 0.5 * uSpeed;\n44  vec3 col = vec3(cos(uv * vec2(d, a)) * 0.6 + 0.4, cos(a + d) * 0.5 + 0.5);\n45  col = cos(col * cos(vec3(d, a, 2.5)) * 0.5 + 0.5) * uColor;\n46  gl_FragColor = vec4(col, 1.0);\n47}\n48`;\n49\n50export default function Iridescence({\n51  color = [1, 1, 1],\n52  speed = 1.0,\n53  amplitude = 0.1,\n54  mouseReact = true,\n55  ...rest\n56}) {\n57  const ctnDom = useRef(null);\n58  const mousePos = useRef({ x: 0.5, y: 0.5 });\n59\n60  useEffect(() => {\n61    if (!ctnDom.current) return;\n62    const ctn = ctnDom.current;\n63    const renderer = new Renderer();\n64    const gl = renderer.gl;\n65    gl.clearColor(1, 1, 1, 1);\n66\n67    let program;\n68\n69    function resize() {\n70      const scale = 1;\n71      renderer.setSize(ctn.offsetWidth * scale, ctn.offsetHeight * scale);\n72      if (program) {\n73        program.uniforms.uResolution.value = new Color(\n74          gl.canvas.width,\n75          gl.canvas.height,\n76          gl.canvas.width / gl.canvas.height\n77        );\n78      }\n79    }\n80    window.addEventListener(\"resize\", resize, false);\n81    resize();\n82\n83    const geometry = new Triangle(gl);\n84    program = new Program(gl, {\n85      vertex: vertexShader,\n86      fragment: fragmentShader,\n87      uniforms: {\n88        uTime: { value: 0 },\n89        uColor: { value: new Color(...color) },\n90        uResolution: {\n91          value: new Color(\n92            gl.canvas.width,\n93            gl.canvas.height,\n94            gl.canvas.width / gl.canvas.height\n95          ),\n96        },\n97        uMouse: { value: new Float32Array([mousePos.current.x, mousePos.current.y]) },\n98        uAmplitude: { value: amplitude },\n99        uSpeed: { value: speed },\n100      },\n101    });\n102\n103    const mesh = new Mesh(gl, { geometry, program });\n104    let animateId;\n105\n106    function update(t) {\n107      animateId = requestAnimationFrame(update);\n108      program.uniforms.uTime.value = t * 0.001;\n109      renderer.render({ scene: mesh });\n110    }\n111    animateId = requestAnimationFrame(update);\n112    ctn.appendChild(gl.canvas);\n113\n114    function handleMouseMove(e) {\n115      const rect = ctn.getBoundingClientRect();\n116      const x = (e.clientX - rect.left) / rect.width;\n117      const y = 1.0 - (e.clientY - rect.top) / rect.height;\n118      mousePos.current = { x, y };\n119      program.uniforms.uMouse.value[0] = x;\n120      program.uniforms.uMouse.value[1] = y;\n121    }\n122    if (mouseReact) {\n123      ctn.addEventListener(\"mousemove\", handleMouseMove);\n124    }\n125\n126    return () => {\n127      cancelAnimationFrame(animateId);\n128      window.removeEventListener(\"resize\", resize);\n129      if (mouseReact) {\n130        ctn.removeEventListener(\"mousemove\", handleMouseMove);\n131      }\n132      ctn.removeChild(gl.canvas);\n133      gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n134    };\n135  // eslint-disable-next-line react-hooks/exhaustive-deps\n136  }, [color, speed, amplitude, mouseReact]);\n137\n138  return (\n139    <div\n140      ref={ctnDom}\n141      className=\"iridescence-container\"\n142      {...rest}\n143    />\n144  );\n145}\n146\n\n1.iridescence-container {\n2  width: 100%;\n3  height: 100%;\n4}\n\n1import { Renderer, Program, Mesh, Color, Triangle } from \"ogl\";\n2import { useEffect, useRef } from \"react\";\n3\n4const vertexShader = `\n5attribute vec2 uv;\n6attribute vec2 position;\n7\n8varying vec2 vUv;\n9\n10void main() {\n11  vUv = uv;\n12  gl_Position = vec4(position, 0, 1);\n13}\n14`;\n15\n16const fragmentShader = `\n17precision highp float;\n18\n19uniform float uTime;\n20uniform vec3 uColor;\n21uniform vec3 uResolution;\n22uniform vec2 uMouse;\n23uniform float uAmplitude;\n24uniform float uSpeed;\n25\n26varying vec2 vUv;\n27\n28void main() {\n29  float mr = min(uResolution.x, uResolution.y);\n30  vec2 uv = (vUv.xy * 2.0 - 1.0) * uResolution.xy / mr;\n31\n32  // Add a subtle offset based on the mouse position\n33  uv += (uMouse - vec2(0.5)) * uAmplitude;\n34\n35  float d = -uTime * 0.5 * uSpeed;\n36  float a = 0.0;\n37  for (float i = 0.0; i < 8.0; ++i) {\n38    a += cos(i - d - a * uv.x);\n39    d += sin(uv.y * i + a);\n40  }\n41  d += uTime * 0.5 * uSpeed;\n42  vec3 col = vec3(cos(uv * vec2(d, a)) * 0.6 + 0.4, cos(a + d) * 0.5 + 0.5);\n43  col = cos(col * cos(vec3(d, a, 2.5)) * 0.5 + 0.5) * uColor;\n44  gl_FragColor = vec4(col, 1.0);\n45}\n46`;\n47\n48export default function Iridescence({\n49  color = [1, 1, 1],\n50  speed = 1.0,\n51  amplitude = 0.1,\n52  mouseReact = true,\n53  ...rest\n54}) {\n55  const ctnDom = useRef(null);\n56  const mousePos = useRef({ x: 0.5, y: 0.5 });\n57\n58  useEffect(() => {\n59    if (!ctnDom.current) return;\n60    const ctn = ctnDom.current;\n61    const renderer = new Renderer();\n62    const gl = renderer.gl;\n63    gl.clearColor(1, 1, 1, 1);\n64\n65    let program;\n66\n67    function resize() {\n68      const scale = 1;\n69      renderer.setSize(ctn.offsetWidth * scale, ctn.offsetHeight * scale);\n70      if (program) {\n71        program.uniforms.uResolution.value = new Color(\n72          gl.canvas.width,\n73          gl.canvas.height,\n74          gl.canvas.width / gl.canvas.height\n75        );\n76      }\n77    }\n78    window.addEventListener(\"resize\", resize, false);\n79    resize();\n80\n81    const geometry = new Triangle(gl);\n82    program = new Program(gl, {\n83      vertex: vertexShader,\n84      fragment: fragmentShader,\n85      uniforms: {\n86        uTime: { value: 0 },\n87        uColor: { value: new Color(...color) },\n88        uResolution: {\n89          value: new Color(\n90            gl.canvas.width,\n91            gl.canvas.height,\n92            gl.canvas.width / gl.canvas.height\n93          ),\n94        },\n95        uMouse: { value: new Float32Array([mousePos.current.x, mousePos.current.y]) },\n96        uAmplitude: { value: amplitude },\n97        uSpeed: { value: speed },\n98      },\n99    });\n100\n101    const mesh = new Mesh(gl, { geometry, program });\n102    let animateId;\n103\n104    function update(t) {\n105      animateId = requestAnimationFrame(update);\n106      program.uniforms.uTime.value = t * 0.001;\n107      renderer.render({ scene: mesh });\n108    }\n109    animateId = requestAnimationFrame(update);\n110    ctn.appendChild(gl.canvas);\n111\n112    function handleMouseMove(e) {\n113      const rect = ctn.getBoundingClientRect();\n114      const x = (e.clientX - rect.left) / rect.width;\n115      const y = 1.0 - (e.clientY - rect.top) / rect.height;\n116      mousePos.current = { x, y };\n117      program.uniforms.uMouse.value[0] = x;\n118      program.uniforms.uMouse.value[1] = y;\n119    }\n120    if (mouseReact) {\n121      ctn.addEventListener(\"mousemove\", handleMouseMove);\n122    }\n123\n124    return () => {\n125      cancelAnimationFrame(animateId);\n126      window.removeEventListener(\"resize\", resize);\n127      if (mouseReact) {\n128        ctn.removeEventListener(\"mousemove\", handleMouseMove);\n129      }\n130      ctn.removeChild(gl.canvas);\n131      gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n132    };\n133  // eslint-disable-next-line react-hooks/exhaustive-deps\n134  }, [color, speed, amplitude, mouseReact]);\n135\n136  return (\n137    <div\n138      ref={ctnDom}\n139      className=\"w-full h-full\"\n140      {...rest}\n141    />\n142  );\n143}\n144",
  "category": "backgrounds",
  "scrapedAt": "2025-04-27T11:47:41.039Z",
  "previewImage": "iridescence-preview.png"
}