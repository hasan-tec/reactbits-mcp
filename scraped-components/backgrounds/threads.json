{
  "name": "Threads",
  "description": "An open source collection of high quality, animated, interactive & fully customizable React components for building stunning, memorable user interfaces.",
  "props": {},
  "dependencies": [],
  "url": "https://www.reactbits.dev/backgrounds/threads",
  "code": "1npm i ogl\n\n1import Threads from './Threads';\n2\n3<div style={{ width: '100%', height: '600px', position: 'relative' }}>\n4  <Threads\n5    amplitude={1}\n6    distance={0}\n7    enableMouseInteraction={true}\n8  />\n9</div>\n\n1import { useEffect, useRef } from \"react\";\n2import { Renderer, Program, Mesh, Triangle, Color } from \"ogl\";\n3\n4import \"./Threads.css\";\n5\n6const vertexShader = `\n7attribute vec2 position;\n8attribute vec2 uv;\n9varying vec2 vUv;\n10void main() {\n11  vUv = uv;\n12  gl_Position = vec4(position, 0.0, 1.0);\n13}\n14`;\n15\n16const fragmentShader = `\n17precision highp float;\n18\n19uniform float iTime;\n20uniform vec3 iResolution;\n21uniform vec3 uColor;\n22uniform float uAmplitude;\n23uniform float uDistance;\n24uniform vec2 uMouse;\n25\n26#define PI 3.1415926538\n27\n28const int u_line_count = 40;\n29const float u_line_width = 7.0;\n30const float u_line_blur = 10.0;\n31\n32float Perlin2D(vec2 P) {\n33    vec2 Pi = floor(P);\n34    vec4 Pf_Pfmin1 = P.xyxy - vec4(Pi, Pi + 1.0);\n35    vec4 Pt = vec4(Pi.xy, Pi.xy + 1.0);\n36    Pt = Pt - floor(Pt * (1.0 / 71.0)) * 71.0;\n37    Pt += vec2(26.0, 161.0).xyxy;\n38    Pt *= Pt;\n39    Pt = Pt.xzxz * Pt.yyww;\n40    vec4 hash_x = fract(Pt * (1.0 / 951.135664));\n41    vec4 hash_y = fract(Pt * (1.0 / 642.949883));\n42    vec4 grad_x = hash_x - 0.49999;\n43    vec4 grad_y = hash_y - 0.49999;\n44    vec4 grad_results = inversesqrt(grad_x * grad_x + grad_y * grad_y)\n45        * (grad_x * Pf_Pfmin1.xzxz + grad_y * Pf_Pfmin1.yyww);\n46    grad_results *= 1.4142135623730950;\n47    vec2 blend = Pf_Pfmin1.xy * Pf_Pfmin1.xy * Pf_Pfmin1.xy\n48               * (Pf_Pfmin1.xy * (Pf_Pfmin1.xy * 6.0 - 15.0) + 10.0);\n49    vec4 blend2 = vec4(blend, vec2(1.0 - blend));\n50    return dot(grad_results, blend2.zxzx * blend2.wwyy);\n51}\n52\n53float pixel(float count, vec2 resolution) {\n54    return (1.0 / max(resolution.x, resolution.y)) * count;\n55}\n56\n57float lineFn(vec2 st, float width, float perc, float offset, vec2 mouse, float time, float amplitude, float distance) {\n58    float split_offset = (perc * 0.4);\n59    float split_point = 0.1 + split_offset;\n60\n61    float amplitude_normal = smoothstep(split_point, 0.7, st.x);\n62    float amplitude_strength = 0.5;\n63    float finalAmplitude = amplitude_normal * amplitude_strength\n64                           * amplitude * (1.0 + (mouse.y - 0.5) * 0.2);\n65\n66    float time_scaled = time / 10.0 + (mouse.x - 0.5) * 1.0;\n67    float blur = smoothstep(split_point, split_point + 0.05, st.x) * perc;\n68\n69    float xnoise = mix(\n70        Perlin2D(vec2(time_scaled, st.x + perc) * 2.5),\n71        Perlin2D(vec2(time_scaled, st.x + time_scaled) * 3.5) / 1.5,\n72        st.x * 0.3\n73    );\n74\n75    float y = 0.5 + (perc - 0.5) * distance + xnoise / 2.0 * finalAmplitude;\n76\n77    float line_start = smoothstep(\n78        y + (width / 2.0) + (u_line_blur * pixel(1.0, iResolution.xy) * blur),\n79        y,\n80        st.y\n81    );\n82\n83    float line_end = smoothstep(\n84        y,\n85        y - (width / 2.0) - (u_line_blur * pixel(1.0, iResolution.xy) * blur),\n86        st.y\n87    );\n88\n89    return clamp(\n90        (line_start - line_end) * (1.0 - smoothstep(0.0, 1.0, pow(perc, 0.3))),\n91        0.0,\n92        1.0\n93    );\n94}\n95\n96void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n97    vec2 uv = fragCoord / iResolution.xy;\n98\n99    float line_strength = 1.0;\n100    for (int i = 0; i < u_line_count; i++) {\n101        float p = float(i) / float(u_line_count);\n102        line_strength *= (1.0 - lineFn(\n103            uv,\n104            u_line_width * pixel(1.0, iResolution.xy) * (1.0 - p),\n105            p,\n106            (PI * 1.0) * p,\n107            uMouse,\n108            iTime,\n109            uAmplitude,\n110            uDistance\n111        ));\n112    }\n113\n114    float colorVal = 1.0 - line_strength;\n115    fragColor = vec4(uColor * colorVal, colorVal);\n116}\n117\n118void main() {\n119    mainImage(gl_FragColor, gl_FragCoord.xy);\n120}\n121`;\n122\n123const Threads = ({\n124  color = [1, 1, 1],\n125  amplitude = 1,\n126  distance = 0,\n127  enableMouseInteraction = false,\n128  ...rest\n129}) => {\n130  const containerRef = useRef(null);\n131  const animationFrameId = useRef();\n132\n133  useEffect(() => {\n134    if (!containerRef.current) return;\n135    const container = containerRef.current;\n136\n137    const renderer = new Renderer({ alpha: true });\n138    const gl = renderer.gl;\n139    gl.clearColor(0, 0, 0, 0);\n140    gl.enable(gl.BLEND);\n141    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n142    container.appendChild(gl.canvas);\n143\n144    const geometry = new Triangle(gl);\n145    const program = new Program(gl, {\n146      vertex: vertexShader,\n147      fragment: fragmentShader,\n148      uniforms: {\n149        iTime: { value: 0 },\n150        iResolution: {\n151          value: new Color(\n152            gl.canvas.width,\n153            gl.canvas.height,\n154            gl.canvas.width / gl.canvas.height\n155          ),\n156        },\n157        uColor: { value: new Color(...color) },\n158        uAmplitude: { value: amplitude },\n159        uDistance: { value: distance },\n160        uMouse: { value: new Float32Array([0.5, 0.5]) },\n161      },\n162    });\n163\n164    const mesh = new Mesh(gl, { geometry, program });\n165\n166    function resize() {\n167      const { clientWidth, clientHeight } = container;\n168      renderer.setSize(clientWidth, clientHeight);\n169      program.uniforms.iResolution.value.r = clientWidth;\n170      program.uniforms.iResolution.value.g = clientHeight;\n171      program.uniforms.iResolution.value.b = clientWidth / clientHeight;\n172    }\n173    window.addEventListener(\"resize\", resize);\n174    resize();\n175\n176    let currentMouse = [0.5, 0.5];\n177    let targetMouse = [0.5, 0.5];\n178\n179    function handleMouseMove(e) {\n180      const rect = container.getBoundingClientRect();\n181      const x = (e.clientX - rect.left) / rect.width;\n182      const y = 1.0 - (e.clientY - rect.top) / rect.height;\n183      targetMouse = [x, y];\n184    }\n185    function handleMouseLeave() {\n186      targetMouse = [0.5, 0.5];\n187    }\n188    if (enableMouseInteraction) {\n189      container.addEventListener(\"mousemove\", handleMouseMove);\n190      container.addEventListener(\"mouseleave\", handleMouseLeave);\n191    }\n192\n193    function update(t) {\n194      if (enableMouseInteraction) {\n195        const smoothing = 0.05;\n196        currentMouse[0] += smoothing * (targetMouse[0] - currentMouse[0]);\n197        currentMouse[1] += smoothing * (targetMouse[1] - currentMouse[1]);\n198        program.uniforms.uMouse.value[0] = currentMouse[0];\n199        program.uniforms.uMouse.value[1] = currentMouse[1];\n200      } else {\n201        program.uniforms.uMouse.value[0] = 0.5;\n202        program.uniforms.uMouse.value[1] = 0.5;\n203      }\n204      program.uniforms.iTime.value = t * 0.001;\n205\n206      renderer.render({ scene: mesh });\n207      animationFrameId.current = requestAnimationFrame(update);\n208    }\n209    animationFrameId.current = requestAnimationFrame(update);\n210\n211    return () => {\n212      if (animationFrameId.current)\n213        cancelAnimationFrame(animationFrameId.current);\n214      window.removeEventListener(\"resize\", resize);\n215\n216      if (enableMouseInteraction) {\n217        container.removeEventListener(\"mousemove\", handleMouseMove);\n218        container.removeEventListener(\"mouseleave\", handleMouseLeave);\n219      }\n220      if (container.contains(gl.canvas)) container.removeChild(gl.canvas);\n221      gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n222    };\n223  }, [color, amplitude, distance, enableMouseInteraction]);\n224\n225  return <div ref={containerRef} className=\"threads-container\" {...rest} />;\n226};\n227\n228export default Threads;\n229\n\n1.threads-container {\n2  position: relative;\n3  width: 100%;\n4  height: 100%;\n5}\n\n1import { useEffect, useRef } from \"react\";\n2import { Renderer, Program, Mesh, Triangle, Color } from \"ogl\";\n3\n4const vertexShader = `\n5attribute vec2 position;\n6attribute vec2 uv;\n7varying vec2 vUv;\n8void main() {\n9  vUv = uv;\n10  gl_Position = vec4(position, 0.0, 1.0);\n11}\n12`;\n13\n14const fragmentShader = `\n15precision highp float;\n16\n17uniform float iTime;\n18uniform vec3 iResolution;\n19uniform vec3 uColor;\n20uniform float uAmplitude;\n21uniform float uDistance;\n22uniform vec2 uMouse;\n23\n24#define PI 3.1415926538\n25\n26const int u_line_count = 40;\n27const float u_line_width = 7.0;\n28const float u_line_blur = 10.0;\n29\n30float Perlin2D(vec2 P) {\n31    vec2 Pi = floor(P);\n32    vec4 Pf_Pfmin1 = P.xyxy - vec4(Pi, Pi + 1.0);\n33    vec4 Pt = vec4(Pi.xy, Pi.xy + 1.0);\n34    Pt = Pt - floor(Pt * (1.0 / 71.0)) * 71.0;\n35    Pt += vec2(26.0, 161.0).xyxy;\n36    Pt *= Pt;\n37    Pt = Pt.xzxz * Pt.yyww;\n38    vec4 hash_x = fract(Pt * (1.0 / 951.135664));\n39    vec4 hash_y = fract(Pt * (1.0 / 642.949883));\n40    vec4 grad_x = hash_x - 0.49999;\n41    vec4 grad_y = hash_y - 0.49999;\n42    vec4 grad_results = inversesqrt(grad_x * grad_x + grad_y * grad_y)\n43        * (grad_x * Pf_Pfmin1.xzxz + grad_y * Pf_Pfmin1.yyww);\n44    grad_results *= 1.4142135623730950;\n45    vec2 blend = Pf_Pfmin1.xy * Pf_Pfmin1.xy * Pf_Pfmin1.xy\n46               * (Pf_Pfmin1.xy * (Pf_Pfmin1.xy * 6.0 - 15.0) + 10.0);\n47    vec4 blend2 = vec4(blend, vec2(1.0 - blend));\n48    return dot(grad_results, blend2.zxzx * blend2.wwyy);\n49}\n50\n51float pixel(float count, vec2 resolution) {\n52    return (1.0 / max(resolution.x, resolution.y)) * count;\n53}\n54\n55float lineFn(vec2 st, float width, float perc, float offset, vec2 mouse, float time, float amplitude, float distance) {\n56    float split_offset = (perc * 0.4);\n57    float split_point = 0.1 + split_offset;\n58\n59    float amplitude_normal = smoothstep(split_point, 0.7, st.x);\n60    float amplitude_strength = 0.5;\n61    float finalAmplitude = amplitude_normal * amplitude_strength\n62                           * amplitude * (1.0 + (mouse.y - 0.5) * 0.2);\n63\n64    float time_scaled = time / 10.0 + (mouse.x - 0.5) * 1.0;\n65    float blur = smoothstep(split_point, split_point + 0.05, st.x) * perc;\n66\n67    float xnoise = mix(\n68        Perlin2D(vec2(time_scaled, st.x + perc) * 2.5),\n69        Perlin2D(vec2(time_scaled, st.x + time_scaled) * 3.5) / 1.5,\n70        st.x * 0.3\n71    );\n72\n73    float y = 0.5 + (perc - 0.5) * distance + xnoise / 2.0 * finalAmplitude;\n74\n75    float line_start = smoothstep(\n76        y + (width / 2.0) + (u_line_blur * pixel(1.0, iResolution.xy) * blur),\n77        y,\n78        st.y\n79    );\n80\n81    float line_end = smoothstep(\n82        y,\n83        y - (width / 2.0) - (u_line_blur * pixel(1.0, iResolution.xy) * blur),\n84        st.y\n85    );\n86\n87    return clamp(\n88        (line_start - line_end) * (1.0 - smoothstep(0.0, 1.0, pow(perc, 0.3))),\n89        0.0,\n90        1.0\n91    );\n92}\n93\n94void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n95    vec2 uv = fragCoord / iResolution.xy;\n96\n97    float line_strength = 1.0;\n98    for (int i = 0; i < u_line_count; i++) {\n99        float p = float(i) / float(u_line_count);\n100        line_strength *= (1.0 - lineFn(\n101            uv,\n102            u_line_width * pixel(1.0, iResolution.xy) * (1.0 - p),\n103            p,\n104            (PI * 1.0) * p,\n105            uMouse,\n106            iTime,\n107            uAmplitude,\n108            uDistance\n109        ));\n110    }\n111\n112    float colorVal = 1.0 - line_strength;\n113    fragColor = vec4(uColor * colorVal, colorVal);\n114}\n115\n116void main() {\n117    mainImage(gl_FragColor, gl_FragCoord.xy);\n118}\n119`;\n120\n121const Threads = ({\n122  color = [1, 1, 1],\n123  amplitude = 1,\n124  distance = 0,\n125  enableMouseInteraction = false,\n126  ...rest\n127}) => {\n128  const containerRef = useRef(null);\n129  const animationFrameId = useRef();\n130\n131  useEffect(() => {\n132    if (!containerRef.current) return;\n133    const container = containerRef.current;\n134\n135    const renderer = new Renderer({ alpha: true });\n136    const gl = renderer.gl;\n137    gl.clearColor(0, 0, 0, 0);\n138    gl.enable(gl.BLEND);\n139    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n140    container.appendChild(gl.canvas);\n141\n142    const geometry = new Triangle(gl);\n143    const program = new Program(gl, {\n144      vertex: vertexShader,\n145      fragment: fragmentShader,\n146      uniforms: {\n147        iTime: { value: 0 },\n148        iResolution: {\n149          value: new Color(\n150            gl.canvas.width,\n151            gl.canvas.height,\n152            gl.canvas.width / gl.canvas.height\n153          ),\n154        },\n155        uColor: { value: new Color(...color) },\n156        uAmplitude: { value: amplitude },\n157        uDistance: { value: distance },\n158        uMouse: { value: new Float32Array([0.5, 0.5]) },\n159      },\n160    });\n161\n162    const mesh = new Mesh(gl, { geometry, program });\n163\n164    function resize() {\n165      const { clientWidth, clientHeight } = container;\n166      renderer.setSize(clientWidth, clientHeight);\n167      program.uniforms.iResolution.value.r = clientWidth;\n168      program.uniforms.iResolution.value.g = clientHeight;\n169      program.uniforms.iResolution.value.b = clientWidth / clientHeight;\n170    }\n171    window.addEventListener(\"resize\", resize);\n172    resize();\n173\n174    let currentMouse = [0.5, 0.5];\n175    let targetMouse = [0.5, 0.5];\n176\n177    function handleMouseMove(e) {\n178      const rect = container.getBoundingClientRect();\n179      const x = (e.clientX - rect.left) / rect.width;\n180      const y = 1.0 - (e.clientY - rect.top) / rect.height;\n181      targetMouse = [x, y];\n182    }\n183    function handleMouseLeave() {\n184      targetMouse = [0.5, 0.5];\n185    }\n186    if (enableMouseInteraction) {\n187      container.addEventListener(\"mousemove\", handleMouseMove);\n188      container.addEventListener(\"mouseleave\", handleMouseLeave);\n189    }\n190\n191    function update(t) {\n192      if (enableMouseInteraction) {\n193        const smoothing = 0.05;\n194        currentMouse[0] += smoothing * (targetMouse[0] - currentMouse[0]);\n195        currentMouse[1] += smoothing * (targetMouse[1] - currentMouse[1]);\n196        program.uniforms.uMouse.value[0] = currentMouse[0];\n197        program.uniforms.uMouse.value[1] = currentMouse[1];\n198      } else {\n199        program.uniforms.uMouse.value[0] = 0.5;\n200        program.uniforms.uMouse.value[1] = 0.5;\n201      }\n202      program.uniforms.iTime.value = t * 0.001;\n203\n204      renderer.render({ scene: mesh });\n205      animationFrameId.current = requestAnimationFrame(update);\n206    }\n207    animationFrameId.current = requestAnimationFrame(update);\n208\n209    return () => {\n210      if (animationFrameId.current)\n211        cancelAnimationFrame(animationFrameId.current);\n212      window.removeEventListener(\"resize\", resize);\n213\n214      if (enableMouseInteraction) {\n215        container.removeEventListener(\"mousemove\", handleMouseMove);\n216        container.removeEventListener(\"mouseleave\", handleMouseLeave);\n217      }\n218      if (container.contains(gl.canvas)) container.removeChild(gl.canvas);\n219      gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n220    };\n221  }, [color, amplitude, distance, enableMouseInteraction]);\n222\n223  return <div ref={containerRef} className=\"w-full h-full relative\" {...rest} />;\n224};\n225\n226export default Threads;\n227",
  "category": "backgrounds",
  "scrapedAt": "2025-04-27T11:48:15.860Z",
  "previewImage": "threads-preview.png"
}