{
  "name": "Particles",
  "description": "An open source collection of high quality, animated, interactive & fully customizable React components for building stunning, memorable user interfaces.",
  "props": {},
  "dependencies": [],
  "url": "https://www.reactbits.dev/backgrounds/particles",
  "code": "1npm i ogl\n\n1import Particles from './Particles';\n2\n3<div style={{ width: '100%', height: '600px', position: 'relative' }}>\n4  <Particles\n5    particleColors={['#ffffff', '#ffffff']}\n6    particleCount={200}\n7    particleSpread={10}\n8    speed={0.1}\n9    particleBaseSize={100}\n10    moveParticlesOnHover={true}\n11    alphaParticles={false}\n12    disableRotation={false}\n13  />\n14</div>\n\n1import { useEffect, useRef } from \"react\";\n2import { Renderer, Camera, Geometry, Program, Mesh } from \"ogl\";\n3\n4import './Particles.css';\n5\n6const defaultColors = [\"#ffffff\", \"#ffffff\", \"#ffffff\"];\n7\n8const hexToRgb = (hex) => {\n9  hex = hex.replace(/^#/, \"\");\n10  if (hex.length === 3) {\n11    hex = hex.split(\"\").map((c) => c + c).join(\"\");\n12  }\n13  const int = parseInt(hex, 16);\n14  const r = ((int >> 16) & 255) / 255;\n15  const g = ((int >> 8) & 255) / 255;\n16  const b = (int & 255) / 255;\n17  return [r, g, b];\n18};\n19\n20const vertex = /* glsl */ `\n21  attribute vec3 position;\n22  attribute vec4 random;\n23  attribute vec3 color;\n24  \n25  uniform mat4 modelMatrix;\n26  uniform mat4 viewMatrix;\n27  uniform mat4 projectionMatrix;\n28  uniform float uTime;\n29  uniform float uSpread;\n30  uniform float uBaseSize;\n31  uniform float uSizeRandomness;\n32  \n33  varying vec4 vRandom;\n34  varying vec3 vColor;\n35  \n36  void main() {\n37    vRandom = random;\n38    vColor = color;\n39    \n40    vec3 pos = position * uSpread;\n41    pos.z *= 10.0;\n42    \n43    vec4 mPos = modelMatrix * vec4(pos, 1.0);\n44    float t = uTime;\n45    mPos.x += sin(t * random.z + 6.28 * random.w) * mix(0.1, 1.5, random.x);\n46    mPos.y += sin(t * random.y + 6.28 * random.x) * mix(0.1, 1.5, random.w);\n47    mPos.z += sin(t * random.w + 6.28 * random.y) * mix(0.1, 1.5, random.z);\n48    \n49    vec4 mvPos = viewMatrix * mPos;\n50    gl_PointSize = (uBaseSize * (1.0 + uSizeRandomness * (random.x - 0.5))) / length(mvPos.xyz);\n51    gl_Position = projectionMatrix * mvPos;\n52  }\n53`;\n54\n55const fragment = /* glsl */ `\n56  precision highp float;\n57  \n58  uniform float uTime;\n59  uniform float uAlphaParticles;\n60  varying vec4 vRandom;\n61  varying vec3 vColor;\n62  \n63  void main() {\n64    vec2 uv = gl_PointCoord.xy;\n65    float d = length(uv - vec2(0.5));\n66    \n67    if(uAlphaParticles < 0.5) {\n68      if(d > 0.5) {\n69        discard;\n70      }\n71      gl_FragColor = vec4(vColor + 0.2 * sin(uv.yxx + uTime + vRandom.y * 6.28), 1.0);\n72    } else {\n73      float circle = smoothstep(0.5, 0.4, d) * 0.8;\n74      gl_FragColor = vec4(vColor + 0.2 * sin(uv.yxx + uTime + vRandom.y * 6.28), circle);\n75    }\n76  }\n77`;\n78\n79const Particles = ({\n80  particleCount = 200,\n81  particleSpread = 10,\n82  speed = 0.1,\n83  particleColors,\n84  moveParticlesOnHover = false,\n85  particleHoverFactor = 1,\n86  alphaParticles = false,\n87  particleBaseSize = 100,\n88  sizeRandomness = 1,\n89  cameraDistance = 20,\n90  disableRotation = false,\n91  className,\n92}) => {\n93  const containerRef = useRef(null);\n94  const mouseRef = useRef({ x: 0, y: 0 });\n95\n96  useEffect(() => {\n97    const container = containerRef.current;\n98    if (!container) return;\n99\n100    const renderer = new Renderer({ depth: false, alpha: true });\n101    const gl = renderer.gl;\n102    container.appendChild(gl.canvas);\n103    gl.clearColor(0, 0, 0, 0);\n104\n105    const camera = new Camera(gl, { fov: 15 });\n106    camera.position.set(0, 0, cameraDistance);\n107\n108    const resize = () => {\n109      const width = container.clientWidth;\n110      const height = container.clientHeight;\n111      renderer.setSize(width, height);\n112      camera.perspective({ aspect: gl.canvas.width / gl.canvas.height });\n113    };\n114    window.addEventListener(\"resize\", resize, false);\n115    resize();\n116\n117    const handleMouseMove = (e) => {\n118      const rect = container.getBoundingClientRect();\n119      const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;\n120      const y = -(((e.clientY - rect.top) / rect.height) * 2 - 1);\n121      mouseRef.current = { x, y };\n122    };\n123\n124    if (moveParticlesOnHover) {\n125      container.addEventListener(\"mousemove\", handleMouseMove);\n126    }\n127\n128    const count = particleCount;\n129    const positions = new Float32Array(count * 3);\n130    const randoms = new Float32Array(count * 4);\n131    const colors = new Float32Array(count * 3);\n132    const palette = particleColors && particleColors.length > 0 ? particleColors : defaultColors;\n133\n134    for (let i = 0; i < count; i++) {\n135      let x, y, z, len;\n136      do {\n137        x = Math.random() * 2 - 1;\n138        y = Math.random() * 2 - 1;\n139        z = Math.random() * 2 - 1;\n140        len = x * x + y * y + z * z;\n141      } while (len > 1 || len === 0);\n142      const r = Math.cbrt(Math.random());\n143      positions.set([x * r, y * r, z * r], i * 3);\n144      randoms.set([Math.random(), Math.random(), Math.random(), Math.random()], i * 4);\n145      const col = hexToRgb(palette[Math.floor(Math.random() * palette.length)]);\n146      colors.set(col, i * 3);\n147    }\n148\n149    const geometry = new Geometry(gl, {\n150      position: { size: 3, data: positions },\n151      random: { size: 4, data: randoms },\n152      color: { size: 3, data: colors },\n153    });\n154\n155    const program = new Program(gl, {\n156      vertex,\n157      fragment,\n158      uniforms: {\n159        uTime: { value: 0 },\n160        uSpread: { value: particleSpread },\n161        uBaseSize: { value: particleBaseSize },\n162        uSizeRandomness: { value: sizeRandomness },\n163        uAlphaParticles: { value: alphaParticles ? 1 : 0 },\n164      },\n165      transparent: true,\n166      depthTest: false,\n167    });\n168\n169    const particles = new Mesh(gl, { mode: gl.POINTS, geometry, program });\n170\n171    let animationFrameId;\n172    let lastTime = performance.now();\n173    let elapsed = 0;\n174\n175    const update = (t) => {\n176      animationFrameId = requestAnimationFrame(update);\n177      const delta = t - lastTime;\n178      lastTime = t;\n179      elapsed += delta * speed;\n180\n181      program.uniforms.uTime.value = elapsed * 0.001;\n182\n183      if (moveParticlesOnHover) {\n184        particles.position.x = -mouseRef.current.x * particleHoverFactor;\n185        particles.position.y = -mouseRef.current.y * particleHoverFactor;\n186      } else {\n187        particles.position.x = 0;\n188        particles.position.y = 0;\n189      }\n190\n191      if (!disableRotation) {\n192        particles.rotation.x = Math.sin(elapsed * 0.0002) * 0.1;\n193        particles.rotation.y = Math.cos(elapsed * 0.0005) * 0.15;\n194        particles.rotation.z += 0.01 * speed;\n195      }\n196\n197      renderer.render({ scene: particles, camera });\n198    };\n199\n200    animationFrameId = requestAnimationFrame(update);\n201\n202    return () => {\n203      window.removeEventListener(\"resize\", resize);\n204      if (moveParticlesOnHover) {\n205        container.removeEventListener(\"mousemove\", handleMouseMove);\n206      }\n207      cancelAnimationFrame(animationFrameId);\n208      if (container.contains(gl.canvas)) {\n209        container.removeChild(gl.canvas);\n210      }\n211    };\n212    // eslint-disable-next-line react-hooks/exhaustive-deps\n213  }, [\n214    particleCount,\n215    particleSpread,\n216    speed,\n217    moveParticlesOnHover,\n218    particleHoverFactor,\n219    alphaParticles,\n220    particleBaseSize,\n221    sizeRandomness,\n222    cameraDistance,\n223    disableRotation,\n224  ]);\n225\n226  return (\n227    <div\n228      ref={containerRef}\n229      className={`particles-container ${className}`}\n230    />\n231  );\n232};\n233\n234export default Particles;\n235\n\n1.particles-container {\n2  position: relative;\n3  width: 100%;\n4  height: 100%;\n5}\n\n1import { useEffect, useRef } from \"react\";\n2import { Renderer, Camera, Geometry, Program, Mesh } from \"ogl\";\n3\n4const defaultColors = [\"#ffffff\", \"#ffffff\", \"#ffffff\"];\n5\n6const hexToRgb = (hex) => {\n7  hex = hex.replace(/^#/, \"\");\n8  if (hex.length === 3) {\n9    hex = hex.split(\"\").map((c) => c + c).join(\"\");\n10  }\n11  const int = parseInt(hex, 16);\n12  const r = ((int >> 16) & 255) / 255;\n13  const g = ((int >> 8) & 255) / 255;\n14  const b = (int & 255) / 255;\n15  return [r, g, b];\n16};\n17\n18const vertex = /* glsl */ `\n19  attribute vec3 position;\n20  attribute vec4 random;\n21  attribute vec3 color;\n22  \n23  uniform mat4 modelMatrix;\n24  uniform mat4 viewMatrix;\n25  uniform mat4 projectionMatrix;\n26  uniform float uTime;\n27  uniform float uSpread;\n28  uniform float uBaseSize;\n29  uniform float uSizeRandomness;\n30  \n31  varying vec4 vRandom;\n32  varying vec3 vColor;\n33  \n34  void main() {\n35    vRandom = random;\n36    vColor = color;\n37    \n38    vec3 pos = position * uSpread;\n39    pos.z *= 10.0;\n40    \n41    vec4 mPos = modelMatrix * vec4(pos, 1.0);\n42    float t = uTime;\n43    mPos.x += sin(t * random.z + 6.28 * random.w) * mix(0.1, 1.5, random.x);\n44    mPos.y += sin(t * random.y + 6.28 * random.x) * mix(0.1, 1.5, random.w);\n45    mPos.z += sin(t * random.w + 6.28 * random.y) * mix(0.1, 1.5, random.z);\n46    \n47    vec4 mvPos = viewMatrix * mPos;\n48    gl_PointSize = (uBaseSize * (1.0 + uSizeRandomness * (random.x - 0.5))) / length(mvPos.xyz);\n49    gl_Position = projectionMatrix * mvPos;\n50  }\n51`;\n52\n53const fragment = /* glsl */ `\n54  precision highp float;\n55  \n56  uniform float uTime;\n57  uniform float uAlphaParticles;\n58  varying vec4 vRandom;\n59  varying vec3 vColor;\n60  \n61  void main() {\n62    vec2 uv = gl_PointCoord.xy;\n63    float d = length(uv - vec2(0.5));\n64    \n65    if(uAlphaParticles < 0.5) {\n66      if(d > 0.5) {\n67        discard;\n68      }\n69      gl_FragColor = vec4(vColor + 0.2 * sin(uv.yxx + uTime + vRandom.y * 6.28), 1.0);\n70    } else {\n71      float circle = smoothstep(0.5, 0.4, d) * 0.8;\n72      gl_FragColor = vec4(vColor + 0.2 * sin(uv.yxx + uTime + vRandom.y * 6.28), circle);\n73    }\n74  }\n75`;\n76\n77const Particles = ({\n78  particleCount = 200,\n79  particleSpread = 10,\n80  speed = 0.1,\n81  particleColors,\n82  moveParticlesOnHover = false,\n83  particleHoverFactor = 1,\n84  alphaParticles = false,\n85  particleBaseSize = 100,\n86  sizeRandomness = 1,\n87  cameraDistance = 20,\n88  disableRotation = false,\n89  className,\n90}) => {\n91  const containerRef = useRef(null);\n92  const mouseRef = useRef({ x: 0, y: 0 });\n93\n94  useEffect(() => {\n95    const container = containerRef.current;\n96    if (!container) return;\n97\n98    const renderer = new Renderer({ depth: false, alpha: true });\n99    const gl = renderer.gl;\n100    container.appendChild(gl.canvas);\n101    gl.clearColor(0, 0, 0, 0);\n102\n103    const camera = new Camera(gl, { fov: 15 });\n104    camera.position.set(0, 0, cameraDistance);\n105\n106    const resize = () => {\n107      const width = container.clientWidth;\n108      const height = container.clientHeight;\n109      renderer.setSize(width, height);\n110      camera.perspective({ aspect: gl.canvas.width / gl.canvas.height });\n111    };\n112    window.addEventListener(\"resize\", resize, false);\n113    resize();\n114\n115    const handleMouseMove = (e) => {\n116      const rect = container.getBoundingClientRect();\n117      const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;\n118      const y = -(((e.clientY - rect.top) / rect.height) * 2 - 1);\n119      mouseRef.current = { x, y };\n120    };\n121\n122    if (moveParticlesOnHover) {\n123      container.addEventListener(\"mousemove\", handleMouseMove);\n124    }\n125\n126    const count = particleCount;\n127    const positions = new Float32Array(count * 3);\n128    const randoms = new Float32Array(count * 4);\n129    const colors = new Float32Array(count * 3);\n130    const palette = particleColors && particleColors.length > 0 ? particleColors : defaultColors;\n131\n132    for (let i = 0; i < count; i++) {\n133      let x, y, z, len;\n134      do {\n135        x = Math.random() * 2 - 1;\n136        y = Math.random() * 2 - 1;\n137        z = Math.random() * 2 - 1;\n138        len = x * x + y * y + z * z;\n139      } while (len > 1 || len === 0);\n140      const r = Math.cbrt(Math.random());\n141      positions.set([x * r, y * r, z * r], i * 3);\n142      randoms.set([Math.random(), Math.random(), Math.random(), Math.random()], i * 4);\n143      const col = hexToRgb(palette[Math.floor(Math.random() * palette.length)]);\n144      colors.set(col, i * 3);\n145    }\n146\n147    const geometry = new Geometry(gl, {\n148      position: { size: 3, data: positions },\n149      random: { size: 4, data: randoms },\n150      color: { size: 3, data: colors },\n151    });\n152\n153    const program = new Program(gl, {\n154      vertex,\n155      fragment,\n156      uniforms: {\n157        uTime: { value: 0 },\n158        uSpread: { value: particleSpread },\n159        uBaseSize: { value: particleBaseSize },\n160        uSizeRandomness: { value: sizeRandomness },\n161        uAlphaParticles: { value: alphaParticles ? 1 : 0 },\n162      },\n163      transparent: true,\n164      depthTest: false,\n165    });\n166\n167    const particles = new Mesh(gl, { mode: gl.POINTS, geometry, program });\n168\n169    let animationFrameId;\n170    let lastTime = performance.now();\n171    let elapsed = 0;\n172\n173    const update = (t) => {\n174      animationFrameId = requestAnimationFrame(update);\n175      const delta = t - lastTime;\n176      lastTime = t;\n177      elapsed += delta * speed;\n178\n179      program.uniforms.uTime.value = elapsed * 0.001;\n180\n181      if (moveParticlesOnHover) {\n182        particles.position.x = -mouseRef.current.x * particleHoverFactor;\n183        particles.position.y = -mouseRef.current.y * particleHoverFactor;\n184      } else {\n185        particles.position.x = 0;\n186        particles.position.y = 0;\n187      }\n188\n189      if (!disableRotation) {\n190        particles.rotation.x = Math.sin(elapsed * 0.0002) * 0.1;\n191        particles.rotation.y = Math.cos(elapsed * 0.0005) * 0.15;\n192        particles.rotation.z += 0.01 * speed;\n193      }\n194\n195      renderer.render({ scene: particles, camera });\n196    };\n197\n198    animationFrameId = requestAnimationFrame(update);\n199\n200    return () => {\n201      window.removeEventListener(\"resize\", resize);\n202      if (moveParticlesOnHover) {\n203        container.removeEventListener(\"mousemove\", handleMouseMove);\n204      }\n205      cancelAnimationFrame(animationFrameId);\n206      if (container.contains(gl.canvas)) {\n207        container.removeChild(gl.canvas);\n208      }\n209    };\n210    // eslint-disable-next-line react-hooks/exhaustive-deps\n211  }, [\n212    particleCount,\n213    particleSpread,\n214    speed,\n215    moveParticlesOnHover,\n216    particleHoverFactor,\n217    alphaParticles,\n218    particleBaseSize,\n219    sizeRandomness,\n220    cameraDistance,\n221    disableRotation,\n222  ]);\n223\n224  return (\n225    <div\n226      ref={containerRef}\n227      className={`relative w-full h-full ${className}`}\n228    />\n229  );\n230};\n231\n232export default Particles;\n233",
  "category": "backgrounds",
  "scrapedAt": "2025-04-27T11:47:29.753Z",
  "previewImage": "particles-preview.png"
}