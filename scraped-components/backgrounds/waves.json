{
  "name": "Waves",
  "description": "An open source collection of high quality, animated, interactive & fully customizable React components for building stunning, memorable user interfaces.",
  "props": {},
  "dependencies": [],
  "url": "https://www.reactbits.dev/backgrounds/waves",
  "code": "1import Waves from './Waves';\n2\n3<Waves\n4  lineColor=\"#fff\"\n5  backgroundColor=\"rgba(255, 255, 255, 0.2)\"\n6  waveSpeedX={0.02}\n7  waveSpeedY={0.01}\n8  waveAmpX={40}\n9  waveAmpY={20}\n10  friction={0.9}\n11  tension={0.01}\n12  maxCursorMove={120}\n13  xGap={12}\n14  yGap={36}\n15/>\n\n1import { useRef, useEffect } from \"react\";\n2import './Waves.css';\n3\n4class Grad {\n5  constructor(x, y, z) {\n6    this.x = x; this.y = y; this.z = z;\n7  }\n8  dot2(x, y) { return this.x * x + this.y * y; }\n9}\n10\n11class Noise {\n12  constructor(seed = 0) {\n13    this.grad3 = [\n14      new Grad(1, 1, 0), new Grad(-1, 1, 0), new Grad(1, -1, 0), new Grad(-1, -1, 0),\n15      new Grad(1, 0, 1), new Grad(-1, 0, 1), new Grad(1, 0, -1), new Grad(-1, 0, -1),\n16      new Grad(0, 1, 1), new Grad(0, -1, 1), new Grad(0, 1, -1), new Grad(0, -1, -1)\n17    ];\n18    this.p = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30,\n19      69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219,\n20      203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74,\n21      165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105,\n22      92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208,\n23      89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217,\n24      226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17,\n25      182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167,\n26      43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246,\n27      97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239,\n28      107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,\n29      138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180\n30    ];\n31    this.perm = new Array(512);\n32    this.gradP = new Array(512);\n33    this.seed(seed);\n34  }\n35  seed(seed) {\n36    if (seed > 0 && seed < 1) seed *= 65536;\n37    seed = Math.floor(seed);\n38    if (seed < 256) seed |= seed << 8;\n39    for (let i = 0; i < 256; i++) {\n40      let v = (i & 1) ? (this.p[i] ^ (seed & 255)) : (this.p[i] ^ ((seed >> 8) & 255));\n41      this.perm[i] = this.perm[i + 256] = v;\n42      this.gradP[i] = this.gradP[i + 256] = this.grad3[v % 12];\n43    }\n44  }\n45  fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }\n46  lerp(a, b, t) { return (1 - t) * a + t * b; }\n47  perlin2(x, y) {\n48    let X = Math.floor(x), Y = Math.floor(y);\n49    x -= X; y -= Y; X &= 255; Y &= 255;\n50    const n00 = this.gradP[X + this.perm[Y]].dot2(x, y);\n51    const n01 = this.gradP[X + this.perm[Y + 1]].dot2(x, y - 1);\n52    const n10 = this.gradP[X + 1 + this.perm[Y]].dot2(x - 1, y);\n53    const n11 = this.gradP[X + 1 + this.perm[Y + 1]].dot2(x - 1, y - 1);\n54    const u = this.fade(x);\n55    return this.lerp(\n56      this.lerp(n00, n10, u),\n57      this.lerp(n01, n11, u),\n58      this.fade(y)\n59    );\n60  }\n61}\n62\n63const Waves = ({\n64  lineColor = \"black\",\n65  backgroundColor = \"transparent\",\n66  waveSpeedX = 0.0125,\n67  waveSpeedY = 0.005,\n68  waveAmpX = 32,\n69  waveAmpY = 16,\n70  xGap = 10,\n71  yGap = 32,\n72  friction = 0.925,\n73  tension = 0.005,\n74  maxCursorMove = 100,\n75  style = {},\n76  className = \"\"\n77}) => {\n78  const containerRef = useRef(null);\n79  const canvasRef = useRef(null);\n80  const ctxRef = useRef(null);\n81  const boundingRef = useRef({ width: 0, height: 0, left: 0, top: 0 });\n82  const noiseRef = useRef(new Noise(Math.random()));\n83  const linesRef = useRef([]);\n84  const mouseRef = useRef({\n85    x: -10, y: 0, lx: 0, ly: 0, sx: 0, sy: 0, v: 0, vs: 0, a: 0, set: false\n86  });\n87  const configRef = useRef({\n88    lineColor, waveSpeedX, waveSpeedY, waveAmpX, waveAmpY,\n89    friction, tension, maxCursorMove, xGap, yGap\n90  });\n91  const frameIdRef = useRef(null);\n92\n93  useEffect(() => {\n94    configRef.current = { lineColor, waveSpeedX, waveSpeedY, waveAmpX, waveAmpY, friction, tension, maxCursorMove, xGap, yGap };\n95  }, [lineColor, waveSpeedX, waveSpeedY, waveAmpX, waveAmpY, friction, tension, maxCursorMove, xGap, yGap]);\n96\n97  useEffect(() => {\n98    console.log(\"Waves mounted\");\n99    const canvas = canvasRef.current;\n100    const container = containerRef.current;\n101    ctxRef.current = canvas.getContext(\"2d\");\n102\n103    function setSize() {\n104      boundingRef.current = container.getBoundingClientRect();\n105      canvas.width = boundingRef.current.width;\n106      canvas.height = boundingRef.current.height;\n107    }\n108\n109    function setLines() {\n110      const { width, height } = boundingRef.current;\n111      linesRef.current = [];\n112      const oWidth = width + 200, oHeight = height + 30;\n113      const { xGap, yGap } = configRef.current;\n114      const totalLines = Math.ceil(oWidth / xGap);\n115      const totalPoints = Math.ceil(oHeight / yGap);\n116      const xStart = (width - xGap * totalLines) / 2;\n117      const yStart = (height - yGap * totalPoints) / 2;\n118      for (let i = 0; i <= totalLines; i++) {\n119        const pts = [];\n120        for (let j = 0; j <= totalPoints; j++) {\n121          pts.push({\n122            x: xStart + xGap * i,\n123            y: yStart + yGap * j,\n124            wave: { x: 0, y: 0 },\n125            cursor: { x: 0, y: 0, vx: 0, vy: 0 }\n126          });\n127        }\n128        linesRef.current.push(pts);\n129      }\n130    }\n131\n132    function movePoints(time) {\n133      const lines = linesRef.current, mouse = mouseRef.current, noise = noiseRef.current;\n134      const { waveSpeedX, waveSpeedY, waveAmpX, waveAmpY, friction, tension, maxCursorMove } = configRef.current;\n135      lines.forEach((pts) => {\n136        pts.forEach((p) => {\n137          const move = noise.perlin2(\n138            (p.x + time * waveSpeedX) * 0.002,\n139            (p.y + time * waveSpeedY) * 0.0015\n140          ) * 12;\n141          p.wave.x = Math.cos(move) * waveAmpX;\n142          p.wave.y = Math.sin(move) * waveAmpY;\n143\n144          const dx = p.x - mouse.sx, dy = p.y - mouse.sy;\n145          const dist = Math.hypot(dx, dy), l = Math.max(175, mouse.vs);\n146          if (dist < l) {\n147            const s = 1 - dist / l;\n148            const f = Math.cos(dist * 0.001) * s;\n149            p.cursor.vx += Math.cos(mouse.a) * f * l * mouse.vs * 0.00065;\n150            p.cursor.vy += Math.sin(mouse.a) * f * l * mouse.vs * 0.00065;\n151          }\n152\n153          p.cursor.vx += (0 - p.cursor.x) * tension;\n154          p.cursor.vy += (0 - p.cursor.y) * tension;\n155          p.cursor.vx *= friction;\n156          p.cursor.vy *= friction;\n157          p.cursor.x += p.cursor.vx * 2;\n158          p.cursor.y += p.cursor.vy * 2;\n159          p.cursor.x = Math.min(maxCursorMove, Math.max(-maxCursorMove, p.cursor.x));\n160          p.cursor.y = Math.min(maxCursorMove, Math.max(-maxCursorMove, p.cursor.y));\n161        });\n162      });\n163    }\n164\n165    function moved(point, withCursor = true) {\n166      const x = point.x + point.wave.x + (withCursor ? point.cursor.x : 0);\n167      const y = point.y + point.wave.y + (withCursor ? point.cursor.y : 0);\n168      return { x: Math.round(x * 10) / 10, y: Math.round(y * 10) / 10 };\n169    }\n170\n171    function drawLines() {\n172      const { width, height } = boundingRef.current;\n173      const ctx = ctxRef.current;\n174      ctx.clearRect(0, 0, width, height);\n175      ctx.beginPath();\n176      ctx.strokeStyle = configRef.current.lineColor;\n177      linesRef.current.forEach((points) => {\n178        let p1 = moved(points[0], false);\n179        ctx.moveTo(p1.x, p1.y);\n180        points.forEach((p, idx) => {\n181          const isLast = idx === points.length - 1;\n182          p1 = moved(p, !isLast);\n183          const p2 = moved(points[idx + 1] || points[points.length - 1], !isLast);\n184          ctx.lineTo(p1.x, p1.y);\n185          if (isLast) ctx.moveTo(p2.x, p2.y);\n186        });\n187      });\n188      ctx.stroke();\n189    }\n190\n191    function tick(t) {\n192      const mouse = mouseRef.current;\n193      mouse.sx += (mouse.x - mouse.sx) * 0.1;\n194      mouse.sy += (mouse.y - mouse.sy) * 0.1;\n195      const dx = mouse.x - mouse.lx, dy = mouse.y - mouse.ly;\n196      const d = Math.hypot(dx, dy);\n197      mouse.v = d;\n198      mouse.vs += (d - mouse.vs) * 0.1;\n199      mouse.vs = Math.min(100, mouse.vs);\n200      mouse.lx = mouse.x; mouse.ly = mouse.y;\n201      mouse.a = Math.atan2(dy, dx);\n202      container.style.setProperty(\"--x\", `${mouse.sx}px`);\n203      container.style.setProperty(\"--y\", `${mouse.sy}px`);\n204\n205      movePoints(t);\n206      drawLines();\n207      frameIdRef.current = requestAnimationFrame(tick);\n208    }\n209\n210    function onResize() {\n211      setSize();\n212      setLines();\n213    }\n214    function onMouseMove(e) { updateMouse(e.clientX, e.clientY); }\n215    function onTouchMove(e) {\n216      const touch = e.touches[0];\n217      updateMouse(touch.clientX, touch.clientY);\n218    }\n219    function updateMouse(x, y) {\n220      const mouse = mouseRef.current, b = boundingRef.current;\n221      mouse.x = x - b.left;\n222      mouse.y = y - b.top;\n223      if (!mouse.set) {\n224        mouse.sx = mouse.x; mouse.sy = mouse.y;\n225        mouse.lx = mouse.x; mouse.ly = mouse.y;\n226        mouse.set = true;\n227      }\n228    }\n229\n230    setSize();\n231    setLines();\n232    frameIdRef.current = requestAnimationFrame(tick);\n233    window.addEventListener(\"resize\", onResize);\n234    window.addEventListener(\"mousemove\", onMouseMove);\n235    window.addEventListener(\"touchmove\", onTouchMove, { passive: false });\n236\n237    return () => {\n238      window.removeEventListener(\"resize\", onResize);\n239      window.removeEventListener(\"mousemove\", onMouseMove);\n240      window.removeEventListener(\"touchmove\", onTouchMove);\n241      cancelAnimationFrame(frameIdRef.current);\n242    };\n243  }, []);\n244\n245  return (\n246    <div\n247      ref={containerRef}\n248      className={`waves ${className}`}\n249      style={{\n250        position: \"absolute\",\n251        top: 0, left: 0, margin: 0, padding: 0,\n252        width: \"100%\", height: \"100%\", overflow: \"hidden\",\n253        backgroundColor,\n254        ...style\n255      }}\n256    >\n257      <canvas ref={canvasRef} className=\"waves-canvas\" />\n258    </div>\n259  );\n260}\n261\n262export default Waves;\n263\n\n1.waves {\n2  position: absolute;\n3  top: 0;\n4  left: 0;\n5  margin: 0;\n6  padding: 0;\n7  width: 100%;\n8  height: 100%;\n9  overflow: hidden;\n10}\n11\n12.waves::before {\n13  content: \"\";\n14  position: absolute;\n15  top: 0;\n16  left: 0;\n17  width: 0.5rem;\n18  height: 0.5rem;\n19  background: #160000;\n20  border-radius: 50%;\n21  transform: translate3d(calc(var(-0.5rem) - 50%), calc(var(50%) - 50%), 0);\n22  will-change: transform;\n23}\n24\n25.waves-canvas {\n26  display: block;\n27  width: 100%;\n28  height: 100%;\n29}\n\n1import { useRef, useEffect } from \"react\";\n2\n3class Grad {\n4  constructor(x, y, z) {\n5    this.x = x; this.y = y; this.z = z;\n6  }\n7  dot2(x, y) { return this.x * x + this.y * y; }\n8}\n9\n10class Noise {\n11  constructor(seed = 0) {\n12    this.grad3 = [\n13      new Grad(1, 1, 0), new Grad(-1, 1, 0), new Grad(1, -1, 0), new Grad(-1, -1, 0),\n14      new Grad(1, 0, 1), new Grad(-1, 0, 1), new Grad(1, 0, -1), new Grad(-1, 0, -1),\n15      new Grad(0, 1, 1), new Grad(0, -1, 1), new Grad(0, 1, -1), new Grad(0, -1, -1)\n16    ];\n17    this.p = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30,\n18      69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219,\n19      203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74,\n20      165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105,\n21      92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208,\n22      89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217,\n23      226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17,\n24      182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167,\n25      43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246,\n26      97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239,\n27      107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,\n28      138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180\n29    ];\n30    this.perm = new Array(512);\n31    this.gradP = new Array(512);\n32    this.seed(seed);\n33  }\n34  seed(seed) {\n35    if (seed > 0 && seed < 1) seed *= 65536;\n36    seed = Math.floor(seed);\n37    if (seed < 256) seed |= seed << 8;\n38    for (let i = 0; i < 256; i++) {\n39      let v = (i & 1) ? (this.p[i] ^ (seed & 255)) : (this.p[i] ^ ((seed >> 8) & 255));\n40      this.perm[i] = this.perm[i + 256] = v;\n41      this.gradP[i] = this.gradP[i + 256] = this.grad3[v % 12];\n42    }\n43  }\n44  fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }\n45  lerp(a, b, t) { return (1 - t) * a + t * b; }\n46  perlin2(x, y) {\n47    let X = Math.floor(x), Y = Math.floor(y);\n48    x -= X; y -= Y; X &= 255; Y &= 255;\n49    const n00 = this.gradP[X + this.perm[Y]].dot2(x, y);\n50    const n01 = this.gradP[X + this.perm[Y + 1]].dot2(x, y - 1);\n51    const n10 = this.gradP[X + 1 + this.perm[Y]].dot2(x - 1, y);\n52    const n11 = this.gradP[X + 1 + this.perm[Y + 1]].dot2(x - 1, y - 1);\n53    const u = this.fade(x);\n54    return this.lerp(\n55      this.lerp(n00, n10, u),\n56      this.lerp(n01, n11, u),\n57      this.fade(y)\n58    );\n59  }\n60}\n61\n62const Waves = ({\n63  lineColor = \"black\",\n64  backgroundColor = \"transparent\",\n65  waveSpeedX = 0.0125,\n66  waveSpeedY = 0.005,\n67  waveAmpX = 32,\n68  waveAmpY = 16,\n69  xGap = 10,\n70  yGap = 32,\n71  friction = 0.925,\n72  tension = 0.005,\n73  maxCursorMove = 100,\n74  style = {},\n75  className = \"\"\n76}) => {\n77  const containerRef = useRef(null);\n78  const canvasRef = useRef(null);\n79  const ctxRef = useRef(null);\n80  const boundingRef = useRef({ width: 0, height: 0, left: 0, top: 0 });\n81  const noiseRef = useRef(new Noise(Math.random()));\n82  const linesRef = useRef([]);\n83  const mouseRef = useRef({\n84    x: -10, y: 0, lx: 0, ly: 0, sx: 0, sy: 0, v: 0, vs: 0, a: 0, set: false\n85  });\n86\n87  const configRef = useRef({\n88    lineColor, waveSpeedX, waveSpeedY, waveAmpX, waveAmpY,\n89    friction, tension, maxCursorMove, xGap, yGap\n90  });\n91  const frameIdRef = useRef(null);\n92\n93  useEffect(() => {\n94    configRef.current = { lineColor, waveSpeedX, waveSpeedY, waveAmpX, waveAmpY, friction, tension, maxCursorMove, xGap, yGap };\n95  }, [lineColor, waveSpeedX, waveSpeedY, waveAmpX, waveAmpY, friction, tension, maxCursorMove, xGap, yGap]);\n96\n97  useEffect(() => {\n98    const canvas = canvasRef.current;\n99    const container = containerRef.current;\n100    ctxRef.current = canvas.getContext(\"2d\");\n101\n102    function setSize() {\n103      boundingRef.current = container.getBoundingClientRect();\n104      canvas.width = boundingRef.current.width;\n105      canvas.height = boundingRef.current.height;\n106    }\n107\n108    function setLines() {\n109      const { width, height } = boundingRef.current;\n110      linesRef.current = [];\n111      const oWidth = width + 200, oHeight = height + 30;\n112      const { xGap, yGap } = configRef.current;\n113      const totalLines = Math.ceil(oWidth / xGap);\n114      const totalPoints = Math.ceil(oHeight / yGap);\n115      const xStart = (width - xGap * totalLines) / 2;\n116      const yStart = (height - yGap * totalPoints) / 2;\n117      for (let i = 0; i <= totalLines; i++) {\n118        const pts = [];\n119        for (let j = 0; j <= totalPoints; j++) {\n120          pts.push({\n121            x: xStart + xGap * i,\n122            y: yStart + yGap * j,\n123            wave: { x: 0, y: 0 },\n124            cursor: { x: 0, y: 0, vx: 0, vy: 0 }\n125          });\n126        }\n127        linesRef.current.push(pts);\n128      }\n129    }\n130\n131    function movePoints(time) {\n132      const lines = linesRef.current, mouse = mouseRef.current, noise = noiseRef.current;\n133      const { waveSpeedX, waveSpeedY, waveAmpX, waveAmpY, friction, tension, maxCursorMove } = configRef.current;\n134      lines.forEach((pts) => {\n135        pts.forEach((p) => {\n136          const move = noise.perlin2(\n137            (p.x + time * waveSpeedX) * 0.002,\n138            (p.y + time * waveSpeedY) * 0.0015\n139          ) * 12;\n140          p.wave.x = Math.cos(move) * waveAmpX;\n141          p.wave.y = Math.sin(move) * waveAmpY;\n142\n143          const dx = p.x - mouse.sx, dy = p.y - mouse.sy;\n144          const dist = Math.hypot(dx, dy), l = Math.max(175, mouse.vs);\n145          if (dist < l) {\n146            const s = 1 - dist / l;\n147            const f = Math.cos(dist * 0.001) * s;\n148            p.cursor.vx += Math.cos(mouse.a) * f * l * mouse.vs * 0.00065;\n149            p.cursor.vy += Math.sin(mouse.a) * f * l * mouse.vs * 0.00065;\n150          }\n151\n152          p.cursor.vx += (0 - p.cursor.x) * tension;\n153          p.cursor.vy += (0 - p.cursor.y) * tension;\n154          p.cursor.vx *= friction;\n155          p.cursor.vy *= friction;\n156          p.cursor.x += p.cursor.vx * 2;\n157          p.cursor.y += p.cursor.vy * 2;\n158          p.cursor.x = Math.min(maxCursorMove, Math.max(-maxCursorMove, p.cursor.x));\n159          p.cursor.y = Math.min(maxCursorMove, Math.max(-maxCursorMove, p.cursor.y));\n160        });\n161      });\n162    }\n163\n164    function moved(point, withCursor = true) {\n165      const x = point.x + point.wave.x + (withCursor ? point.cursor.x : 0);\n166      const y = point.y + point.wave.y + (withCursor ? point.cursor.y : 0);\n167      return { x: Math.round(x * 10) / 10, y: Math.round(y * 10) / 10 };\n168    }\n169\n170    function drawLines() {\n171      const { width, height } = boundingRef.current;\n172      const ctx = ctxRef.current;\n173      ctx.clearRect(0, 0, width, height);\n174      ctx.beginPath();\n175      ctx.strokeStyle = configRef.current.lineColor;\n176      linesRef.current.forEach((points) => {\n177        let p1 = moved(points[0], false);\n178        ctx.moveTo(p1.x, p1.y);\n179        points.forEach((p, idx) => {\n180          const isLast = idx === points.length - 1;\n181          p1 = moved(p, !isLast);\n182          const p2 = moved(points[idx + 1] || points[points.length - 1], !isLast);\n183          ctx.lineTo(p1.x, p1.y);\n184          if (isLast) ctx.moveTo(p2.x, p2.y);\n185        });\n186      });\n187      ctx.stroke();\n188    }\n189\n190    function tick(t) {\n191      const mouse = mouseRef.current;\n192      mouse.sx += (mouse.x - mouse.sx) * 0.1;\n193      mouse.sy += (mouse.y - mouse.sy) * 0.1;\n194      const dx = mouse.x - mouse.lx, dy = mouse.y - mouse.ly;\n195      const d = Math.hypot(dx, dy);\n196      mouse.v = d;\n197      mouse.vs += (d - mouse.vs) * 0.1;\n198      mouse.vs = Math.min(100, mouse.vs);\n199      mouse.lx = mouse.x; mouse.ly = mouse.y;\n200      mouse.a = Math.atan2(dy, dx);\n201      container.style.setProperty(\"--x\", `${mouse.sx}px`);\n202      container.style.setProperty(\"--y\", `${mouse.sy}px`);\n203\n204      movePoints(t);\n205      drawLines();\n206      frameIdRef.current = requestAnimationFrame(tick);\n207    }\n208\n209    function onResize() {\n210      setSize();\n211      setLines();\n212    }\n213    function onMouseMove(e) { updateMouse(e.clientX, e.clientY); }\n214    function onTouchMove(e) {\n215      const touch = e.touches[0];\n216      updateMouse(touch.clientX, touch.clientY);\n217    }\n218    function updateMouse(x, y) {\n219      const mouse = mouseRef.current, b = boundingRef.current;\n220      mouse.x = x - b.left;\n221      mouse.y = y - b.top;\n222      if (!mouse.set) {\n223        mouse.sx = mouse.x; mouse.sy = mouse.y;\n224        mouse.lx = mouse.x; mouse.ly = mouse.y;\n225        mouse.set = true;\n226      }\n227    }\n228\n229    setSize();\n230    setLines();\n231    frameIdRef.current = requestAnimationFrame(tick);\n232    window.addEventListener(\"resize\", onResize);\n233    window.addEventListener(\"mousemove\", onMouseMove);\n234    window.addEventListener(\"touchmove\", onTouchMove, { passive: false });\n235\n236    return () => {\n237      window.removeEventListener(\"resize\", onResize);\n238      window.removeEventListener(\"mousemove\", onMouseMove);\n239      window.removeEventListener(\"touchmove\", onTouchMove);\n240      cancelAnimationFrame(frameIdRef.current);\n241    };\n242  }, []);\n243\n244  return (\n245    <div\n246      ref={containerRef}\n247      style={{\n248        backgroundColor,\n249        ...style\n250      }}\n251      className={`absolute top-0 left-0 w-full h-full overflow-hidden ${className}`}\n252    >\n253      <div\n254        className=\"absolute top-0 left-0 bg-[#160000] rounded-full w-[0.5rem] h-[0.5rem]\"\n255        style={{\n256          transform: \"translate3d(calc(var(--x) - 50%), calc(var(--y) - 50%), 0)\",\n257          willChange: \"transform\"\n258        }}\n259      />\n260      <canvas\n261        ref={canvasRef}\n262        className=\"block w-full h-full\"\n263      />\n264    </div>\n265  );\n266}\n267\n268export default Waves;\n269",
  "category": "backgrounds",
  "scrapedAt": "2025-04-27T11:47:51.878Z",
  "previewImage": "waves-preview.png"
}